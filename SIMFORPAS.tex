%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Template para PFC                      %
%                                                       %
%    Comandos para pasar a pdf:                         %
%      1.- Pasamos a ps.                                %
%         dvips ComunicaDocumentacionPFC.dvi            %
%      2.- Pasamos a pdf.                               %
%         ps2pdf ComunicaDocumentacionPFC.ps            %
%Llamad al DocToPdf.bat para hacerlo de manera autom√°tica  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%aloo
\documentclass[12pt,a4paper,spanish]{book} %%%Esto indica el tipo de documento.
\usepackage[left=3cm,top=2.5cm,right=3cm,bottom=3.5cm]{geometry} 
%Va a ser un libro (book), el tama√±o es a4, la lengua castellano (spanish)%%%
\usepackage{babel} %%%Incluimos el paquete Babel
%que sirve para separar correctamente
%las palabras de multitud de idiomas%%%
\usepackage[latin1]{inputenc}
\usepackage{eurosym}
%%%Este paquete permite poner acentos directamente%%%
\usepackage{amsmath}%%%Macros AMS%%%
\usepackage{amsthm}%%%Macros AMS para teoremas%%%
\usepackage{amsfonts}%%%Permite usar fuentes AMS%%%
\usepackage{amssymb}
%\usepackage[dvips]{epsfig} %%%Inclusi√≥n de figuras postscript% con
%visualizaci√≥n posterior%%%\usepackage{indentfirst}%%%Espaciado de
\usepackage[dvips]{graphicx}
\usepackage{titlesec}
\usepackage{lettrine}
\usepackage{eso-pic} 
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{parskip}
\usepackage{float}
\usepackage{ifthen}
\usepackage{type1cm}
\usepackage{times}



%C√≥digo java%
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}

\usepackage{listings}
\lstset{ frame=Ltb,
     framerule=0pt,
     aboveskip=0.5cm,
     framextopmargin=3pt,
     framexbottommargin=3pt,
     framexleftmargin=0.4cm,
     framesep=0pt,
     rulesep=.4pt,
     backgroundcolor=\color{gray97},
     rulesepcolor=\color{black},
     %
     stringstyle=\ttfamily,
     showstringspaces = false,
     basicstyle=\scriptsize\ttfamily,
     commentstyle=\color{green},
     keywordstyle=\color{blue},
     %
     breaklines=true,     
   }
 
% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
   {\lstset{#1}\pagebreak[0]}{\pagebreak[0]}
 
\lstdefinestyle{consola}
   {basicstyle=\scriptsize\bf\ttfamily,
    backgroundcolor=\color{gray75},
   }
 
\lstdefinestyle{Java}
   {language=Java,
   }


\let\oldcleardoublepage\cleardoublepage
\renewcommand{\cleardoublepage}{\newpage{\pagestyle{empty}\oldcleardoublepage}}

%Cabecera%
\date{}
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\pagestyle{fancyplain}
\newcommand{\diezpuntos}{\fontsize{8pt}{\baselineskip}\selectfont}
\addtolength{\headheight}{1\baselineskip}
\lhead{\diezpuntos ITIGesti√≥n}
%\chead{\diezpuntos }%
\rhead[\diezpuntos \bfseries \leftmark]{\diezpuntos \bfseries \rightmark}
\renewcommand{\headrulewidth}{0.5 pt}
\renewcommand{\footrulewidth}{0pt}
\lfoot{\diezpuntos}

%%%%%%%%%%
%Comandos%
%%%%%%%%%%

%Fuente por defecto%
%\renewcommand{\familydefault}{\sfdefault}
%*Marquesina*%
\newcommand\BackgroundPicR{ 
\put(540,0){ 
\parbox[b][\paperheight]{3cm}{% 
\vfill 
\includegraphics[width=3cm,height=\paperheight, 
keepaspectratio]{img/Clouds.eps}% 
\vfill 
}}} 

%\newcommand\BackgroundPicL{ 
%\put(-5,0){ 
%\parbox[b][\paperheight]{3cm}{% 
%\vfill 
%\includegraphics[width=3cm,height=\paperheight, 
%keepaspectratio]{img/Clouds.eps}% 
%\vfill 
%}}} 
%
%\newcommand\BackgroundPic{\ifthenelse{\isodd{\thepage}}
% {\BackgroundPicR}{\BackgroundPicL}}

%Listas sin enumerar%
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\bullet$}
\renewcommand{\labelitemiii}{$\bullet$}
%Listas enumeradas%
\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\labelenumi}{%
\textbf{\theenumi}.-
}
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\labelenumii}{%
\textbf{\theenumi}.\theenumii.-
}
\renewcommand{\theenumiii}{\arabic{enumiii}}
\renewcommand{\labelenumiii}{%
\textbf{\theenumi}.\theenumii.\theenumiii.-
}

%Citas%
\let\oldquote\quote
\renewcommand\quote{\par\singlespacing\small\oldquote}
\let\oldquotation\quotation
\renewcommand\quotation[1]{\oldquotation\small\hfill{\emph{\color{blue!
10!black}{#1}}}}
 \let\oldverse\verse
\renewcommand\verse{\par\singlespacing\small\oldverse}

%Capital%
\renewcommand{\LettrineFontHook}{\color{blue! 30!black}}

%Imagenes%
\newcommand{\imgIncl}[3]{
  \begin{figure}[here]
		\begin{center}
		\includegraphics[width=#1cm,angle=#2]{#3}
		\label{fig:#3}
		\end{center}
	\end{figure}
	
	}

\newcommand{\imgCentrada}[3]{
\begin{figure}[H]
\begin{center}
\includegraphics[width=12cm]{#2}
\caption{#3}
\label{#1}
\end{center}
\end{figure}
}

\newcommand{\imgCentradaGrande}[3]{
\begin{figure}[H]
\begin{center}
\includegraphics[width=16cm]{#2}
\caption{#3}
\label{#1}
\end{center}
\end{figure}
}

\newcommand{\imgCentradaMed}[3]{
\begin{figure}[H]
\begin{center}
\includegraphics[width=9cm]{#2}
\caption{#3}
\label{#1}
\end{center}
\end{figure}
}


\newcommand{\imgCentradaPeq}[3]{
\begin{figure}[H]
\begin{center}
\includegraphics[width=6cm]{#2}
\caption{#3}
\label{#1}
\end{center}
\end{figure}
}
	
%Parte%
\newcommand{\bigrule}{\titlerule[0.5mm]}
<<<<<<< HEAD
\titleformat{\part}[display] % cambiamos el formato de los capÌ≠tulos
{\bfseries\Huge} % por defecto se usar·n caracteres de tamaÒo \Huge en negrita
{% contenido de la etiqueta
\titlerule % lÌ≠nea horizontal
\filleft % texto alineado a la derecha
\Large{Parte}  % "Parte" en tamaÒo \Large en lugar de \Huge
\Large\thepart} % n˙mero de capÌ≠tulo en tamaÒo \Large
{0mm} % espacio mÌ≠nimo entre etiqueta y cuerpo
{\filleft} % texto del cuerpo alineado a la derecha
[\vspace{0.5mm} \bigrule \vspace{4cm}] % despuÈs del cuerpo, dejar espacio vertical y trazar lÌ≠nea horizontal gruesa

%Capitulo%
\titleformat{\chapter}[hang] % cambiamos el formato de los capÌ≠tulos
{\bfseries\Large} % por defecto se usar·n caracteres de tamaÒo \Huge en negrita
{% contenido de la etiqueta
\color{blue! 30!black}
\Large\chaptertitlename\ %"CapÌ≠tulo" o "ApÈndice" en tamaÒo \Large en lugar de \Huge
\Large\thechapter .} % n˙mero de capÌ≠tulo en tamaÒo \Large
{2mm} % espacio mÌ≠nimo entre etiqueta y cuerpo
{\filright\color{blue! 30!black}} % texto del cuerpo alineado a la derecha
[\vspace{0.5mm}] % despuÈs del cuerpo, dejar espacio vertical y trazar lÌ≠nea horizontal gruesa
=======
\titleformat{\part}[display] % cambiamos el formato de los cap√≠tulos
{\bfseries\Huge} % por defecto se usar√°n caracteres de tama√±o \Huge en negrita
{% contenido de la etiqueta
\titlerule % l√≠nea horizontal
\filleft % texto alineado a la derecha
\Large{Parte}  % "Parte" en tama√±o \Large en lugar de \Huge
\Large\thepart} % n√∫mero de cap√≠tulo en tama√±o \Large
{0mm} % espacio m√≠nimo entre etiqueta y cuerpo
{\filleft} % texto del cuerpo alineado a la derecha
[\vspace{0.5mm} \bigrule \vspace{4cm}] % despu√©s del cuerpo, dejar espacio vertical y trazar l√≠nea horizontal gruesa

%Capitulo%
\titleformat{\chapter}[hang] % cambiamos el formato de los cap√≠tulos
{\bfseries\Large} % por defecto se usar√°n caracteres de tama√±o \Huge en negrita
{% contenido de la etiqueta
\color{blue! 30!black}
\Large\chaptertitlename\ %"Cap√≠tulo" o "Ap√©ndice" en tama√±o \Large en lugar de \Huge
\Large\thechapter .} % n√∫mero de cap√≠tulo en tama√±o \Large
{2mm} % espacio m√≠nimo entre etiqueta y cuerpo
{\filright\color{blue! 30!black}} % texto del cuerpo alineado a la derecha
[\vspace{0.5mm}] % despu√©s del cuerpo, dejar espacio vertical y trazar l√≠nea horizontal gruesa
>>>>>>> FETCH_HEAD

%Secciones%
\titleformat{\section}[hang]
{\scshape\bfseries\Large}
{\color{blue! 30!black}\thesection. }
{0mm}{\filright\color{blue! 30!black}}[\vspace{0.5mm}]

%SubSecciones%
\titleformat{\subsection}[hang]
{\scshape\bfseries\large}
{\color{blue! 30!black}\thesubsection .}
{0mm}{\filright\color{blue! 30!black}}[\vspace{0.5mm}]

%SubsubSecciones%
\titleformat{\subsubsection}[hang]
{\scshape\bfseries}
{\color{blue! 30!black}\thesubsubsection .}
{0mm}{\filright\color{blue! 30!black}}[\vspace{0.5mm}]

%%%%%%%%%%%%%%%%%
%Fin de comandos%
%%%%%%%%%%%%%%%%%

\author{Manuel Mateos Guti√©rrez.}
\title{SIMFORPAS}
\begin{document}
<<<<<<< HEAD
%%%AquÌ≠ empieza el documento%%%
=======
%%%Aqu√≠ empieza el documento%%%
>>>>>>> FETCH_HEAD
\pagenumbering{roman}
%\maketitle
%%%Portada%%%
\begin{titlepage}
\bfseries
\begin{center}
    \includegraphics[width=0.3\textwidth]{img/LOGO.eps}
    \bigbreak
    \bigbreak
    \bigbreak
    ESCUELA T√âCNICA SUPERIOR DE INGENIER√çA INFORM√ÅTICA
    \bigbreak
    \bigbreak
    INGENIER√çA T√âCNICA EN INFORM√ÅTICA DE GESTI√ìN
    \bigbreak
    \bigbreak
    \bigbreak
    \bigbreak
    \bigbreak
    \bigbreak
    {\LARGE SIMFORPAS}
    \smallbreak
    {\large Simulador para RPAS}
    \bigbreak
    \bigbreak    
    \bigbreak
    \bigbreak
    \bigbreak
    Realizado por
    \smallbreak
    MANUEL MATEOS GUTI√âRREZ\\
    32076954-G

    \bigbreak
    \bigbreak
    Dirigido por
    \smallbreak
    IRENE ALEJO TEISSI\`ERE
    \smallbreak
    PABLO TRINIDAD MART√çN-ARROYO
    \bigbreak
    \bigbreak
    Departamento
    \smallbreak
    LENGUAJES Y SISTEMAS INFORM√ÅTICOS
\end{center}
    \vfill
\begin{flushright}
Sevilla, Mayo de 2014
\end{flushright}
\end{titlepage}
%%%FIN de Portada%%%

\vspace*{7cm}
%AGRADECIMIENTOS
\setlength{\parindent}{1cm}
\chapter*{Agradecimientos}
Agradecimientos
\cleardoublepage

\tableofcontents
\listoffigures

\cleardoublepage

\pagenumbering{arabic}

\part{Introducci√≥n}


 
%\AddToShipoutPicture{\BackgroundPic}

\chapter{Introducci√≥n}

<<<<<<< HEAD
\newpage
\section{Estructura del documento}

…ste documento se estructura en las siguientes partes:

\textbf{PREFACIO:} En Èste capÌ≠tulo se introduce el proyecto creando el contexto de su implementaciÛn, explicando en quÈ consiste, la motivaciÛn que nos ha llevado a desarrollarlo, asÌ≠ como Èste mismo apartado de estructura del proyecto en el que explicamos quÈ vamos a encontrarnos en Èsta memoria y cÛmo est· distribuida y un Ì≠ndice de contenidos y de figuras.
=======
\lettrine{A}{UNQUE} el concepto de aviones no tripulados o UAV's (Unmanned Aerial Vehicles) es bastante antiguo, puesto que se empezaron a usar durante la primera guerra mundial, cada d√≠a o√≠mos m√°s hablar sobre ellos en los medios de comunicaci√≥n, esto se debe al gran crecimiento que est√° sufriendo el sector de la aeron√°utica en torno a estos dispositivos, tanto para uso militar, como los famosos "drones" de Estados Unidos, como civil.

Su uso es amplio y variado, desde rodaje de planos a√©reos en pel√≠culas de cine hasta control de incendios, control de costas, recogida de informaci√≥n, ayuda en operaciones de rescate, control de multitudes...

\imgCentrada{fig.1.1}{img/incendio.eps}{Soporte a√©reo en el control de incendios.}

A finales del siglo XX fue cuando los UAV's empiezan a operar con todas las caracter√≠sticas de autonom√≠a. Esto nos provee de muchas ventajas, por ejemplo, presencia en lugares de dif√≠cil acceso sin necesidad de llevar al terreno a un piloto de UAV, reducci√≥n del riesgo humano en determinadas situaciones, disminuci√≥n del la incursi√≥n humana sobre parques naturales y zonas protegidas... . Poco a poco los UAV's tienden a prescindir de la presencia de un piloto que tenga la obligaci√≥n de estar visualizando el avi√≥n y a implementar sistemas de control remoto mediante estaciones de control de tierra o GCS's (Ground Control Stations) y de vuelo automatizado, lo que nos llevar√° a no depender del factor humano. 

Las GCS son controladas por operadores expertos en estos dispositivos que se encargan de dise\'nar e implementar las misiones que realizar√°n los aviones, as√≠ como llevar el control del curso de la misma, conocer las caracter√≠sticas de la aeronave, deben saber interpretar los indicadores de telemetr√≠a, estar familiarizados con el protocolo de comunicaci√≥n y saber reaccionar ante posibles fallos durante la misi√≥n para salvaguardar en todo momento la seguridad tanto del veh√≠culo a√©reo como del entorno en el que se mueve.

Estos operadores requieren de una formaci√≥n en profundidad y fiable ya que tienen la responsabilidad sobre las acciones que realice la aeronave, por ello se debe exigir un entrenamiento concienzudo. Si este entrenamiento es realizado con dispositivos reales corremos el riesgo de que frente a cualquier fallo, error humano o de car√°cter inform√°tico, haya una p√©rdida en alg√∫n componente del sistema, ya sea que se estrelle la aeronave, que da\'ne alguna estructura o a alguna persona, lo que resultar√≠a en una importante p√©rdida econ√≥mica y/o humana. 

Para ilustrar la necesidad de la implementaci√≥n de un sistema de evaluaci√≥n de pilotos tendremos en cuenta, entre otros factores los m√∫ltiples accidentes que ha habido en los √∫ltimos a√±os, la mayor√≠a de ellos debido a descuidos o a la falta de experiencia de los operadores de GCS. Uno de los casos que pueden darse es el de la falta de pruebas del sistema por parte de los desarrolladores la cual puede llevar a que los operadores puedan mandar comandos err√≥neos al avi√≥n provocando as√≠ un accidente, como pas√≥ en el accidente del UAV tipo Predator en Septiembre del a√±o 2000 cuando un piloto por equivocaci√≥n liber√≥ la memoria del UAV provocando un corte en las comunicaciones el cual no pudieron recuperar antes de que el avi√≥n se estrellara (Datos de la FAA, Federal Aviation Administration, de Estados Unidos durante una conferencia sobre seguridad durante vuelos de UAV dada por Kevin W. Williams), si se hubiera podido probar el software de forma segura sin poner en peligro el avi√≥n √©ste error podr√≠a haberse evitado.

\imgCentrada{fig.1.2}{img/predator.eps}{UAV tipo Predator en vuelo.}

Otro ejemplo de error com√∫n que podemos encontrar en la informaci√≥n ofrecida por la FAA es el de la falta de experiencia de los operadores controlando los mandos, uno de los ejemplos de este tipo de error fue el accidente ocurrido en abril de 2006, el dispositivo de control de tierra constaba de dos estaciones iguales, una destinada al manejo de la aeronave y otra al de la c√°mara. En un momento dado se detect√≥ un error en la comunicaci√≥n entre el avi√≥n y la GCS y decidieron cambiar la funci√≥n de las estaciones entre s√≠, pero la posici√≥n en la que se encontraba la estaci√≥n que controlaba la c√°mara, concretamente una palanca que cerraba el diafragma de la misma, ordenaba al controlar el UAV que se parara el motor, de forma que en el momento del cambio perdieron el control de la aeronave estrell√°ndola. 

\imgCentrada{fig.1.3}{img/predatorgcs.eps}{GCS usada para el UAV Predator.}

En este accidente los pilotos ten√≠an poca experiencia de vuelo y ning√∫n certificado acreditativo para poder manejar este tipo de instrumental, la alarma del indicador de que algo iba mal no era espec√≠fica para ese error por lo que no se tuvo en cuenta. Un error tan importante como la no implantaci√≥n de un protocolo de comprobaciones al iniciar una nueva estaci√≥n de control para volar un UAV podr√≠a haber sido evitado si se incluyera en un curso obligatorio para operadores de estos dispositivos.

El proyecto SIMFORPAS pretende dar una soluci√≥n a este problema presentando un entorno de simulaci√≥n de vuelo de UAV's para operadores de GCS en formaci√≥n, que proveer√° de un contexto de vuelo seguro e id√©ntico a una situaci√≥n real de control de misi√≥n de un UAV.
\newpage
\section{Motivaci√≥n}

\lettrine{S}{eg√∫n} un estudio publicado por el medio online \emph{Update Defense} y realizado por la firma de investigaci√≥n de mercados \emph{ICD Research} durante la pr√≥xima d√©cada el sector de la aviaci√≥n no tripulada tendr√° un aumento anual del 4,08\% lo que supondr√° que en 2021 alcance alrededor de los 10.500 millones de d√≥lares. El gran incremento de la demanda  se traducir√° en una mayor necesidad de infraestructuras y tecnolog√≠as en torno a estos dispositivos.

En vistas de estas espectativas resulta interesante implicarse de una forma activa en un mercado en auge que supondr√° la aceptaci√≥n de un gran n√∫mero de nuevas tecnolog√≠as y traer√° nuevos desaf√≠os en cuanto a investigaci√≥n y desarrollo.

Uno de los requisitos que tendr√° esta etapa ser√° pa de disponer de personal cualificado para la manipulaci√≥n de los dispositivos de pilotage remotos de aeronaves no tripuladas, el proyecto SIMFORPAS pretende ocupar ese hueco proveyendo de un entorno seguro y fiable que permita conceder una certificaci√≥n avanzada a operadores de GCS de forma que se aseguren los conocimientos t√©cnicos necesarios en una situaci√≥n real de pilotage.

En este proyecto propondremos una soluci√≥n usando una serie de tecnolog√≠as que nos proveer√°n de las herramientas necesarias para crear el sistema necesario para la consecuci√≥n de nuestro objetivo.
>>>>>>> FETCH_HEAD

\textbf{}

<<<<<<< HEAD
\textbf{CONCEPTOS B¡SICOS:} Introducimos las metodologÌ≠as que hemos usado durante el desarrollo del proyecto asÌ≠ como los conceptos b·sicos necesarios para comprender todo el documento, una enumeraciÛn de tecnologÌ≠as usadas y un glosario de terminologÌ≠a, tambiÈn se explicar· el mÈtodo de desarrollo iterativo e incremental que hemos llevado a cabo y en el que se basa la documentaciÛn del proyecto.

\textbf{SISTEMA A DESARROLLAR:} AquÌ≠ se enumerar·n cada una de las etapas de desarrollo que ha ido sufriendo el proyecto SIMFORPAS desarrollando la planificaciÛn para cada iteraciÛn y cada problema que ha ido surgiendo durante el mismo, tambiÈn se aportar· el diagrama de Burndown para monitorizar en todo momento el estado del proyecto.

\textbf{CONCLUSIONES:} Realizaremos una retrospectiva final del proyecto analizando su estado final, la consecuciÛn de los objetivos, los cambios con respecto a la planificaciÛn inicial que se han realizado y las posibles mejoras y futuro del proyecto SIMFORPAS.

\textbf{APENDICES:} Para finalizar aÒadiremos un apÈndice de definiciones, un manual de usuario y la bibliografÌ≠a usada durante el desarrollo del proyecto y la memoria.

\lettrine{A}{UNQUE} el concepto de aviones no tripulados o UAV's (Unmanned Aerial Vehicles) es bastante antiguo, puesto que se empezaron a usar durante la primera guerra mundial, cada dÌ≠a oÌ≠mos m·s hablar sobre ellos en los medios de comunicaciÛn, esto se debe al gran crecimiento que est· sufriendo el sector de la aeron·utica en torno a estos dispositivos, tanto para uso militar, como los famosos "drones" de Estados Unidos, como civil.

Su uso es amplio y variado, desde rodaje de planos aÈreos en pelÌ≠culas de cine hasta control de incendios, control de costas, recogida de informaciÛn, ayuda en operaciones de rescate, control de multitudes...

\imgCentrada{fig.1.1}{img/incendio.eps}{Soporte aÈreo en el control de incendios.}

A finales del siglo XX fue cuando los UAV's empiezan a operar con todas las caracterÌ≠sticas de autonomÌ≠a. Esto nos provee de muchas ventajas, por ejemplo, presencia en lugares de difÌ≠cil acceso sin necesidad de llevar al terreno a un piloto de UAV, reducciÛn del riesgo humano en determinadas situaciones, disminuciÛn del la incursiÛn humana sobre parques naturales y zonas protegidas... . Poco a poco los UAV's tienden a prescindir de la presencia de un piloto que tenga la obligaciÛn de estar visualizando el aviÛn y a implementar sistemas de control remoto mediante estaciones de control de tierra o GCS's (Ground Control Stations) y de vuelo automatizado, lo que nos llevar· a no depender del factor humano. 

Las GCS son controladas por operadores expertos en estos dispositivos que se encargan de dise\'nar e implementar las misiones que realizar·n los aviones, asÌ≠ como llevar el control del curso de la misma, conocer las caracterÌ≠sticas de la aeronave, deben saber interpretar los indicadores de telemetrÌ≠a, estar familiarizados con el protocolo de comunicaciÛn y saber reaccionar ante posibles fallos durante la misiÛn para salvaguardar en todo momento la seguridad tanto del vehÌ≠culo aÈreo como del entorno en el que se mueve.

Estos operadores requieren de una formaciÛn en profundidad y fiable ya que tienen la responsabilidad sobre las acciones que realice la aeronave, por ello se debe exigir un entrenamiento concienzudo. Si este entrenamiento es realizado con dispositivos reales corremos el riesgo de que frente a cualquier fallo, error humano o de car·cter inform·tico, haya una pÈrdida en alg˙n componente del sistema, ya sea que se estrelle la aeronave, que da\'ne alguna estructura o a alguna persona, lo que resultarÌ≠a en una importante pÈrdida econÛmica y/o humana. 

Para ilustrar la necesidad de la implementaciÛn de un sistema de evaluaciÛn de pilotos tendremos en cuenta, entre otros factores los m˙ltiples accidentes que ha habido en los ˙ltimos aÒos, la mayorÌ≠a de ellos debido a descuidos o a la falta de experiencia de los operadores de GCS. Uno de los casos que pueden darse es el de la falta de pruebas del sistema por parte de los desarrolladores la cual puede llevar a que los operadores puedan mandar comandos errÛneos al aviÛn provocando asÌ≠ un accidente, como pasÛ en el accidente del UAV tipo Predator en Septiembre del aÒo 2000 cuando un piloto por equivocaciÛn liberÛ la memoria del UAV provocando un corte en las comunicaciones el cual no pudieron recuperar antes de que el aviÛn se estrellara (Datos de la FAA, Federal Aviation Administration, de Estados Unidos durante una conferencia sobre seguridad durante vuelos de UAV dada por Kevin W. Williams), si se hubiera podido probar el software de forma segura sin poner en peligro el aviÛn Èste error podrÌ≠a haberse evitado.

\imgCentrada{fig.1.2}{img/predator.eps}{UAV tipo Predator en vuelo.}

Otro ejemplo de error com˙n que podemos encontrar en la informaciÛn ofrecida por la FAA es el de la falta de experiencia de los operadores controlando los mandos, uno de los ejemplos de este tipo de error fue el accidente ocurrido en abril de 2006, el dispositivo de control de tierra constaba de dos estaciones iguales, una destinada al manejo de la aeronave y otra al de la c·mara. En un momento dado se detectÛ un error en la comunicaciÛn entre el aviÛn y la GCS y decidieron cambiar la funciÛn de las estaciones entre sÌ≠, pero la posiciÛn en la que se encontraba la estaciÛn que controlaba la c·mara, concretamente una palanca que cerraba el diafragma de la misma, ordenaba al controlar el UAV que se parara el motor, de forma que en el momento del cambio perdieron el control de la aeronave estrell·ndola. 

\imgCentrada{fig.1.3}{img/predatorgcs.eps}{GCS usada para el UAV Predator.}
=======
\lettrine{E}{l} objetivo de este proyecto ser√° el de crear una plataforma de simulaci√≥n para la formaci√≥n y entrenamiento de pilotos de RPAS (Remotely Piloted Aircraft System) ligeros que se comporte exactamente como lo har√≠a el avi√≥n real. Que el sistema permita hacer uso de una GCS homologada para el manejo de UAV's usando un protocolo de comunicaciones para aviones no tripulados de menos de 25 Kg y usando un modelo de avi√≥n real.

Tambi√©n se requerir√° de una herramienta que permita a un instructor ser capaz de controlar la simulaci√≥n permiti√©ndole manejar su curso e introducir errores en el sistema. La simulaci√≥n se deber√° hacer en tiempo real.

Para garantizar la correcta consecuci√≥n de los objetivos generales del proyecto se utilizar√° la herramienta de organizaci√≥n SCRUM junto a otras metodolog√≠as de desarrollo √°gil.

\subsection{Objetivos orientados a la metodolog√≠a}

Los objetivos que se tienen en mente al realizar esta aplicaci√≥n con respecto a
las metodolog√≠as usadas son los siguientes:

\begin{itemize}
  \item Aplicar el marco de trabajo Scrum, usando para ello los conocimientos
  adquiridos al trabajar en empresas que utilizan dicha metodolog√≠a y cursos.
  Tambi√©n se dispone del apoyo bibliogr√°fico de libros como \emph{Agile Samurai} y \emph{Agile Software Development with Scrum}

  \item Aplicar metodolog√≠as de programaci√≥n en pareja para agilizar el desarrollo y evitar errores en el c√≥digo.

  \item Aplicar los principios S.O.L.I.D. como base de un c√≥digo robusto, limpio y sujeto a cambios.

  \item Aplicar metodolog√≠as de eXtreme Programming para asegurar que el c√≥digo acepte cambios de manera sencilla e intuitiva.

  \item Comprobar los beneficios colaterales a la realizaci√≥n de estas
  pr√°cticas como, por ejemplo, la facilidad de a\'nadir nuevas tareas durante el
  proceso de desarrollo.
 
\end{itemize}

\subsection{Objetivos orientados a la t√©cnica}

Los objetivos que se han querido validar al realizar esta aplicaci√≥n son los
siguientes:

\begin{itemize}
  \item Aprender y utilizar tecnolog√≠as que garanticen una comunicaci√≥n y procesado de datos en tiempo real como pueden ser C++ y DDS.
  
  \item Aprender y utilizar para el puesto de instructor herramientas que ayuden al desarrollo de una plataforma web para el control del simulador como Maven, Struts2, Spring4 e Hibernate4.
  
  \item Aprender y utilizar entornos de testeo de c√≥digo como Google test, Google mock, Junit y Jmock para asegurar que el c√≥digo funciona en todas las fases de desarrollo y modificaci√≥n del software.

  \item Aplicar correctamente cada una de las metodolog√≠as estudiadas y sacar conclusiones de su uso.
  
\end{itemize}
>>>>>>> FETCH_HEAD

En este accidente los pilotos tenÌ≠an poca experiencia de vuelo y ning˙n certificado acreditativo para poder manejar este tipo de instrumental, la alarma del indicador de que algo iba mal no era especÌ≠fica para ese error por lo que no se tuvo en cuenta. Un error tan importante como la no implantaciÛn de un protocolo de comprobaciones al iniciar una nueva estaciÛn de control para volar un UAV podrÌ≠a haber sido evitado si se incluyera en un curso obligatorio para operadores de estos dispositivos.

<<<<<<< HEAD
El proyecto SIMFORPAS pretende dar una soluciÛn a este problema presentando un entorno de simulaciÛn de vuelo de UAV's para operadores de GCS en formaciÛn, que proveer· de un contexto de vuelo seguro e idÈntico a una situaciÛn real de control de misiÛn de un UAV.
\newpage
\section{MotivaciÛn}

\lettrine{S}{eg˙n} un estudio publicado por el medio online \emph{Update Defense} y realizado por la firma de investigaciÛn de mercados \emph{ICD Research} durante la prÛxima dÈcada el sector de la aviaciÛn no tripulada tendr· un aumento anual del 4,08\% lo que supondr· que en 2021 alcance alrededor de los 10.500 millones de dÛlares. El gran incremento de la demanda  se traducir· en una mayor necesidad de infraestructuras y tecnologÌ≠as en torno a estos dispositivos.

En vistas de estas espectativas resulta interesante implicarse de una forma activa en un mercado en auge que supondr· la aceptaciÛn de un gran n˙mero de nuevas tecnologÌ≠as y traer· nuevos desafÌ≠os en cuanto a investigaciÛn y desarrollo.
=======
Se ha querido asegurar que se cumplen los siguientes objetivos a lo largo del
desarrollo de la aplicaci√≥n:

\begin{itemize}
  \item Adaptaci√≥n: Adecuarse a las exigencias de estas nuevas metodolog√≠as. Los
  desarrolladores tienen la motivaci√≥n de aprender nuevas t√©cnicas que mejoren
  la calidad del software.
  
  \item Confianza: Conseguir conocimientos que me permitan en un futuro abatir exitosamente un proyecto software.
  
  \item Experiencia: Adquirir aptitudes para solucionar problemas y a√±adir valor a un grupo de trabajo en un entorno laboral.
  
  \item Conocimientos T√©cnicos: Trabajar y sintetizar nuevas tecnolog√≠as que me sirvan en el futuro para completarme como profesional en mi campo.

\end{itemize}
%COMPROBAR APARTADO DE CONCLUSIONES
Se tendr√°n en cuenta estos objetivos durante la realizaci√≥n del proyecto y se comprobar√° si han sido realizados. Esto se ver√° con detenimiento en los apartados de conclusiones, v√©ase la parte V del presente documento.
>>>>>>> FETCH_HEAD

Uno de los requisitos que tendr· esta etapa ser· pa de disponer de personal cualificado para la manipulaciÛn de los dispositivos de pilotage remotos de aeronaves no tripuladas, el proyecto SIMFORPAS pretende ocupar ese hueco proveyendo de un entorno seguro y fiable que permita conceder una certificaciÛn avanzada a operadores de GCS de forma que se aseguren los conocimientos tÈcnicos necesarios en una situaciÛn real de pilotage.

<<<<<<< HEAD
En este proyecto propondremos una soluciÛn usando una serie de tecnologÌ≠as que nos proveer·n de las herramientas necesarias para crear el sistema necesario para la consecuciÛn de nuestro objetivo.

\section{JustificaciÛn de la metodologÌ≠a usada}

\lettrine{E}{l} proyecto tiene car·cter de investigaciÛn, ya que el objetivo principal ser· el estudio de la viabilidad y la complejidad de un sistema de simulaciÛn implementado en un entorno de aprendizaje, y adem·s es un proyecto interno, por lo que no tenemos un cliente real con unas especificaciones definidas. La funcionalidad del proyecto puede variar a lo largo del desarrollo del mismo y las acciones a realizar pueden variar. Al no tener definidas unas especificaciones concretas el proyecto est· totalmente abierto a cambios.

Debido a esto la metodologÌ≠a que m·s se adecua a nuestra situaciÛn son las metodologÌ≠as ·giles. Si hablamos de la planificaciÛn y guiado del proyecto m·s concretamente usaremos Scrum. …sta metodologÌ≠a de trabajo fracciona el tiempo empleado en "sprints" o iteraciones de desarrollo de corto tiempo durante las cuales se definen unas tareas a realizar y al final de cada uno se analiza el trabajo realizado y se valora si se debe hacer alguna modificaciÛn.

En el ·mbito de la programaciÛn otras tÈcnicas de desarrollo ·gil como pueden ser TDD o Extreme programming tambiÈn nos facilitar·n que la estructura del cÛdigo estÈ abierta a cambios de forma que si hay que realizar alguna modificaciÛn importante no haya que tirar todo el trabajo realizado y empezar desde el principio sino que se pueda reutilizar o facilmente modificar nuestro cÛdigo y adaptarlo a los nuevos cambios.

Por todo esto tanto el desarrollo como la implementaciÛn de la aplicaciÛn se realizar·n siguiendo las pautas del desarrolo ·gil.

\newpage
\ClearShipoutPicture
\part{PanificaciÛn y diseÒo}
\chapter{AplicaciÛn de la metodologÌ≠a}

\lettrine{E}{n} Èste capÌ≠tulo empezaremos haciendo una introducciÛn a las metodologÌ≠as ·giles, explicando su filosofÌ≠a y el por quÈ de su existencia asÌ≠ como una serie de tÈcnicas para implementar este tipo de metodologÌ≠as a nuestro proyecto software y quÈ beneficio nos aporta.

\section{MetodologÌ≠as ·giles}

\lettrine{E}{l} proceso normal afianzado hasta ahora en el desarrollo software sigue unas pautas de rigidez que evita que el producto estÈ sometido a cambios ya que cuanto m·s avanzado est· el desarrollo del proyecto m·s difÌ≠cil y costoso resulta la introducciÛn de modificaciones, para ello se definen unos requisitos que debe cumplir el producto final y antes de empezar el proyecto se decide las tecnologÌ≠as a usar y la planificaciÛn del desarrollo, el cliente no toma parte en el proceso de implementaciÛn sino que cuando llega la fecha indicada para la finalizaciÛn se le presenta y se eval˙a si se ha conseguido el resultado que Èl esperaba.

Como pueden imaginar en la mayorÌ≠a de los casos debido al desconocimiento real del problema no se definen correctamente los requisitos o las tecnologÌ≠as usadas y surgÌ≠an problemas imprevistos en la planificaciÛn que retrasan la fecha de entrega o acortan el tiempo de desarrollo obligando al equipo a dedicar m·s horas repercutiendo todo esto negativamente en el resultado final.
=======
√âste documento se estructura en las siguientes partes:

\textbf{PREFACIO:} En √©ste cap√≠tulo se introduce el proyecto creando el contexto de su implementaci√≥n, explicando en qu√© consiste, la motivaci√≥n que nos ha llevado a desarrollarlo y los objetivos que se quieren cumplir en el mismo, as√≠ como √©ste mismo apartado de estructura del proyecto en el que explicamos qu√© vamos a encontrarnos en √©sta memoria y c√≥mo est√° distribuida y un √≠ndice de contenidos y de figuras.

\textbf{CONCEPTOS B√ÅSICOS:} Introducimos las metodolog√≠as que hemos usado durante el desarrollo del proyecto as√≠ como los conceptos b√°sicos necesarios para comprender todo el documento, una enumeraci√≥n de tecnolog√≠as usadas y un glosario de terminolog√≠a, tambi√©n se explicar√° el m√©todo de desarrollo iterativo e incremental que hemos llevado a cabo y en el que se basa la documentaci√≥n del proyecto.

\textbf{SISTEMA A DESARROLLAR:} Aqu√≠ se enumerar√°n cada una de las etapas de desarrollo que ha ido sufriendo el proyecto SIMFORPAS desarrollando la planificaci√≥n para cada iteraci√≥n y cada problema que ha ido surgiendo durante el mismo, tambi√©n se aportar√° el diagrama de Burndown para monitorizar en todo momento el estado del proyecto.

\textbf{CONCLUSIONES:} Realizaremos una retrospectiva final del proyecto analizando su estado final, la consecuci√≥n de los objetivos, los cambios con respecto a la planificaci√≥n inicial que se han realizado y las posibles mejoras y futuro del proyecto SIMFORPAS.

\textbf{APENDICES:} Para finalizar a√±adiremos un ap√©ndice de definiciones, un manual de usuario y la bibliograf√≠a usada durante el desarrollo del proyecto y la memoria.

\newpage
\ClearShipoutPicture
\part{Conceptos b√°sicos}
\chapter{Metodolog√≠as usadas}
%\AddToShipoutPicture{\BackgroundPic}

\lettrine{E}{n} √©ste cap√≠tulo empezaremos haciendo una introducci√≥n a las metodolog√≠as √°giles, explicando su filosof√≠a y el por qu√© de su existencia as√≠ como una serie de t√©cnicas para implementar este tipo de metodolog√≠as a nuestro proyecto software y qu√© beneficio nos aporta.

El proyecto fue desarrollado haciendo uso del sistema SCRUM de desarrollo iterativo, se explicar√° en qu√© consiste √©ste m√©todo y como ha sido aplicado a SIMFORPAS.

\section{Metodolog√≠as √°giles}

\lettrine{E}{l} proceso normal afianzado hasta ahora en el desarrollo software sigue unas pautas de rigidez que evita que el producto est√© sometido a cambios ya que cuanto m√°s avanzado est√° el desarrollo del proyecto m√°s dif√≠cil y costoso resulta la introducci√≥n de modificaciones, para ello se definen unos requisitos que debe cumplir el producto final y antes de empezar el proyecto se decide las tecnolog√≠as a usar y la planificaci√≥n del desarrollo, el cliente no toma parte en el proceso de implementaci√≥n sino que cuando llega la fecha indicada para la finalizaci√≥n se le presenta y se eval√∫a si se ha conseguido el resultado que √©l esperaba.

Como pueden imaginar en la mayor√≠a de los casos debido al desconocimiento real del problema no se definen correctamente los requisitos o las tecnolog√≠as usadas y surg√≠an problemas imprevistos en la planificaci√≥n que retrasan la fecha de entrega o acortan el tiempo de desarrollo obligando al equipo a dedicar m√°s horas repercutiendo todo esto negativamente en el resultado final.
>>>>>>> FETCH_HEAD

En otros casos la entrega se hace a tiempo pero debido a la ausencia del cliente durante el proceso de desarrollo el producto final no responde a lo que √©l imaginaba que se iba a desarrollar causando descontento por parte de nuestro cliente y afectando a futuros contratos que podamos hacer con √©l mismo.

<<<<<<< HEAD
Para hacer frente a esta serie de problemas en torno al desarrollo software nacen las "MetodologÌ≠as ¡giles", En 2001 un grupo de desarrolladores se re˙ne en Utah para discutir los \emph{mÈtodos de peso ligero} de desarrollo software y publicaron el \emph{Manifiesto ·gil}, un documento que resume la filosofÌ≠a ·gil y establece cuatro valores y doce principios.
=======
Para hacer frente a esta serie de problemas en torno al desarrollo software nacen las "Metodolog√≠as √Ågiles", En 2001 un grupo de desarrolladores se re√∫ne en Utah para discutir los \emph{m√©todos de peso ligero} de desarrollo software y publicaron el \emph{Manifiesto √°gil}, un documento que resume la filosof√≠a √°gil y establece cuatro valores y doce principios.
>>>>>>> FETCH_HEAD

\subsection{Manifiesto √°gil}

\imgCentrada{fig.2.1}{img/manifest.eps}{Manifiesto √°gil.}

\subsubsection{VALORES:}

\begin{itemize}
<<<<<<< HEAD
\item \textbf{Valorar m·s a los individuos y su interacciÛn que a los procesos y las herramientas:} Este es posiblemente el principio m·s importante del manifiesto. Por supuesto que los procesos ayudan al trabajo. Son una guÌ≠a de operaciÛn. Las herramientas mejoran la eficiencia, pero sin personas con conocimiento tÈcnico y actitud adecuada, no producen resultados.
\item \textbf{Valorar m·s el software que funciona que la documentaciÛn exhaustiva:} La documentaciÛn siempre ser· una medida importante pero no como guÌ≠a para entender un cÛdigo sino como complemento de un cÛdigo claro y autoexplicativo. Al final lo que se debe valorar es un cÛdigo ordenado y que funciona, que le da valor a un proyecto, por encima de una documentaciÛn que aporta datos y no informaciÛn.
\item \textbf{Valorar m·s la colaboraciÛn con el cliente que la negociaciÛn contractual:} Las pr·cticas ·giles est·n especialmente indicadas para productos difÌ≠ciles de definir con detalle en el principio, o que si se definieran asÌ≠ tendrÌ≠an al final menos valor que si se van enriqueciendo con retro-informaciÛn continua durante el desarrollo. TambiÈn para los casos en los que los requisitos van a ser muy inestables por la velocidad del entorno de negocio. En el desarrollo ·gil el cliente es un miembro m·s del equipo, que se integra y colabora en el grupo de trabajo. Los modelos de contrato por obra no encajan.
\item \textbf{Valorar m·s la respuesta al cambio que el seguimiento de un plan:} Para un modelo de desarrollo que surge de entornos inestables, que tienen como factor inherente el cambio y la evoluciÛn r·pida y continua, resulta mucho m·s valiosa la capacidad de respuesta que la de seguimiento y aseguramiento de planes pre-establecidos. Los principales valores de la gestiÛn ·gil son la anticipaciÛn y la adaptaciÛn; diferentes a los de la gestiÛn de proyectos ortodoxa: planificaciÛn y control para evitar desviaciones sobre el plan.
=======
\item \textbf{Valorar m√°s a los individuos y su interacci√≥n que a los procesos y las herramientas:} Este es posiblemente el principio m√°s importante del manifiesto. Por supuesto que los procesos ayudan al trabajo. Son una gu√≠a de operaci√≥n. Las herramientas mejoran la eficiencia, pero sin personas con conocimiento t√©cnico y actitud adecuada, no producen resultados.
\item \textbf{Valorar m√°s el software que funciona que la documentaci√≥n exhaustiva:} La documentaci√≥n siempre ser√° una medida importante pero no como gu√≠a para entender un c√≥digo sino como complemento de un c√≥digo claro y autoexplicativo. Al final lo que se debe valorar es un c√≥digo ordenado y que funciona, que le da valor a un proyecto, por encima de una documentaci√≥n que aporta datos y no informaci√≥n.
\item \textbf{Valorar m√°s la colaboraci√≥n con el cliente que la negociaci√≥n contractual:} Las pr√°cticas √°giles est√°n especialmente indicadas para productos dif√≠ciles de definir con detalle en el principio, o que si se definieran as√≠ tendr√≠an al final menos valor que si se van enriqueciendo con retro-informaci√≥n continua durante el desarrollo. Tambi√©n para los casos en los que los requisitos van a ser muy inestables por la velocidad del entorno de negocio. En el desarrollo √°gil el cliente es un miembro m√°s del equipo, que se integra y colabora en el grupo de trabajo. Los modelos de contrato por obra no encajan.
\item \textbf{Valorar m√°s la respuesta al cambio que el seguimiento de un plan:} Para un modelo de desarrollo que surge de entornos inestables, que tienen como factor inherente el cambio y la evoluci√≥n r√°pida y continua, resulta mucho m√°s valiosa la capacidad de respuesta que la de seguimiento y aseguramiento de planes pre-establecidos. Los principales valores de la gesti√≥n √°gil son la anticipaci√≥n y la adaptaci√≥n; diferentes a los de la gesti√≥n de proyectos ortodoxa: planificaci√≥n y control para evitar desviaciones sobre el plan.
>>>>>>> FETCH_HEAD

\end{itemize}

\subsubsection{PRINCIPIOS:}

\begin{enumerate}

\item La prioridad es satisfacer al cliente mediante tempranas y continuas
entregas de software que le aporten valor.
\item Dar la bienvenida a los cambios de requisitos. Se capturan los cambios
para que el cliente tenga una ventaja competitiva.
\item Liberar software que funcione frecuentemente, desde un par de semanas
a un par de meses, con el menor intervalo de tiempo posible entre
entregas.
\item Los miembros del negocio y los desarrolladores deben trabajar juntos
diariamente a lo largo del proyecto.
\item Construir el proyecto en torno a individuos motivados. Darles el entorno
y apoyo que necesiten y confiar a en ellos para conseguir finalizar
el trabajo.
\item El di√°logo cara a cara es el m√©todo m√°s eficiente y efectivo para
comunicar informaci√≥n dentro de un equipo de desarrollo.
\item El software que funciona es la principal medida de progreso.
<<<<<<< HEAD
\item Los procesos ·giles promueven un desarrollo sostenible. Los promotores,
desarrolladores y usuarios deberÌ≠an ser capaces de mantener una paz
=======
\item Los procesos √°giles promueven un desarrollo sostenible. Los promotores,
desarrolladores y usuarios deber√≠an ser capaces de mantener una paz
>>>>>>> FETCH_HEAD
constante.
\item La atenci√≥n continua a la calidad t√©cnica y al buen dise√±o mejora
la agilidad.
\item La simplicidad es esencial.
\item Las mejores arquitecturas, requisitos y dise√±os surgen de los equipos
que se organizan ellos mismos.
\item En intervalos regulares, el equipo debe reflexionar sobre c√≥mo ser
m√°s efectivo y, seg√∫n estas reflexiones, ajustar su comportamiento.


\end{enumerate}



\subsection{Desarrollo iterativo incremental con Scrum}

\subsubsection{Introducci√≥n}

<<<<<<< HEAD
\lettrine{P}{ara} abordar la realizaciÛn del proyecto SIMFORPAS se har· uso del modelo organizativo de trabajo Scrum. Una de las caracterÌ≠sticas de Èste modelo es la b˙squeda de una serie de beneficios, como por ejemplo, la capacidad de aceptaciÛn de nuevos cambios durante el desarrollo ya sean requeridos por el cliente como por el mercado, esto nos asegura que el cliente al finalizar el proyecto va a tener el producto que satisface a sus necesidades ya que de otro modo los requisitos pueden haber cambiado desde la definiciÛn inicial.
=======
\lettrine{P}{ara} abordar la realizaci√≥n del proyecto SIMFORPAS se har√° uso del modelo organizativo de trabajo Scrum. Una de las caracter√≠sticas de √©ste modelo es la b√∫squeda de una serie de beneficios, como por ejemplo, la capacidad de aceptaci√≥n de nuevos cambios durante el desarrollo ya sean requeridos por el cliente como por el mercado, esto nos asegura que el cliente al finalizar el proyecto va a tener el producto que satisface a sus necesidades ya que de otro modo los requisitos pueden haber cambiado desde la definici√≥n inicial.
>>>>>>> FETCH_HEAD

El equipo de trabajo se auto asignar√° las tareas a realizar, esto provoca que cada integrante se mantenga motivado ya que √©l mismo se ha puesto su objetivo. El desarrollo iterativo exige tener una versi√≥n funcional o una serie de resultados presentables al finalizar cada etapa del desarrollo, esto se traduce en una mayor calidad del software.

<<<<<<< HEAD
Utilizando herramientas como la gr·fica de burn down es posible observar la velocidad que est· llevando el equipo de desarrollo, esto es ˙til para detectar posibles problemas de rendimiento que haya que solucionar entre todo el equipo o una reorganizaciÛn de la planificaciÛn asÌ≠ como para poder estimar el tiempo de duraciÛn del proyecto.
=======
Utilizando herramientas como la gr√°fica de burn down es posible observar la velocidad que est√° llevando el equipo de desarrollo, esto es √∫til para detectar posibles problemas de rendimiento que haya que solucionar entre todo el equipo o una reorganizaci√≥n de la planificaci√≥n as√≠ como para poder estimar el tiempo de duraci√≥n del proyecto.
>>>>>>> FETCH_HEAD

\subsubsection{Roles}

\begin{itemize}
\item \textbf{Product owner:} El Product Owner representa la voz del cliente. Se asegura de que el equipo Scrum trabaje de forma adecuada desde la perspectiva del negocio. El Product Owner escribe historias de usuario, las prioriza, y las coloca en el Product Backlog.
<<<<<<< HEAD
\item \textbf{ScrumMaster:} El Scrum es facilitado por un ScrumMaster, cuyo trabajo primario es eliminar los obst·culos que impiden que el equipo alcance el objetivo del sprint. El ScrumMaster no es el lÌ≠der del equipo (porque ellos se auto-organizan), sino que act˙a como una protecciÛn entre el equipo y cualquier influencia que le distraiga. El ScrumMaster se asegura de que el proceso Scrum se utiliza como es debido. El ScrumMaster es el que hace que las reglas se cumplan.
\item \textbf{Equipo de desarrollo:} El equipo tiene la responsabilidad de entregar el producto. Un pequeÒo equipo de 3 a 9 personas con las habilidades transversales necesarias para realizar el trabajo (an·lisis, diseÒo, desarrollo, pruebas, documentaciÛn, etc).
=======
\item \textbf{ScrumMaster:} El Scrum es facilitado por un ScrumMaster, cuyo trabajo primario es eliminar los obst√°culos que impiden que el equipo alcance el objetivo del sprint. El ScrumMaster no es el l√≠der del equipo (porque ellos se auto-organizan), sino que act√∫a como una protecci√≥n entre el equipo y cualquier influencia que le distraiga. El ScrumMaster se asegura de que el proceso Scrum se utiliza como es debido. El ScrumMaster es el que hace que las reglas se cumplan.
\item \textbf{Equipo de desarrollo:} El equipo tiene la responsabilidad de entregar el producto. Un peque√±o equipo de 3 a 9 personas con las habilidades transversales necesarias para realizar el trabajo (an√°lisis, dise√±o, desarrollo, pruebas, documentaci√≥n, etc).
>>>>>>> FETCH_HEAD
\end{itemize}

Existen otros roles auxiliares como pueden ser proveedores, clientes, vendedores... s√≥lo participar√°n directamente durante las revisiones de sprint.

\subsubsection{Desarrollo del proyecto con Scrum}

<<<<<<< HEAD
\lettrine{A}{l} principio se tiene una reuniÛn con el cliente donde se recoge el objetivo del proyecto, los requisitos y las tareas que se llevar·n a cabo para realizarlos, todo ello mediante historias de usuario en las que se asocia el rol a la necesidad del proyecto como se puede observar en el siguiente ejemplo: \emph{Como desarrollador quiero un mÛdulo central capaz de cambiar y monitorizar el estado del modelo}, de esta forma se deciden las tareas a realizar. Luego el equipo y el cliente discuten la prioridad en las tareas hasta llegar a un consenso de quÈ es m·s importante desarrollar primero y quÈ dejar para m·s adelante, de esta forma nos aseguramos de ir cumpliendo las necesidades m·s importantes para poder tener cuanto antes una versiÛn funcional del proyecto. TambiÈn se valorar·n seg˙n la dificultad de cada una de ellas, facilitando de esta forma la elecciÛn de quÈ se realizar· antes, las acciones que sean esenciales y f·ciles se har·n primero, y las difÌ≠ciles y poco necesarias se dejar·n para el final, el tiempo de realizaciÛn de cada tarea se har· en funciÛn a la dificultad de la misma.

Una vez definidas las historias de usuario se define el tamaÒo de los \emph{sprints}, normalmente un sprint es un espacio de tiempo de entre una y cuatro semanas en las que se desarrollar·n determinadas historias de usuario. Cuando se define el primer sprint se colocan en una pizarra las historias de usuario, para cada historia se definir·n unos test de aceptaciÛn que asegurar·n una vez cumplidos que la tarea est· finalizada y se colocar·n pequeÒas sub-tareas necesarias para la realizaciÛn de la historia de usuario. La pizarra tendr· varios \emph{pools} que indicar·n las sub-tareas a realizar, las que est·n en proceso y las que ya se han realizado. …stas sub-tareas se ir·n cambiando de posiciÛn seg˙n sea su estado. La morfologÌ≠a de la pizarra de Scrum se muestra en la siguiente figura.

%FOTO SCRUM CATEC SIMFORPAS

Durante el sprint se har· una reuniÛn diaria entre el equipo y el ScrumMaster en la que se hablar· del estado del proyecto, quÈ se realizÛ el dÌ≠a anterior, quÈ se realizar· en ese dÌ≠a y quÈ problemas han surgido para buscar entre todos soluciones y que ning˙n miembro del equipo se quede estancado en una tarea.

Una vez finalizado el sprint se organiza una reuniÛn de retrospectiva, a la que acudir· el equipo, el ScrumMaster y el product owner en la que se presentar· el estado del proyecto, quÈ es lo que se ha llevado a cabo durante el sprint, quÈ problemas han surgido, que se podrÌ≠a modificar/mejorar. El cliente dar· el visto bueno y har· las peticiones que vea necesarias, se har· la gr·fica de burn down para documentar el estado de esa fase del proyecto y se organizar·n las tareas para el siguiente sprint.

\imgCentrada{fig.2.2}{img/scrum.eps}{Ciclo metodologÌ≠a Scrum.}

Esta forma de trabajo se repetir· hasta la finalizaciÛn del proyecto, nos asegurar· que el cliente est· implicado en el desarrollo y que conocer· de antemano el producto que va a comprar y podr· interceder en su morfologÌ≠a. Con este mÈtodo el equipo de desarrollo trabaja de una forma m·s relajada evitando la acumulaciÛn de trabajo a ˙ltima hora y los estancamientos ya que entre el equipo debe fluir la comunicaciÛn y el problema que tenga uno en la realizaciÛn de su parte se convierte en problema de todos. El cliente podr· aÒadir cambios o complementos al proyecto a sabiendas de que esos cambios vendr·n con el sacrificio de otras historias de usuario programadas o de un incremento del tiempo de desarrollo y del coste del proyecto.
=======
\lettrine{A}{l} principio se tiene una reuni√≥n con el cliente donde se recoge el objetivo del proyecto, los requisitos y las tareas que se llevar√°n a cabo para realizarlos, todo ello mediante historias de usuario en las que se asocia el rol a la necesidad del proyecto como se puede observar en el siguiente ejemplo: \emph{Como desarrollador quiero un m√≥dulo central capaz de cambiar y monitorizar el estado del modelo}, de esta forma se deciden las tareas a realizar. Luego el equipo y el cliente discuten la prioridad en las tareas hasta llegar a un consenso de qu√© es m√°s importante desarrollar primero y qu√© dejar para m√°s adelante, de esta forma nos aseguramos de ir cumpliendo las necesidades m√°s importantes para poder tener cuanto antes una versi√≥n funcional del proyecto. Tambi√©n se valorar√°n seg√∫n la dificultad de cada una de ellas, facilitando de esta forma la elecci√≥n de qu√© se realizar√° antes, las acciones que sean esenciales y f√°ciles se har√°n primero, y las dif√≠ciles y poco necesarias se dejar√°n para el final, el tiempo de realizaci√≥n de cada tarea se har√° en funci√≥n a la dificultad de la misma.

Una vez definidas las historias de usuario se define el tama√±o de los \emph{sprints}, normalmente un sprint es un espacio de tiempo de entre una y cuatro semanas en las que se desarrollar√°n determinadas historias de usuario. Cuando se define el primer sprint se colocan en una pizarra las historias de usuario, para cada historia se definir√°n unos test de aceptaci√≥n que asegurar√°n una vez cumplidos que la tarea est√° finalizada y se colocar√°n peque√±as sub-tareas necesarias para la realizaci√≥n de la historia de usuario. La pizarra tendr√° varios \emph{pools} que indicar√°n las sub-tareas a realizar, las que est√°n en proceso y las que ya se han realizado. √âstas sub-tareas se ir√°n cambiando de posici√≥n seg√∫n sea su estado. La morfolog√≠a de la pizarra de Scrum se muestra en la siguiente figura.

%FOTO SCRUM CATEC SIMFORPAS

Durante el sprint se har√° una reuni√≥n diaria entre el equipo y el ScrumMaster en la que se hablar√° del estado del proyecto, qu√© se realiz√≥ el d√≠a anterior, qu√© se realizar√° en ese d√≠a y qu√© problemas han surgido para buscar entre todos soluciones y que ning√∫n miembro del equipo se quede estancado en una tarea.

Una vez finalizado el sprint se organiza una reuni√≥n de retrospectiva, a la que acudir√° el equipo, el ScrumMaster y el product owner en la que se presentar√° el estado del proyecto, qu√© es lo que se ha llevado a cabo durante el sprint, qu√© problemas han surgido, que se podr√≠a modificar/mejorar. El cliente dar√° el visto bueno y har√° las peticiones que vea necesarias, se har√° la gr√°fica de burn down para documentar el estado de esa fase del proyecto y se organizar√°n las tareas para el siguiente sprint.

\imgCentrada{fig.2.2}{img/scrum.eps}{Ciclo metodolog√≠a Scrum.}

Esta forma de trabajo se repetir√° hasta la finalizaci√≥n del proyecto, nos asegurar√° que el cliente est√° implicado en el desarrollo y que conocer√° de antemano el producto que va a comprar y podr√° interceder en su morfolog√≠a. Con este m√©todo el equipo de desarrollo trabaja de una forma m√°s relajada evitando la acumulaci√≥n de trabajo a √∫ltima hora y los estancamientos ya que entre el equipo debe fluir la comunicaci√≥n y el problema que tenga uno en la realizaci√≥n de su parte se convierte en problema de todos. El cliente podr√° a√±adir cambios o complementos al proyecto a sabiendas de que esos cambios vendr√°n con el sacrificio de otras historias de usuario programadas o de un incremento del tiempo de desarrollo y del coste del proyecto.
>>>>>>> FETCH_HEAD

\subsection{Test Driven Development}

\lettrine{E}{l} desarrollo guiado por pruebas o TDD por sus siglas en ingl√©s consiste en una pr√°ctica de programaci√≥n que implica a su vez otras dos pr√°cticas: Escribir las pruebas antes que el c√≥digo y refactorizar. Una vez habiendo definido la funcionalidad de la parte del c√≥digo que vamos a escribir hacemos un test que pruebe esa funcionalidad y una vez definido √©ste test y fallando nos disponemos a codificar la soluci√≥n que lo resuelva, de esta forma nos aseguramos de que no perdemos ninguna funci√≥n al programar el c√≥digo. Si se hace al rev√©s el test se ve afectado por la forma que tiene el c√≥digo y tendemos a probar lo que sabemos que va a ocurrir dej√°ndonos muchos casos sin resolver que pueden afectar m√°s tarde al correcto funcionamiento de nuestro programa. Con esta t√©cnica tambi√©n nos aseguramos que en el momento en que se realice un cambio en el programa nada deja de funcionar, puesto que en todo momento el c√≥digo debe pasar los test asegurando que no se pierde ninguna funcionalidad debida al nuevo cambio.

<<<<<<< HEAD
Una vez se ha escrito el test, se ha comprobado que fallaba y se ha resuelto viene la hora de refactorizar el cÛdigo, como no sabemos  a priori cÛmo va a ser el cÛdigo final debemos probablemente el cÛdigo que hemos escrito para pasar ese test sea memorable, por eso tenemos que estudiar la forma correcta de escribir esa parte del cÛdigo, esto se hace mediante una refactorizaciÛn. Una vez realizada Èsta refactorizaciÛn se vuelven a pasar los test, si no pasan habrÌ≠a que repasar el cÛdigo para que se solucione el error y luego volver a repasar la refactorizaciÛn.
=======
Una vez se ha escrito el test, se ha comprobado que fallaba y se ha resuelto viene la hora de refactorizar el c√≥digo, como no sabemos  a priori c√≥mo va a ser el c√≥digo final debemos probablemente el c√≥digo que hemos escrito para pasar ese test sea memorable, por eso tenemos que estudiar la forma correcta de escribir esa parte del c√≥digo, esto se hace mediante una refactorizaci√≥n. Una vez realizada √©sta refactorizaci√≥n se vuelven a pasar los test, si no pasan habr√≠a que repasar el c√≥digo para que se solucione el error y luego volver a repasar la refactorizaci√≥n.
>>>>>>> FETCH_HEAD

\imgCentradaMed{fig.2.3}{img/tdd.eps}{Ciclo TDD.}

\newpage

Mediante √©sta t√©cnica nos aseguramos un c√≥digo limpio, bien estructurado y libre de errores. Otra funcionalidad de los test es explicar de qu√© manera se usa el c√≥digo que estamos programando, ya que para probar nuestros m√©todos y clases debemos hacer uso de ellas, y este uso queda reflejado en el test.

\subsection{Pair programming}

<<<<<<< HEAD
\lettrine{A}{} la hora de programar es muy com˙n perder mucho tiempo con errores al codificar asÌ≠ como en tomar decisiones correctas sobre quÈ forma darle al cÛdigo, una tÈcnica que evita estas situaciones es la programaciÛn por parejas, consiste en unir a dos desarrolladores para que programen juntos en el mismo puesto de trabajo, de forma que mientras uno programa el otro vigila que no tenga errores. TambiÈn deciden entre los dos cÛmo hacer las cosas de una forma objetiva, siempre es bueno tener una segunda opiniÛn y discutir cu·l es la mejor soluciÛn a un problema.
=======
\lettrine{A}{} la hora de programar es muy com√∫n perder mucho tiempo con errores al codificar as√≠ como en tomar decisiones correctas sobre qu√© forma darle al c√≥digo, una t√©cnica que evita estas situaciones es la programaci√≥n por parejas, consiste en unir a dos desarrolladores para que programen juntos en el mismo puesto de trabajo, de forma que mientras uno programa el otro vigila que no tenga errores. Tambi√©n deciden entre los dos c√≥mo hacer las cosas de una forma objetiva, siempre es bueno tener una segunda opini√≥n y discutir cu√°l es la mejor soluci√≥n a un problema.
>>>>>>> FETCH_HEAD

A priori puede parecer que √©ste m√©todo hace que dos personas est√©n haciendo el trabajo de una, pero a la larga esto acelera el tiempo de desarrollo. Tambi√©n es muy √∫til a la hora de transmitir conocimientos a una nueva incorporaci√≥n al equipo o para ense√±ar a programadores junior.

<<<<<<< HEAD
Cada cierto tiempo se pueden intercambiar los papeles lo que les permitir· a las dos partes coger soltura y ver el cÛdigo con perspectiva de forma que puedan abstraerse y tener una visiÛn global. …sta tÈcnica puede combinarse con la programaciÛn guiada por tests de forma que uno de los dos escribe el test y el otro tiene que escribir el cÛdigo que lo resuelve para que el otro tenga la obligaciÛn de pensar de quÈ forma podrÌ≠a fallar y asÌ≠ tener una mayor cobertura frente a fallos.

\imgCentradaMed{fig.2.4}{img/pair.eps}{Pair programming.}

\section{PlanificaciÛn temporal}

%%PREGUNTAR A PABLO SI INTRODUCIR ESTA SECCION DESPUES DEL LANZAMIENTO DEL PROYECTO

\chapter{PlanificaciÛn inicial}

%%%OBJETIVOS

\newpage
\section{Objetivos del proyecto}

\lettrine{E}{l} objetivo de este proyecto ser· el de crear una plataforma de simulaciÛn para la formaciÛn y entrenamiento de pilotos de RPAS (Remotely Piloted Aircraft System) ligeros que se comporte exactamente como lo harÌ≠a el aviÛn real. Que el sistema permita hacer uso de una GCS homologada para el manejo de UAV's usando un protocolo de comunicaciones para aviones no tripulados de menos de 25 Kg y usando un modelo de aviÛn real.

TambiÈn se requerir· de una herramienta que permita a un instructor ser capaz de controlar la simulaciÛn permitiÈndole manejar su curso e introducir errores en el sistema. La simulaciÛn se deber· hacer en tiempo real.

Para garantizar la correcta consecuciÛn de los objetivos generales del proyecto se utilizar· la herramienta de organizaciÛn SCRUM junto a otras metodologÌ≠as de desarrollo ·gil.

\subsection{Objetivos orientados a la metodologÌ≠a}

Los objetivos que se tienen en mente al realizar esta aplicaciÛn con respecto a
las metodologÌ≠as usadas son los siguientes:

\begin{itemize}
  \item Aplicar el marco de trabajo Scrum, usando para ello los conocimientos
  adquiridos al trabajar en empresas que utilizan dicha metodologÌ≠a y cursos.
  TambiÈn se dispone del apoyo bibliogr·fico de libros como \emph{Agile Samurai} y \emph{Agile Software Development with Scrum}

  \item Aplicar metodologÌ≠as de programaciÛn en pareja para agilizar el desarrollo y evitar errores en el cÛdigo.

  \item Aplicar los principios S.O.L.I.D. como base de un cÛdigo robusto, limpio y sujeto a cambios.

  \item Aplicar metodologÌ≠as de eXtreme Programming para asegurar que el cÛdigo acepte cambios de manera sencilla e intuitiva.

  \item Comprobar los beneficios colaterales a la realizaciÛn de estas
  pr·cticas como, por ejemplo, la facilidad de a\'nadir nuevas tareas durante el
  proceso de desarrollo.
 
=======
Cada cierto tiempo se pueden intercambiar los papeles lo que les permitir√° a las dos partes coger soltura y ver el c√≥digo con perspectiva de forma que puedan abstraerse y tener una visi√≥n global. √âsta t√©cnica puede combinarse con la programaci√≥n guiada por tests de forma que uno de los dos escribe el test y el otro tiene que escribir el c√≥digo que lo resuelve para que el otro tenga la obligaci√≥n de pensar de qu√© forma podr√≠a fallar y as√≠ tener una mayor cobertura frente a fallos.

\imgCentradaMed{fig.2.4}{img/pair.eps}{Pair programming.}

\section{Tecnolog√≠as}

\lettrine{A}{ntes} de iniciar el desarrollo del proyecto debemos decidir qu√© tecnolog√≠as son las m√°s adecuadas a la hora de realizar ciertas tareas, como por ejemplo, unos de los requisitos para el simulador de UAV's es que las comunicaciones deben ocurrir en tiempo real, as√≠ como el procesado de datos, por tanto necesitamos un lenguaje que nos ofrezca esta velocidad como podr√≠a ser c++.

A continuaci√≥n enumeraremos y daremos una breve explicaci√≥n de cada una de las tecnolog√≠as usadas durante el desarrollo del proyecto SIMFORPAS.

\subsection{Programaci√≥n orientada a objetos}

\lettrine{L}{a} programaci√≥n orientada a objetos es un paradigma de programaci√≥n en el que las funciones las realizan los \emph{objetos}. Est√° basado en varias t√©cnicas como la \emph{herencia}, la \emph{cohesi√≥n}, \emph{abstracci√≥n}, \emph{polimorfismo}, \emph{acoplamiento} y \emph{encapsulamiento}. La principal caracter√≠stica de √©ste paradigma es que relaciona el sistema con el mundo real, en el que cada entidad que cumple una funci√≥n est√° representada por un objeto en el c√≥digo, as√≠ podemos encontrar objetos controladores, f√°bricas, etc...

La herencia y el polimorfismo son t√©cnicas que nos permiten crear un c√≥digo mucho m√°s legible, limpio, y f√°cil de mantener debido al encapsulamiento de responsabilidades que hace que cuando necesitemos encontrar una funci√≥n de nuestro c√≥digo sepamos en qu√© lugar buscar y no tengamos que depurar todas las l√≠neas como ocurre en paradigmas como la programaci√≥n estructural. 

Entre las muchas ventajas de la programaci√≥n orientada a objetos podemos encontrar la robustez del c√≥digo debido a que una clase que no funcione correctamente no debe afectar al resto del c√≥digo, es capaz de abstraer entidades del mundo real haciendo mucho m√°s f√°cil manejarlas en nuestro programa, facilita el desarrollo del software y el trabajo en equipo ya que dos personas ser√°n capaces de trabajar sobre distintas partes del c√≥digo sin interferir una en el trabajo de la otra.

\subsubsection{Caracter√≠sticas de la POO}

\begin{itemize}
\item\textbf{Abstracci√≥n:} Denota las caracter√≠sticas esenciales de un objeto, donde se capturan sus comportamientos. Cada objeto en el sistema sirve como modelo de un "agente" abstracto que puede realizar trabajo, informar y cambiar su estado, y "comunicarse" con otros objetos en el sistema sin revelar c√≥mo se implementan estas caracter√≠sticas. Los procesos, las funciones o los m√©todos pueden tambi√©n ser abstra√≠dos, y, cuando lo est√°n, una variedad de t√©cnicas son requeridas para ampliar una abstracci√≥n. El proceso de abstracci√≥n permite seleccionar las caracter√≠sticas relevantes dentro de un conjunto e identificar comportamientos comunes para definir nuevos tipos de entidades en el mundo real. La abstracci√≥n es clave en el proceso de an√°lisis y dise√±o orientado a objetos, ya que mediante ella podemos llegar a armar un conjunto de clases que permitan modelar la realidad o el problema que se quiere atacar.
\item\textbf{Encapsulamiento:} Significa reunir todos los elementos que pueden considerarse pertenecientes a una misma entidad, al mismo nivel de abstracci√≥n. Esto permite aumentar la cohesi√≥n de los componentes del sistema. Algunos autores confunden este concepto con el principio de ocultaci√≥n, principalmente porque se suelen emplear conjuntamente.

\item\textbf{Modularidad:} Se denomina modularidad a la propiedad que permite subdividir una aplicaci√≥n en partes m√°s peque√±as (llamadas m√≥dulos), cada una de las cuales debe ser tan independiente como sea posible de la aplicaci√≥n en s√≠ y de las restantes partes. Estos m√≥dulos se pueden compilar por separado, pero tienen conexiones con otros m√≥dulos. Al igual que la encapsulaci√≥n, los lenguajes soportan la modularidad de diversas formas.
\item\textbf{Principio de ocultaci√≥n:} Cada objeto est√° aislado del exterior, es un m√≥dulo natural, y cada tipo de objeto expone una interfaz a otros objetos que especifica c√≥mo pueden interactuar con los objetos de la clase. El aislamiento protege a las propiedades de un objeto contra su modificaci√≥n por quien no tenga derecho a acceder a ellas; solamente los propios m√©todos internos del objeto pueden acceder a su estado. Esto asegura que otros objetos no puedan cambiar el estado interno de un objeto de manera inesperada, eliminando efectos secundarios e interacciones inesperadas. Algunos lenguajes relajan esto, permitiendo un acceso directo a los datos internos del objeto de una manera controlada y limitando el grado de abstracci√≥n. La aplicaci√≥n entera se reduce a un agregado o rompecabezas de objetos.
\item\textbf{Polimorfismo:} Comportamientos diferentes, asociados a objetos distintos, pueden compartir el mismo nombre; al llamarlos por ese nombre se utilizar√° el comportamiento correspondiente al objeto que se est√© usando. O, dicho de otro modo, las referencias y las colecciones de objetos pueden contener objetos de diferentes tipos, y la invocaci√≥n de un comportamiento en una referencia producir√° el comportamiento correcto para el tipo real del objeto referenciado. Cuando esto ocurre en "tiempo de ejecuci√≥n", esta √∫ltima caracter√≠stica se llama asignaci√≥n tard√≠a o asignaci√≥n din√°mica. Algunos lenguajes proporcionan medios m√°s est√°ticos (en "tiempo de compilaci√≥n") de polimorfismo, tales como las plantillas y la sobrecarga de operadores de C++.
\item\textbf{Herencia:} Las clases no se encuentran aisladas, sino que se relacionan entre s√≠, formando una jerarqu√≠a de clasificaci√≥n. Los objetos heredan las propiedades y el comportamiento de todas las clases a las que pertenecen. La herencia organiza y facilita el polimorfismo y el encapsulamiento, permitiendo a los objetos ser definidos y creados como tipos especializados de objetos preexistentes. Estos pueden compartir (y extender) su comportamiento sin tener que volver a implementarlo. Esto suele hacerse habitualmente agrupando los objetos en clases y estas en √°rboles o enrejados que reflejan un comportamiento com√∫n. Cuando un objeto hereda de m√°s de una clase se dice que hay herencia m√∫ltiple; siendo de alta complejidad t√©cnica por lo cual suele recurrirse a la herencia virtual para evitar la duplicaci√≥n de datos.
\item\textbf{Recolecci√≥n de basura:} La recolecci√≥n de basura o garbage collection es la t√©cnica por la cual el entorno de objetos se encarga de destruir autom√°ticamente, y por tanto desvincular la memoria asociada, los objetos que hayan quedado sin ninguna referencia a ellos. Esto significa que el programador no debe preocuparse por la asignaci√≥n o liberaci√≥n de memoria, ya que el entorno la asignar√° al crear un nuevo objeto y la liberar√° cuando nadie lo est√© usando. En la mayor√≠a de los lenguajes h√≠bridos que se extendieron para soportar el Paradigma de Programaci√≥n Orientada a Objetos como C++ u Object Pascal, esta caracter√≠stica no existe y la memoria debe desasignarse expresamente.
>>>>>>> FETCH_HEAD
\end{itemize}

\subsection{Objetivos orientados a la tÈcnica}

Los objetivos que se han querido validar al realizar esta aplicaciÛn son los
siguientes:

<<<<<<< HEAD
\begin{itemize}
  \item Aprender y utilizar tecnologÌ≠as que garanticen una comunicaciÛn y procesado de datos en tiempo real como pueden ser C++ y DDS.
  
  \item Aprender y utilizar para el puesto de instructor herramientas que ayuden al desarrollo de una plataforma web para el control del simulador como Maven, Struts2, Spring4 e Hibernate4.
  
  \item Aprender y utilizar entornos de testeo de cÛdigo como Google test, Google mock, Junit y Jmock para asegurar que el cÛdigo funciona en todas las fases de desarrollo y modificaciÛn del software.
=======
La manera que usaremos para sacar el mayor partido a la programaci√≥n orientada a objetos ser√° haciendo uso de los principios \emph{S.O.L.I.D.} como gu√≠a de buenas formas a la hora de programar.
>>>>>>> FETCH_HEAD

  \item Aplicar correctamente cada una de las metodologÌ≠as estudiadas y sacar conclusiones de su uso.
  
\end{itemize}

<<<<<<< HEAD
\subsection{Objetivos personales}

Se ha querido asegurar que se cumplen los siguientes objetivos a lo largo del
desarrollo de la aplicaciÛn:

\begin{itemize}
  \item AdaptaciÛn: Adecuarse a las exigencias de estas nuevas metodologÌ≠as. Los
  desarrolladores tienen la motivaciÛn de aprender nuevas tÈcnicas que mejoren
  la calidad del software.
  
  \item Confianza: Conseguir conocimientos que me permitan en un futuro abatir exitosamente un proyecto software.
  
  \item Experiencia: Adquirir aptitudes para solucionar problemas y aÒadir valor a un grupo de trabajo en un entorno laboral.
  
  \item Conocimientos TÈcnicos: Trabajar y sintetizar nuevas tecnologÌ≠as que me sirvan en el futuro para completarme como profesional en mi campo.

=======
\lettrine{R}{representan} cinco principios b√°sicos del uso de la POO y del dise√±o software. √âstos conceptos fueron recogidos por Robert C. Martin en torno al a√±o 2000, los principios S.O.L.I.D. son una gu√≠a que ayuda al programador a elaborar un c√≥digo m√°s limpio, legible y f√°cil de mantener y extender. Su uso se adapta a dos conceptos que hemos visto anteriormente como son el de TDD y Refactorizaci√≥n, ya que estos dos tienen como finalidad buscar un c√≥digo que cumpla siempre con estas directrices.

El acr√≥nimo S.O.L.I.D. responde a las siguientes definiciones:

\begin{itemize}
\item\textbf{S}ingle responsibility principle: El principio de √∫nica responsabilidad dice que una clase s√≥lo deber√≠a tener una √∫nica responsabilidad, de esa forma solo tendr√≠a una √∫nica raz√≥n para cambiar y as√≠ se contiene la propagaci√≥n de cualquier cambio que realicemos sobre ella sin que afecte a otra parte del c√≥digo que no tiene nada que ver con dicha responsabilidad.
\item\textbf{O}pen/close principle: Nos explica la importancia de que el c√≥digo est√© abierto a su extensi√≥n pero cerrado a su modificaci√≥n, esto nos permite modificar la funcionalidad de una clase sin necesidad de tocar su c√≥digo, lo que requerir√≠a revisiones, pruebas y comprobaciones de que todo sigue funcionando correctamente.
\item\textbf{L}iskov substitution principle: Es una definici√≥n particular de una relaci√≥n de subtipificaci√≥n, llamada tipificaci√≥n del comportamiento, esto quiere decir que en un c√≥digo puede usarse cualquier clase hija del mismo padre sin que esto altere las propiedades de ese programa.
\item\textbf{I}nterface segregation principle: Es una reflexi√≥n que apunta que es mejor tener muchas interfaces espec√≠ficas a una gen√©rica, de esta forma evitamos que el cliente haga uso de propiedades de la interfaz que no necesita o a las cuales no deber√≠a tener acceso, tambi√©n es una buena herramienta de documentaci√≥n de la funcionalidad del programa y as√≠ se define mejor la funcionalidad de pasa clase.
\item\textbf{D}dependency inversi√≥n principle: √âste principio apunta que las dependencias entre partes del c√≥digo deben hacerse sobre abstracciones no sobre implementaciones, de esta forma una clase que haga uso de otra no depender√° del c√≥digo que se haya escrito para la segunda y si en alg√∫n momento √©ste cambiara no afectar√≠a a la primera. Esto ayuda a mejorar el mantenimiento del c√≥digo y lo prepara para futuras modificaciones.
>>>>>>> FETCH_HEAD
\end{itemize}
Se tendr·n en cuenta estos objetivos durante la realizaciÛn del proyecto y se comprobar· si han sido realizados. Esto se ver· con detenimiento en los apartados de conclusiones, vÈase la parte V del presente documento.

\section{Lanzamiento del proyecto}

<<<<<<< HEAD
\lettrine{A}{} principios del mes de Octubre de 2013 se re˙ne el equipo de desarrollo del proyecto SIMFORPAS formado por Irene Alejo, Jaime Rey, Manuel Mateos y Yamnia RodrÌ≠guez junto con Pablo Morillas desarrollado de la GCS en car·cter de experto sobre comunicaciones entre GCS y UAV y manejo de la GCS. …sta reuniÛn constituye la primera etapa del desarrollo incremental guiado por Scrum, en ella se definir·n los roles existentes y se pondr·n en com˙n las historias de usuario necesarias para la consecuciÛn de los objetivos del proyecto.

\subsection{DefiniciÛn de roles}

\lettrine{S}{e} ponen en com˙n los posibles roles que participar·n en el desarrollo entre los que salen el cliente, que comprar· la aplicaciÛn, los usuarios que ser·n el instructor y el alumno, el equipo de desarrollo y el instalador del sistema. Estos actores tendr·n sus requerimientos sobre el sistema y sus exigencias sobre la funcionalidad que tiene que darse en Èl para su beneficio. Por tanto haremos una descripciÛn de la funciÛn de cada uno y despuÈs los usaremos para definir las historias de usuarios.

Al ser un proyecto de investigaciÛn sobre Èsta tecnologÌ≠a no disponemos de un cliente, si en un futuro se pretende vender Èste producto nos pondremos nosotros mismos en el papel del cliente imaginando cÛmo debe ser el producto final.

\begin{itemize}
\item\textbf{Instructor:} Ser· el encargado de manejar el puesto de instructor mediante el cual podr· recibir datos del puesto de un alumno y en base a la informaciÛn intercambiada decidir si Èste es apto o no para recibir un tÌ≠tulo de operador de GCS.
=======
\lettrine{P}{ara} la consecuci√≥n de nuestro objetivo de rapidez a la hora del procesado de datos necesitamos un lenguaje que nos ofrezca esta caracter√≠stica, debido a la estructura del lenguaje de programaci√≥n orientado a objetos \emph{Java}, √©ste resulta lento y pesado a la hora de ejecutarse lo que supondr√≠a retrasos en el intercambio de datos, cosa que no nos podemos permitir cuando una aeronave depende de la comunicaci√≥n que mantengamos con ella. C, al ser un lenguaje a m√°s bajo nivel nos ofrece √©sta caracter√≠stica, pero al ser un lenguaje estructural nos priva de la ventaja de los lenguajes orientados a objetos. Una buena combinaci√≥n de estas dos caracter√≠sticas es el lenguaje C++, √©ste lenguaje es una extensi√≥n de C que nos permite la manipulaci√≥n de objetos, desde el punto de vista de la programaci√≥n orientada a objetos, √©ste es un lenguaje h√≠brido.

\imgCentradaMed{fig.2.6}{img/cpp11.eps}{Ilustraci√≥n c++11.}

Debido a su base C de bajo nivel, teniendo que gestionar la memoria del programa, nos permite tener la velocidad requerida, por eso es la mejor opci√≥n para el sistema que queremos desarrollar. En 2011 se actualiz√≥ la biblioteca est√°ndar de C++ con la nueva versi√≥n C++11, que ofrece nuevas funcionalidad para facilitar la labor del programador.

Una de las bibliotecas principales que usamos en C++ es Qt, una biblioteca multiplataforma que nos permite, entre otras funcionalidades, crear aplicaciones con interfaz gr√°fica, el API de la biblioteca tambi√©n cuenta con m√©todos para acceder a bases de datos, uso de XML, gesti√≥n de hilos y otras muchas funciones √∫tiles a la hora de programar.

√âste lenguaje lo usaremos a la hora de realizar las funciones de simulaci√≥n y comunicaci√≥n entre los diferentes m√≥dulos del sistema, en el siguiente cap√≠tulo haremos hincapi√© en qu√© funci√≥n requerir√° el uso de √©ste lenguaje.
>>>>>>> FETCH_HEAD

El instructor necesitar· herramientas que le permitan evaluar los conocimientos del alumno. Deber· visualizar cuando sea preciso el puesto del alumno para monitorizar sus acciones, ser capaz de introducir errores en el modelo para comprobar la reacciÛn del alumno y guardar un log con la evoluciÛn de la misiÛn.

<<<<<<< HEAD
\item\textbf{Alumno:} Este actor ser· evaluado por un instructor haciendo uso del sistema. Requerir· disponer de una GCS que simule un entorno real de pilotaje de UAV, un instructor que le cargue una misiÛn y supervise durante el desarrollo de la misma. El sistema deber· tener unas condiciones lo m·s parecidas a un caso real para comprobar que los conocimientos adquiridos por el alumno son correctos y pueden usarse en un entorno real.

\item\textbf{Desarrollador:} Es el encargado del diseÒo, escritura y posterior montaje del sistema. Necesitar· para ello informaciÛn verÌ≠dica sobre los requisitos que se necesitan, un entorno de desarrollo adecuado y las herramientas necesarias.
=======
\lettrine{E}{l} proyecto podr√≠a dividirse en tres partes bien identificadas, por un lado tenemos el simulador de la aeronave, la GCS y el puesto de instructor, los dos primeros como ya hemos explicado requieren una respuesta r√°pida ya que el vuelo simulado depende de la rapidez en las comunicaciones y para asegurar que el entorno es similar a un vuelo en la vida real necesitamos tratar al simulador como si fuera una aeronave real.

Sin embargo el puesto de instructor no requiere una interacci√≥n con el sistema que sea en tiempo real, sino que importa m√°s que la aplicaci√≥n, al estar separada del resto de m√≥dulos, sea multi-plataforma para abstraernos del entorno desde el que se use y sea f√°cilmente portable, as√≠ como que disponga de un m√©todo de comunicaci√≥n compatible con el resto del sistema. Java es un lenguaje totalmente orientado a objetos, se ejecuta sobre una m√°quina virtual (JVM) adaptada a la mayor√≠a de sistemas operativos, lo que convierte cualquier aplicaci√≥n java en multi-plataforma. 
>>>>>>> FETCH_HEAD

\item\textbf{Instalador del sistema:} Es el actor encargado de preparar los equipos para que trabajen con el software desarrollado durante el proyecto. Necesitar· un equipo adecuado para instalar el puesto del alumno y otro para el del instructor, que el software disponga de un instalador con todas las herramientas necesarias para el correcto funcionamiento del sistema.

<<<<<<< HEAD
\item\textbf{Cliente:} Ser· el interesado en adquirir el software para instruir a futuros operadores de GCS. Necesitar· un entorno de aprendizaje que simule fielmente las condiciones de pilotaje de UAV y permita a un instructor ser capaz de evaluar al alumno.

\end{itemize}

\subsection{Historias de usuario}
=======
Al ser un lenguaje orientado a objetos nos da todas las facilidades que ya explicamos antes y debido a la gran comunidad y a lo extendido que est√° √©ste lenguaje de programaci√≥n tenemos un n√∫mero infinito de herramientas y tecnolog√≠as que se pueden implementar con Java, incluido el m√©todo de comunicaci√≥n entre m√≥dulos que usaremos para el intercambio de informaci√≥n que usaremos en el proyecto, por tanto es el lenguaje perfecto para lo que necesitamos. Tambi√©n permite la implementaci√≥n de p√°ginas web de manera r√°pida y sencilla lo que nos permitir√° darle a√∫n m√°s accesibilidad a la aplicaci√≥n ya que podr√≠a instalarse en un servidor y accederse desde cualquier terminal conectado a √©l.

\subsection{Patrones de dise√±o}

\lettrine{A}{} la hora de programar solemos encontrarnos una gran cantidad de veces con problemas recurrentes de dise√±o de cuya soluci√≥n puede depender que nuestro c√≥digo se alivie o que salga herido. Una mala soluci√≥n a un problema normalmente acarrear√° m√°s cambios en el resto del c√≥digo, en cuanto al dise√±o del software hay una serie de problemas que son bastante conocidos ya que suelen aparecer frecuentemente, por ejemplo, tenemos que implementar una aplicaci√≥n que trabaja con una base de datos y una interfaz de usuario gestionada por una clase que se comunica directamente con la base de datos y la interfaz representando estos datos. Si en alg√∫n momento se quisiera modificar cualquiera de las partes, base de datos, interfaz o a√±adir una nuevo funcionalidad o modificar una ya existente este cambio afectar√≠a al conjunto de las partes y pr√°cticamente tendr√≠amos que reescribir parte del c√≥digo sino el c√≥digo entero. Para resolver este problema tenemos uno de los patrones de dise√±o m√°s comunes, el patr√≥n MVC(Modelo Vista Controlador) el cual separa la parte de persistencia de datos o modelo de datos de la interfaz del usuario, el controlador hace de puente entre los dos anteriores y guarda la l√≥gica de negocio asociada a esos datos. La vista es la interfaz con el usuario, el modelo guarda los datos con los que se trabaja y el controlador modifica esos datos.
>>>>>>> FETCH_HEAD

\lettrine{A}{} partir de los actores del proyecto se definir·n las historias de usuario. Una historia de usuario es una representaciÛn de un requisito de software escrito en una o dos frases utilizando el lenguaje com˙n del usuario. …stas historias de usuario son utilizadas en la metodologÌ≠a Scrum para la especificaciÛn de requisitos. Cada historia de usuario debe ser limitada, esta deberÌ≠a poderse escribir sobre una nota adhesiva pequeÒa. Son una forma r·pida de administrar los requisitos de los usuarios sin tener que elaborar gran cantidad de documentos formales y sin requerir de mucho tiempo para administrarlos. Las historias de usuario permiten responder r·pidamente a los requisitos cambiantes. Vamos a enumerar caracterÌ≠sticas que deben cumplir las historias de usuario.

<<<<<<< HEAD
Deben ser:
=======
\newpage
En 1990 el grupo \emph{Gang of Four} publica el libro \emph{Design Patterns}, en el que recogen los 23 patrones de dise√±o m√°s comunes, en √©ste libro se recogen una serie de soluciones a problemas habituales en el dise√±o software. Los problemas que resuelven estos patrones de dise√±o han sido ampliamente estudiados por lo que podemos asegurarnos de que su uso va a ofrecernos una soluci√≥n limpia y en la mayor√≠a de los casos √≥ptima sin necesidad de tener que reintentar la rueda. El uso compulsivo de patrones de dise√±o, sin embargo, es desaconsejable, los patrones son una gran ayuda en los casos en los que necesitamos de ellos, pero retorcer el c√≥digo con la finalidad de introducir un patr√≥n de dise√±o para resolver un problema que no necesitaba de ese patr√≥n tambi√©n podr√≠a ser negativo para nuestro programa.
>>>>>>> FETCH_HEAD

\begin{itemize}
\item\textbf{Independientes unas de otras:} De ser necesario, combinar las historias dependientes o buscar otra forma de dividir las historias de manera que resulten independientes.

<<<<<<< HEAD
\item\textbf{Negociables:} La historia en si misma no es lo suficientemente explÌ≠cita como para considerarse un contrato, la discusiÛn con los usuarios debe permitir esclarecer su alcance y Èste debe dejarse explÌ≠cito bajo la forma de pruebas de validaciÛn.

\item\textbf{Valoradas por los clientes o usuarios:} Los intereses de los clientes y de los usuarios no siempre coinciden, pero en todo caso, cada historia debe ser importante para alguno de ellos m·s que para el desarrollador.
=======
\lettrine{C}{uando} nos enfrentamos al desarrollo de un sistema complejo que requiera el uso de muchas tecnolog√≠as disponemos de herramientas para facilitarnos el trabajo, por ejemplo, una parte importante en el desarrollo de videojuegos es el aspecto gr√°fico, si deseamos animar una imagen podr√≠amos crearnos un programa que recoja las im√°genes que queramos mostrar y crearnos un sistema que secuencie la muestra de estos dibujos creando as√≠ la animaci√≥n, tambi√©n podr√≠amos implementar un sistema que gestione la f√≠sica de nuestro juego, esto requerir√≠a que dise√±√°ramos desde cero un motor de juego que nos permita m√°s adelante desarrollar nuestra aplicaci√≥n. Otra opci√≥n es hacer uso de bibliotecas que nos den √©stas herramientas ya desarrolladas que nos permitir√°, por ejemplo, mediante el archivo que guarda las im√°genes y una velocidad de animaci√≥n que la biblioteca usar√° para autom√°ticamente gestionar la animaci√≥n de una forma transparente al programador. Otro ejemplo m√°s sencillo es el de operaciones matem√°ticas incluidas en la mayor√≠a de bibliotecas est√°ndares de casi todos los lenguajes de programaci√≥n que nos quitan el peso de tener que implementar ciertas acciones que son muy comunes, si ya est√° hecho y probada su calidad y buen funcionamiento no es necesario hacerlo otra vez.

Existen bibliotecas espec√≠ficas para un gran n√∫mero de utilidades, como por ejemplo la biblioteca \emph{Spring} de Java que nos permite gestionar f√°cilmente la \emph{inversi√≥n de control} en nuestro programa, de √©sta biblioteca hablaremos m√°s adelante. Tambi√©n existen bibliotecas que nos permiten acceder a ciertos recursos gr√°ficos, trabajar con mapas, gestionar servicios web, hacer uso de determinadas aplicaciones, dar servicios de comunicaci√≥n, etc√©tera...
>>>>>>> FETCH_HEAD

\item\textbf{Estimables:} Un resultado de la discusiÛn de una historia de usuario es la estimaciÛn del tiempo que tomar· completarla. Esto permite estimar el tiempo total del proyecto.

<<<<<<< HEAD
\item\textbf{PequeÒas:} Las historias muy largas son difÌ≠ciles de estimar e imponen restricciones sobre la planificaciÛn de un desarrollo iterativo. Generalmente se recomienda la consolidaciÛn de historias muy cortas en una sola historia.
=======
\lettrine{E}{n} la b√∫squeda de un entorno de desarrollo que respondiese a nuestras necesidades deb√≠amos buscar un sistema operativo que fuera estable y que nos diera libertad de configuraci√≥n. El sistema que vamos a desarrollar requiere de un gran n√∫mero de componentes ya sean bibliotecas o m√≥dulos adicionales, los cuales pueden inducir al sistema operativo a m√∫ltiples errores durante el desarrollo, si no disponemos de un sistema estable esto afectar√≠a a la velocidad del desarrollo y al estado de √°nimo del programador. Tambi√©n nos permite manipular la totalidad del sistema de forma que podemos adaptarlo al desarrollo de la forma que mejor nos convenga, sin contar la gran comunidad que tiene detr√°s al ser un sistema operativo de c√≥digo libre lo cu√°l es un motivo para muchos programadores para implementar sus herramientas con compatibilidad para este sistema operativo lo que se convierte en una gran bater√≠a de herramientas a nuestro alcance a la hora de desarrollar un proyecto.
>>>>>>> FETCH_HEAD

\item\textbf{Verificables:} Las historias de usuario cubren requerimientos funcionales, por lo que generalmente son verificables. Cuando sea posible, la verificaciÛn debe automatizarse, de manera que pueda ser verificada en cada entrega del proyecto.

\end{itemize}

<<<<<<< HEAD
DespuÈs de definir todas las historias de usuario hay que valorar la dificultad de cada una de las historias de usuario para hacer una estimaciÛn del tiempo necesario para llevarlas a cabo.  El siguiente paso consiste en darles a cada una una prioridad basada en la necesidad que tenemos de que se realicen primero o de la importancia que tengan en el sistema. Ahora enumeraremos las historias de usuario propuestas durante la reuniÛn de lanzamiento del proyecto y la importancia que se le dio a cada uno, a mayor n˙mero junto a la historia de usuario mayor importancia tendr·, tambiÈn aÒadiremos el grado de dificultad de cada historia, para dar una imagen global de como usar los puntos, un grupo de trabajo de cuatro personas tiene una velocidad aproximada de 20 puntos por semana.

\begin{itemize}
=======
\lettrine{P}{ara} el c√≥digo del simulador que como ya explicamos anteriormente hace uso de C++ ya que nos proporciona la velocidad y robustez que necesitamos en t√©cnicas de simulaci√≥n en tiempo real hemos elegido Qt Creator como entorno de desarrollo integrado. Comenzamos usando \emph{Eclipse for C/C++} pero a la hora de realizar la integraci√≥n con \emph{CMake}, del cual hablaremos m√°s adelante, surg√≠an muchos problemas y la velocidad de compilaci√≥n era muy reducida, despu√©s de ser aconsejados por una compa√±era de trabajo decidimos cambiar a Qt Creator, el cual ofrece un entorno de desarrollo para C++ orientado a facilitar el uso de la biblioteca Qt de C++ y con muy buena integraci√≥n con CMake. Al no depender de la m√°quina virtual de java la velocidad tambi√©n aument√≥, la interfaz es mucho m√°s reducida que la de Eclipse y m√°s sencilla e intuitiva aportando todas las opciones de configuraci√≥n que necesit√°bamos.

Tambi√©n nos provee de una herramienta de dise√±o de interfaces de usuario con Qt sencilla y un debugger visual. Por todos esos motivos decidimos seguir el desarrollo con √©ste IDE en el caso de la programaci√≥n en C++ ya que aument√≥ el rendimiento y redujo los fallos derivados del manejo del entorno de desarrollo. 
>>>>>>> FETCH_HEAD

\item Como cliente quiero que el desarrollo del simulador se lleve usando las herramientas y metodologÌ≠as necesarias para augurar el Èxito en el desarrollo del proyecto.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9990

\item Como desarrollador quiero tener bien definida la arquitectura b·sica a alto nivel y las herramientas principales que se van a utilizar para no perder la vista del objetivo principal del proyecto.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9980
\item Como instructor quiero que las comunicaciones entre los sistemas se realice en tiempo real como uno de los puntos para garantizar el entrenamiento veraz.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }9890
\item Como desarrollador quiero poder insertar un modelo simple de UAV en el simulador para ayudar a definir el mÈtodo de carga de modelos fÌ≠sicos.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }9880
\item Como desarrollador quiero un mÛdulo central capaz de cambiar y monitorizar el estado del modelo.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9790
\item Como desarrollador quiero un mÛdulo que emule las GCS en el envÌ≠o y recepciÛn de datos para no depender de las GCS a la hora de desarrollar el resto de mÛdulos y tener asÌ≠ el bucle completo cerrado GCS-SIMCore-SIMModel.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }9780
\item Como cliente quiero que el modelo contemple la carga de los datos de misiÛn utilizados en el protocolo Mavlink.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9785
\item Como desarrollador quiero que el mÛdulo central estÈ sincronizado con el modelo para asegurar que los datos son coherentes.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9775
\item Como instructor quiero que las GCS visualicen la telemetrÌ≠a del UAV simulado para tener control de la misiÛn.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9770
\item Como instructor quiero que el modelo del UAV sea lo m·s real posible para garantizar los conocimiento del alumno.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9760
\item Como cliente quiero que el desarrollo del puesto de instructor se lleve usando las herramientas y metodologÌ≠as necesarias para augurar el Èxito en el desarrollo del proyecto.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9755
\item Como instructor quiero usar el autopiloto real para realizar el entrenamiento y examen.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9754
\item Como instructor quiero que las GCS establezcan un plan de vuelo para la misiÛn simulada.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9750
\item Como instructor quiero poder iniciar la simulaciÛn para tener control de la misiÛn.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9680
\item Como instructor quiero poder parar la simulaciÛn para tener control de la misiÛn.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9670
\item Como instructor quiero poder pausar la simulaciÛn para tener control de la misiÛn.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9660
\item Como instructor quiero introducir fallos de pÈrdida total de comunicaciÛn para poner a prueba al alumno.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9650
\item Como instructor quiero visualizar las GCS para tener controlado al alumno.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9590
\item Como instructor quiero crear misiones para tener una baterÌ≠a de ex·menes.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9580
\item Como instructor quiero grabar misiones que he generado en las GCS para poner a prueba al alumno en diferentes contextos.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9570
\item Como instructor quiero cargar misiones que he generado en las GCS para poner a prueba al alumno en diferentes contextos.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9560
\item Como instalador quiero que el sistema completo sea sencillo de administrar en instalar.
\\
\textbf{Dificultad: }1
\\
\textbf{Prioridad: }9490
\item Como Instructor, quiero tener acceso a informaciÛn que me indique, paso a paso, el funcionamiento del puesto de instructor.
\\
\textbf{Dificultad: }1
\\
\textbf{Prioridad: }9480
\item Como instructor quiero que el modelo del UAV sea lo m·s real posible para garantizar los conocimiento del alumno.
\\
\textbf{Dificultad: }20
\\
\textbf{Prioridad: }8990
\item Como instructor quiero cambiar las condiciones del entorno (lluvia, viento?) para poner a prueba al alumno.
\\
\textbf{Dificultad: }20
\\
\textbf{Prioridad: }8980
\item Como instructor quiero elegir un UAV para la misiÛn con el objetivo de evaluar al alumno en un UAV concreto.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }8970
\item Como Instructor quiero almacenar/ consultar resultados de las pruebas para posterior evaluaciÛn o consulta a histÛrico del alumno.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }8960
\item Como instructor quiero tomar y guardar anotaciones sobre el examen de un alumno para posterior evaluaciÛn.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }8950

<<<<<<< HEAD
\end{itemize}
=======
\lettrine{E}{l} puesto de instructor est√° escrito en c√≥digo Java ya que necesit√°bamos que fuera multiplataforma, para √©ste lenguaje de programaci√≥n, el IDE m√°s extendido es el de la propine empresa que lo dise√±√≥, Sun Microsystems, cuyo nombre es Eclipse. Es un programa compuesto por un conjunto de herramientas de c√≥digo abierto y multiplataforma orientado al desarrollo de entornos de desarrollo integrados, en nuestro caso, lo usaremos como entorno para programadores Java ya que tiene una gran integraci√≥n con herramientas necesarias en nuestro proyecto como pueden ser \emph{Maven}, \emph{Junit}, Control de versiones, etc√©tera... Decidimos hacer uso de √©l debido al gran n√∫mero de herramientas de soporte para el desarrollo Java.
>>>>>>> FETCH_HEAD

Una vez tenemos todos estos datos podemos realizar el documento de backlog, un documento de alto nivel para todo el proyecto. …ste documento va a ir incluyendo gr·ficas que representan la evoluciÛn del proyecto en cada sprint.

\imgCentradaGrande{fig.3.1}{img/documentobacklog.eps}{Ejemplo del documento de backlog.}

<<<<<<< HEAD
Se concretan las acciones para el primer sprint, que consistir·n en realizar documentaciÛn sobre la estructura que tendr· el proyecto, estudio de interfaces y set up de los entornos de trabajo.


\section{Restricciones tecnolÛgicas}

\lettrine{D}{adas} las especificaciones del proyecto en base a la necesidad de que las respuestas entre los distintos dispositivos se hagan de manera inmediata y que el sistema de simulaciÛn es crÌ≠tico de forma que no nos podemos permitir pÈrdidas de comunicaciÛn ni de computaciÛn usaremos las siguientes tecnologÌ≠as que nos asegurar·n las necesidades tÈcnicas.

\subsection{ProgramaciÛn orientada a objetos}

\lettrine{L}{a} programaciÛn orientada a objetos es un paradigma de programaciÛn en el que las funciones las realizan los \emph{objetos}. Est· basado en varias tÈcnicas como la \emph{herencia}, la \emph{cohesiÛn}, \emph{abstracciÛn}, \emph{polimorfismo}, \emph{acoplamiento} y \emph{encapsulamiento}. La principal caracterÌ≠stica de Èste paradigma es que relaciona el sistema con el mundo real, en el que cada entidad que cumple una funciÛn est· representada por un objeto en el cÛdigo, asÌ≠ podemos encontrar objetos controladores, f·bricas, etc...

La herencia y el polimorfismo son tÈcnicas que nos permiten crear un cÛdigo mucho m·s legible, limpio, y f·cil de mantener debido al encapsulamiento de responsabilidades que hace que cuando necesitemos encontrar una funciÛn de nuestro cÛdigo sepamos en quÈ lugar buscar y no tengamos que depurar todas las lÌ≠neas como ocurre en paradigmas como la programaciÛn estructural. 

Entre las muchas ventajas de la programaciÛn orientada a objetos podemos encontrar la robustez del cÛdigo debido a que una clase que no funcione correctamente no debe afectar al resto del cÛdigo, es capaz de abstraer entidades del mundo real haciendo mucho m·s f·cil manejarlas en nuestro programa, facilita el desarrollo del software y el trabajo en equipo ya que dos personas ser·n capaces de trabajar sobre distintas partes del cÛdigo sin interferir una en el trabajo de la otra.

\subsubsection{CaracterÌ≠sticas de la POO}

\begin{itemize}
\item\textbf{AbstracciÛn:} Denota las caracterÌ≠sticas esenciales de un objeto, donde se capturan sus comportamientos. Cada objeto en el sistema sirve como modelo de un "agente" abstracto que puede realizar trabajo, informar y cambiar su estado, y "comunicarse" con otros objetos en el sistema sin revelar cÛmo se implementan estas caracterÌ≠sticas. Los procesos, las funciones o los mÈtodos pueden tambiÈn ser abstraÌ≠dos, y, cuando lo est·n, una variedad de tÈcnicas son requeridas para ampliar una abstracciÛn. El proceso de abstracciÛn permite seleccionar las caracterÌ≠sticas relevantes dentro de un conjunto e identificar comportamientos comunes para definir nuevos tipos de entidades en el mundo real. La abstracciÛn es clave en el proceso de an·lisis y diseÒo orientado a objetos, ya que mediante ella podemos llegar a armar un conjunto de clases que permitan modelar la realidad o el problema que se quiere atacar.
\item\textbf{Encapsulamiento:} Significa reunir todos los elementos que pueden considerarse pertenecientes a una misma entidad, al mismo nivel de abstracciÛn. Esto permite aumentar la cohesiÛn de los componentes del sistema. Algunos autores confunden este concepto con el principio de ocultaciÛn, principalmente porque se suelen emplear conjuntamente.

\item\textbf{Modularidad:} Se denomina modularidad a la propiedad que permite subdividir una aplicaciÛn en partes m·s pequeÒas (llamadas mÛdulos), cada una de las cuales debe ser tan independiente como sea posible de la aplicaciÛn en sÌ≠ y de las restantes partes. Estos mÛdulos se pueden compilar por separado, pero tienen conexiones con otros mÛdulos. Al igual que la encapsulaciÛn, los lenguajes soportan la modularidad de diversas formas.
\item\textbf{Principio de ocultaciÛn:} Cada objeto est· aislado del exterior, es un mÛdulo natural, y cada tipo de objeto expone una interfaz a otros objetos que especifica cÛmo pueden interactuar con los objetos de la clase. El aislamiento protege a las propiedades de un objeto contra su modificaciÛn por quien no tenga derecho a acceder a ellas; solamente los propios mÈtodos internos del objeto pueden acceder a su estado. Esto asegura que otros objetos no puedan cambiar el estado interno de un objeto de manera inesperada, eliminando efectos secundarios e interacciones inesperadas. Algunos lenguajes relajan esto, permitiendo un acceso directo a los datos internos del objeto de una manera controlada y limitando el grado de abstracciÛn. La aplicaciÛn entera se reduce a un agregado o rompecabezas de objetos.
\item\textbf{Polimorfismo:} Comportamientos diferentes, asociados a objetos distintos, pueden compartir el mismo nombre; al llamarlos por ese nombre se utilizar· el comportamiento correspondiente al objeto que se estÈ usando. O, dicho de otro modo, las referencias y las colecciones de objetos pueden contener objetos de diferentes tipos, y la invocaciÛn de un comportamiento en una referencia producir· el comportamiento correcto para el tipo real del objeto referenciado. Cuando esto ocurre en "tiempo de ejecuciÛn", esta ˙ltima caracterÌ≠stica se llama asignaciÛn tardÌ≠a o asignaciÛn din·mica. Algunos lenguajes proporcionan medios m·s est·ticos (en "tiempo de compilaciÛn") de polimorfismo, tales como las plantillas y la sobrecarga de operadores de C++.
\item\textbf{Herencia:} Las clases no se encuentran aisladas, sino que se relacionan entre sÌ≠, formando una jerarquÌ≠a de clasificaciÛn. Los objetos heredan las propiedades y el comportamiento de todas las clases a las que pertenecen. La herencia organiza y facilita el polimorfismo y el encapsulamiento, permitiendo a los objetos ser definidos y creados como tipos especializados de objetos preexistentes. Estos pueden compartir (y extender) su comportamiento sin tener que volver a implementarlo. Esto suele hacerse habitualmente agrupando los objetos en clases y estas en ·rboles o enrejados que reflejan un comportamiento com˙n. Cuando un objeto hereda de m·s de una clase se dice que hay herencia m˙ltiple; siendo de alta complejidad tÈcnica por lo cual suele recurrirse a la herencia virtual para evitar la duplicaciÛn de datos.
\item\textbf{RecolecciÛn de basura:} La recolecciÛn de basura o garbage collection es la tÈcnica por la cual el entorno de objetos se encarga de destruir autom·ticamente, y por tanto desvincular la memoria asociada, los objetos que hayan quedado sin ninguna referencia a ellos. Esto significa que el programador no debe preocuparse por la asignaciÛn o liberaciÛn de memoria, ya que el entorno la asignar· al crear un nuevo objeto y la liberar· cuando nadie lo estÈ usando. En la mayorÌ≠a de los lenguajes hÌ≠bridos que se extendieron para soportar el Paradigma de ProgramaciÛn Orientada a Objetos como C++ u Object Pascal, esta caracterÌ≠stica no existe y la memoria debe desasignarse expresamente.
\end{itemize}

\imgCentradaMed{fig.2.5}{img/poo.eps}{Pilares de la POO.}
=======
\lettrine{C}{usando} nos disponemos a afrontar un proyecto software uno de los miedos m√°s comunes es el de tener un c√≥digo que funciona bien, realizar alg√∫n cambio y que todo deje de funcionar y haya que volver a repetir el trabajo ya realizado anteriormente. √âste miedo est√° ampliamente superado gracias al control de versiones. √âsta t√©cnica nos permite hacer copias de seguridad peri√≥dicas de nuestro c√≥digo en un repositorio externo, de forma que si en alg√∫n momento ocurre un accidente que haga que perdamos nuestro c√≥digo dispongamos de un archivo con todas las versiones anteriores de nuestro programa pudiendo volver a un punto del tiempo en el que nuestro c√≥digo funcionaba correctamente, evitando as√≠ tener que repetir la soluci√≥n que ya ten√≠amos implementada.

Otro problema muy normal entre los equipos de desarrollo se presenta cuando varios integrantes necesitan tocar el mismo c√≥digo, sin el control de versiones, dos personas que est√©n implementando sobre el mismo fichero, sin saber qu√© est√° yaciendo el otro tendr√°n que unir, una vez finalizados sus respectivos cambios, los dos archivos en uno √∫nico en el que convivan las modificaciones que haya hecho cada uno, esto es un trabajo bastante tedioso y problem√°tico ya que en muchas ocasiones el c√≥digo de uno se ver√° afectado por el de otro, de manera que cuando el segundo vuelva a revisar su c√≥digo se encuentre que lo que ya funcionaba ahora no realiza correctamente su funci√≥n y se le presente una dura tarea de debug para averiguar qu√© cambios han afectado a su c√≥digo. El control de versiones nos permite crear varias ramas de desarrollo, de forma que cada programador trabaja en su rama y solo debe unir sus cambios al repositorio cuando se haya bajado el c√≥digo actual, haya comprobado que no hay con conflictos entre el c√≥digo principal y el suyo y su  c√≥digo est√© probado y funcionando correctamente, de esta forma siempre tendremos una versi√≥n del c√≥digo que funciona correctamente y eliminaremos la situaci√≥n en que el c√≥digo escrito por dos personas sobre el mismo fichero se vea en conflicto. √âstos motivos la convierten en una t√©cnica indispensable a la hora de organizar un equipo de desarrollo software.

Los sistemas de control de versiones pueden ser clasificados seg√∫n la arquitectura que utilizan para el almacenamiento del c√≥digo:

\begin{itemize}
\item\textbf{Centralizados:} Hay un √∫nico repositorio que almacena todo el c√≥digo y es gestionado por un administrador o grupo de administradores. Es m√°s sencillo de gestionar ya que para realizar alg√∫n cambio como la creaci√≥n de una nueva rama hay que pedir la aprobaci√≥n del responsable del repositorio. Algunos ejemplos de repositorios de √©ste tipo son \emph{Subversion} o \emph{CVS}.
\item\textbf{Distribuidos:} A diferencia de los anteriores, cada usuario tiene su propia copia del repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Existe tambi√©n un repositorio principal que sirve para sincronizar el resto de repositorios locales. Entre los repositorios de √©ste tipo podemos encontrarnos \emph{Mercurial} o \emph{Git}.
\end{itemize}

Ventajas de los sistemas distribu√≠dos:

\begin{itemize}
\item Necesita menos veces estar conectado a la red para hacer operaciones. Esto produce una mayor autonom√≠a y una mayor rapidez.
\item Aunque se caiga el repositorio remoto la gente puede seguir trabajando.
\item Al hacer los distintos repositorio una r√©plica local de la informaci√≥n de los repositorios remotos a los que se conectan, la informaci√≥n est√° muy replicada y por tanto el sistema tiene menos problemas en recuperarse si por ejemplo se quema la m√°quina que tiene el repositorio remoto. Por tanto hay menos necesidad de backups.
\item Permite mantener repositorios centrales m√°s limpios en el sentido de que un usuario puede decidir que ciertos cambios realizados por √©l en el repositorio local, no son relevantes para el resto de usuarios y por tanto no permite que esa informaci√≥n sea accesible de forma p√∫blica. Por ejemplo es muy √∫til se pueden tener versiones inestables o en proceso de codificaci√≥n o tambi√©n tags propios del usuario.
\item El servidor remoto requiere menos recursos que los que necesitar√≠a un servidor centralizado ya que gran parte del trabajo lo realizan los repositorios locales.
\item Al ser los sistemas distribuidos m√°s recientes que los sistemas centralizados, y al tener m√°s flexibilidad por tener un repositorio local y otro/s remotos, estos sistemas han sido dise√±ados para hacer f√°cil el uso de ramas (creaci√≥n, evoluci√≥n y fusi√≥n) y poder aprovechar al m√°ximo su potencial. Por ejemplo se pueden crear ramas en el repositorio remoto para corregir errores o crear funcionalidades nuevas. 
\end{itemize}

Para implementar √©sta t√©cnica en el proyecto SIMFORPAS decidimos hacer uso de las siguientes herramientas.
>>>>>>> FETCH_HEAD

\subsection{C++}

<<<<<<< HEAD
\lettrine{P}{ara} la consecuciÛn de nuestro objetivo de rapidez a la hora del procesado de datos necesitamos un lenguaje que nos ofrezca esta caracterÌ≠stica, debido a la estructura del lenguaje de programaciÛn orientado a objetos \emph{Java}, Èste resulta lento y pesado a la hora de ejecutarse lo que supondrÌ≠a retrasos en el intercambio de datos, cosa que no nos podemos permitir cuando una aeronave depende de la comunicaciÛn que mantengamos con ella. C, al ser un lenguaje a m·s bajo nivel nos ofrece Èsta caracterÌ≠stica, pero al ser un lenguaje estructural nos priva de la ventaja de los lenguajes orientados a objetos. Una buena combinaciÛn de estas dos caracterÌ≠sticas es el lenguaje C++, Èste lenguaje es una extensiÛn de C que nos permite la manipulaciÛn de objetos, desde el punto de vista de la programaciÛn orientada a objetos, Èste es un lenguaje hÌ≠brido.
=======
Haremos uso de un sistema de control de versiones distribuido, ya que su arquitectura de adecua mejor a nuestras necesidades como equipo de desarrollo. Usaremos Mercurial un sistema de control de versiones distribuido multiplataforma, originalmente escrito para trabajar en sistemas Linux como Ubuntu. Es un programa para l√≠nea de comandos y ofrece un protocolo de acceso mediante red muy eficiente que persigue reducir el tama√±o de los datos as√≠ como la gesti√≥n de m√∫ltiples peticiones y conexiones. Su c√≥digo se distribuye bajo licencia GNU GPL, lo que lo clasifica como Software Libre.
>>>>>>> FETCH_HEAD

\imgCentradaMed{fig.2.6}{img/cpp11.eps}{IlustraciÛn c++11.}

Debido a su base C de bajo nivel, teniendo que gestionar la memoria del programa, nos permite tener la velocidad requerida, por eso es la mejor opciÛn para el sistema que queremos desarrollar. En 2011 se actualizÛ la biblioteca est·ndar de C++ con la nueva versiÛn C++11, que ofrece nuevas funcionalidad para facilitar la labor del programador.

Una de las bibliotecas principales que usamos en C++ es Qt, una biblioteca multiplataforma que nos permite, entre otras funcionalidades, crear aplicaciones con interfaz gr·fica, el API de la biblioteca tambiÈn cuenta con mÈtodos para acceder a bases de datos, uso de XML, gestiÛn de hilos y otras muchas funciones ˙tiles a la hora de programar.

…ste lenguaje lo usaremos a la hora de realizar las funciones de simulaciÛn y comunicaciÛn entre los diferentes mÛdulos del sistema, en el siguiente capÌ≠tulo haremos hincapiÈ en quÈ funciÛn requerir· el uso de Èste lenguaje.

\newpage
\subsection{Java}

<<<<<<< HEAD
\lettrine{E}{l} proyecto podrÌ≠a dividirse en tres partes bien identificadas, por un lado tenemos el simulador de la aeronave, la GCS y el puesto de instructor, los dos primeros como ya hemos explicado requieren una respuesta r·pida ya que el vuelo simulado depende de la rapidez en las comunicaciones y para asegurar que el entorno es similar a un vuelo en la vida real necesitamos tratar al simulador como si fuera una aeronave real.
=======
Bitbucket es un servicio web de alojamiento de c√≥digo que use sistema de control de versiones Mercurial y Git. Ofrece alojamiento gratuito u opcional de pago, permitiendo √©ste segundo un mayor n√∫mero de participantes en el repositorio. Tambi√©n nos da la opci√≥n de crear repositorios tanto p√∫blicos como privados y el manejo de funciones propias de Mercurial como la creaci√≥n de \emph{Forks} que nos permitan clocar un repositorio en un punto determinado y desarrollar en √©l, mientras el administrador se encarga de gestionar la adici√≥n de los cambios que aporte ese foro al repositorio principal, asegurando que el c√≥digo principal siempre va a gozar de buena salud.
>>>>>>> FETCH_HEAD

Sin embargo el puesto de instructor no requiere una interacciÛn con el sistema que sea en tiempo real, sino que importa m·s que la aplicaciÛn, al estar separada del resto de mÛdulos, sea multi-plataforma para abstraernos del entorno desde el que se use y sea f·cilmente portable, asÌ≠ como que disponga de un mÈtodo de comunicaciÛn compatible con el resto del sistema. Java es un lenguaje totalmente orientado a objetos, se ejecuta sobre una m·quina virtual (JVM) adaptada a la mayorÌ≠a de sistemas operativos, lo que convierte cualquier aplicaciÛn java en multi-plataforma. 

\imgCentradaMed{fig.2.7}{img/java.eps}{Logo Java.}

<<<<<<< HEAD
Al ser un lenguaje orientado a objetos nos da todas las facilidades que ya explicamos antes y debido a la gran comunidad y a lo extendido que est· Èste lenguaje de programaciÛn tenemos un n˙mero infinito de herramientas y tecnologÌ≠as que se pueden implementar con Java, incluido el mÈtodo de comunicaciÛn entre mÛdulos que usaremos para el intercambio de informaciÛn que usaremos en el proyecto, por tanto es el lenguaje perfecto para lo que necesitamos. TambiÈn permite la implementaciÛn de p·ginas web de manera r·pida y sencilla lo que nos permitir· darle a˙n m·s accesibilidad a la aplicaciÛn ya que podrÌ≠a instalarse en un servidor y accederse desde cualquier terminal conectado a Èl.
=======
Es un cliente de escritorio para Ubuntu de control de versiones Mercurial que nos permite interactuar entre los archivos locales de nuestro c√≥digo y el repositorio remoto, de forma que nos gestiona nuestro repositorio local y nos permite tenerlo sincronizado con el remoto comprobando si ha habido cambios, pudiendo actualizar nuestro repositorio, el remoto y todas las funciones caracter√≠sticas del control de versiones como los push, pull, as√≠ como una herramienta de soluci√≥n de conflictos en el c√≥digo.
>>>>>>> FETCH_HEAD

\subsection{ANIMO DDS}

<<<<<<< HEAD
\lettrine{P}{ara} solucionar el problema de intercambio de datos entre los distintos mÛdulos que compondr·n nuestro sistema usaremos un midleware de comunicaciones basado en DDS RTI (Data DIstribution Service de la compaÒÌ≠a Real Time Innovations), una tecnologÌ≠a que nos permite conectar varios sistemas entre sÌ≠ de forma distribuida, de esta forma disponemos de un medio de intercambio de informaciÛn sencillo, escalable y sin necesidad de preocuparnos de conectividad a bajo nivel. El uso de DDS RTI tambiÈn nos garantiza que las comunicaciones se realizar·n en tiempo real y sin perder ning˙n dato, una funcionalidad indispensable cuando estamos trabajando con dispositivos crÌ≠ticos como los UAV en los que cualquier pÈrdida de alg˙n dato puede introducir fallos en el sistema. Al estar basado en el patrÛn publicador-subscriptor y nuestro entorno estar estructurado en mÛdulos podemos ampliar la funcionalidad como queramos sin necesidad de afectar al resto de mÛdulos. Por ejemplo, si la aeronave est· publicando su posiciÛn podemos crear una aplicaciÛn de monitorizaciÛn que se subscriba a este dato sin afectar al resto de componentes.

ANIMO es un framework envoltura de DDS RTI que nos ofrece una serie de herramientas que facilitan el uso de estas librerÌ≠as ya que simplifica muchas de las configuraciones previas necesarias para realizar una comunicaciÛn DDS, tambiÈn permite mediante un sencillo archivo de configuraciÛn crear los archivos necesarios para un nuevo tipo de dato autom·ticamente mediante un generador de cÛdigos. Gracias a las calidades de servicio de DDS RTI podemos definir muchas variables en la comunicaciÛn de los datos, desde enviar un primer dato cuando se inicie la comunicaciÛn para un cierto tipo con el fin de comprobar que todo funciona bien hasta decidir el tiempo que tiene que pasar para que un dato se de por perdido o incluso establecer un identificador para el destinatario, de esta forma nos aseguramos que la comunicaciÛn es fiable y segura.
=======
\lettrine{E}{l} c√≥digo escrito por un programador est√° siempre sujeto a errores inherentes a la condici√≥n humana, por √©ste motivo siempre debemos probar un c√≥digo despu√©s de haberlo implementado. Si trat√°semos de probar el c√≥digo despu√©s de haber acabado un proyecto completo seguramente nos encontrar√≠amos con una gran cantidad de fallos dif√≠cilmente localizables y requerir√≠a mucho tiempo descubrir qu√© es lo que funciona mal y cu√°l es su soluci√≥n. Una buena t√©cnica para evitar esto es realizar pruebas al c√≥digo parte a parte, otorg√°ndole a cada clase su propia prueba de forma unitaria,
 
 Entre las ventajas del uso de las pruebas unitarias se encuentran:
 
 \paragraph{Encuentra problemas a tiempo:} En TDD, como ya explicamos anteriormente, se intenta definir primero la funcionalidad de una clase escribiendo la condici√≥n que tiene que cumplir para que su funcionamiento se de por bueno a trav√©s de una prueba unitaria, de esta forma tendremos conocimiento de cuando falla el c√≥digo inmediatamente despu√©s de haberlo escrito. Por tanto, las pruebas unitarias alertan a los desarrolladores de un problema antes de que el producto salga al mercado.
 \paragraph{Facilita los cambios:} Las pruebas unitarias permiten al programador realizar refactorizaciones comprobando que cada parte individual del c√≥digo sigue cumpliendo su funci√≥n. El procedimiento requiere que se escriban pruebas para cada m√©todo del programa por lo que cualquier lugar en el que haya ocurrido un error ser√° r√°pidamente reconocible ya que la prueba nos indicar√° d√≥nde se ha producido el fallo.
 \paragraph{Simplifica la integraci√≥n:} Ayudan a la integraci√≥n entre diferentes unidades del sistema haciendo m√°s sencillas las pruebas de varias clases en conjunto ya que cuando se vayan a hacer estas no tenemos que probar los fallos referentes al funcionamiento individual de las clases. En las pruebas unitarias de una clase no debe intervenir ninguna otra, esas casu√≠sticas se tratan en las pruebas de integraci√≥n.
 \paragraph{Aporta documentaci√≥n:} Las pruebas aportan documentaci√≥n pr√°ctica sobre el c√≥digo ya que para implementarlos hemos tenido que utilizar esas clases de forma correcta y queda plasmada en ellos c√≥mo quiere el desarrollado que se use esa clase, de forma que cualquiera que quiera usar ese c√≥digo o conocer su funcionamiento puede acudir a las pruebas para ver de primera mano qu√© est√°n haciendo esas clases.
 \paragraph{Mejora el dise√±o:} Cuando el software es desarrollado con guiado mediante pruebas, la combinaci√≥n entre escribir los test pare definir las interfaces con la refactorizaci√≥n del c√≥digo despu√©s de que se valide la prueba correctamente hace que la estructura del c√≥digo adquiera una forma adecuada y optimizada mejorando as√≠ la calidad del mismo y favoreciendo las futuras modificaciones.
 
 \subsubsection{Google Test}
 
 Para la gesti√≥n de las pruebas unitarias en los proyectos que est√©n escritos en el lenguaje de programaci√≥n C++ usaremos la biblioteca de pruebas de Google \emph{Google Test}. √âsta librer√≠a nos ofrece una amplia gama de herramientas para probar nuestro c√≥digo, d√°ndonos la oportunidad de ejecutar los test por separados o todos a la vez, lo que hace que cubra las necesidades de un amplio espectro de perfiles de desarrolladores.
 
 Google test funciona separando cada test de manera que unos no interfieran sobre la ejecuci√≥n de los dem√°s lo que nos proporciona fiabilidad y robustez en nuestras pruebas. Tambi√©n ejecuta todas las pruebas definidas en el proyecto de manera que no necesitamos listarlas de manera especial para indicarle qu√© test tenemos. Otra caracter√≠stica es la b√∫squeda de ofrecer el mayor n√∫mero de informaci√≥n sobre el c√≥digo que se est√° probando de manera que no para en el primer error que encuentra sino que sigue con las siguientes pruebas para darnos una visi√≥n m√°s global del estado de nuestro proyecto. Tambi√©n nos permite reutilizar y compartir c√≥digo e instancias de objetos entre los diferentes tests, que gestionamos con los \emph{set-ups} y \emph{tear-downs} de manera que los tests ser√°n m√°s r√°pidos.
 
 \subsubsection{JUnit}
 
 En cuanto a la parte del proyecto realizada en c√≥digo Java haremos uso de las muy extendidas bibliotecas de pruebas para Java \emph{JUnit}. Son un conjunto de clases que nos permiten realizar la ejecuci√≥n de clases Java de manera controlada para poder evaluar si el funcionamiento de los m√©todos de la clase se comporta como se espera. Es decir, en funci√≥n de alg√∫n valor de entrada se eval√∫a el valor de retorno esperado, al igual que la biblioteca de pruebas para C++.
 
 Existe integraci√≥n para Eclipse de JUnit, el cual puede ser obtenido a trav√©s del \emph{Market Place} incluido en el mismo programa, el cual nos ofrece un entorno gr√°fico para la visualizaci√≥n de los resultados de las pruebas. Los tests se definen mediante anotaciones, una t√©cnica muy usada en Java que nos permite a√±adir metadatos al c√≥digo fuente para la aplicaci√≥n en tiempo de ejecuci√≥n de matera que nos libera de tener que usar una biblioteca y a√±adir m√°s l√≠neas a nuestro c√≥digo.
 
\subsection{Mocks}

\lettrine{L}{as} pruebas unitarias requieren que solamente se valide una √∫nica clase de forma que no afecte a la prueba ninguna otra. Pero en m√∫ltiples ocasiones nos encontramos con que la clase que queremos someter a pruebas depende de una clase externa y su funcionamiento est√° ligado a la interacci√≥n con esta otra clase. Para solucionar esta paradoja se nos ofrece una herramienta como son los objetos \emph{Mock}, estos objetos tienen la funci√≥n de comportarse como una imitaci√≥n de la clase real. Si por ejemplo necesitamos hacer uso de un m√©todo que realiza la multiplicaci√≥n entre dos n√∫meros y cuyo resultado usaremos para realizar alguna acci√≥n en la clase que estamos probando, la implementaci√≥n de estas clase multiplicaci√≥n nos ofrecer√° un m√©todo que nos devuelva un n√∫mero, no nos interesa que realice ninguna operaci√≥n sino que nos devuelva lo que necesitamos para ejecutar nuestro c√≥digo. Si us√°ramos la clase real estar√≠amos condicionados a suponer el buen funcionamiento de esta clase, de esta forma, no dependemos de ninguna forma de la clase, sino que nos ce√±iremos a probar que la clase que estamos probando funciona correctamente. El si las clases de las que dependemos funcionan bien o no ser√° responsabilidad de los test de esas clases respectivamente.
>>>>>>> FETCH_HEAD

\imgCentradaMed{fig.2.16}{img/rti.eps}{Logo de RTI.}

\newpage
\subsection{Mavlink}

<<<<<<< HEAD
\lettrine{P}{ara} realizar las comunicaciones entre los distintos mÛdulos que compondr·n el simulador usaremos el protocolo de comunicaciones Mavlink que es el que se usar· realmente en un vuelo con el UAV para el que realizaremos el entorno de simulaciÛn, es un protocolo de comunicaciones simple para aeronaves no tripuladas de menos de 25 kilogramos, se sopesÛ utilizar el protocolo definido por STANAG, el acuerdo de normalizaciÛn de la OTAN, pero Èste protocolo es m·s amplio y detallado y hubiÈramos gastado demasiado tiempo en la implementaciÛn del protocolo que diseÒando la funcionalidad del simulador que era lo que nos interesaba, adem·s los componentes que vamos a usar, tanto el UAV como la GCS ya tienen implementados el protocolo Mavlink, por tanto nos aprovecharemos de esto para realizar la primera aproximaciÛn.
=======
Al igual que con los entornos de pruebas unitarias, tenemos bibliotecas que nos ayudan con la generaci√≥n de objetos mock para que no tengamos que preocuparnos de generar todas estas clases adicionales nosotros mismos. Para pruebas unitarias con Google Test usaremos \emph{GMock}, una biblioteca de Google que nos permite generar este tipo de objetos r√°pidamente, de manera sencilla y con una amplia gana de configuraciones entre las que podemos probar el n√∫mero de veces que se espera llamar a √©se m√©todo y qu√© objeto queremos que devuelva en cada una de las llamadas as√≠ como definir con qu√© par√°metros de entrada se debe invocar, todo esto integrado con el entorno de pruebas de Google Test. Existe una amplia documentaci√≥n sobre √©sta tecnolog√≠a incluido el \emph{CookBook para GMock} de Google donde se explican detalladamente y con ejemplos cada una de las caracter√≠sticas de esta biblioteca.
>>>>>>> FETCH_HEAD

\imgCentrada{fig.2.22}{img/mavlink.eps}{Logo Mavlink.}

El protocolo Mavlink define una serie de interfaces a usar en las comunicaciones entre la estaciÛn de control de tierra y la aeronave y unos protocolos de utilidad durante el revuelo y la misiÛn del aviÛn como pueden ser carga de misiÛn, ordenes, mensajes de error, monitorizaciÛn de sensores, etcÈtera.

<<<<<<< HEAD
Cada mensaje del protocolo va a su vez encapsulado dentro de un paquete que guarda datos del envÌ≠o como el n˙mero de secuencia de ese paquete, el sistema y el componente al que va destinado, un flag de control de envÌ≠o, un flag de inicio de transmisiÛn...
=======
Para JUnit tambi√©n tenemos una biblioteca similar que es \emph{jMock}, jMock nos ofrece las mismas caracter√≠sticas que ya explicamos anteriormente con GMock, tiene integraci√≥n con JUnit y al estar dise√±ado con anotaciones tambi√©n permite que nuestro c√≥digo quede m√°s limpio, r√°pido y sea m√°s f√°cil de usar. Nos permite especificar que tipo de interacci√≥n existe entre nuestros objetos reduciendo la fragilidad de nuestro c√≥digo.
>>>>>>> FETCH_HEAD

Es un protocolo muy extendido y tiene soporte para muchas plataformas, tanto software como hardware, se puede usar con los autopilotos Parrot AR.Drone, ArduPilot, PX4FMU, pxIMU, SmartAP, MatrixPilot, Armazilla 10dM3UOP88 y software como AndroidPilot, APM Planner 2.0, DroidPlanner, MAVProxy, MissionPlanner, QGroundControl(implementado por la compaÒÌ≠a creadora de Mavlink). …stos son los oficiales, mucha gente lo ha usado como nosotros para sus propios autopilotos a parte de los aquÌ≠ redactados y tiene una gran comunidad detr·s.

<<<<<<< HEAD
En nuestro sistema usaremos a parte de los mensajes de comando, monitorizaciÛn y errores la secuencia definida por Mavlink para la escritura de la misiÛn en el aviÛn cuyo funcionamiento describirÈ a continuaciÛn para ilustrar el uso de los mensajes de Èste protocolo.

\subsubsection{Escritura de misiÛn con el protocolo Mavlink}
=======
\lettrine{C}{Make} es una familia de herramientas dise√±ada para construir, probar y empaquetar software. \emph{CMake} se utiliza para controlar el proceso de compilaci√≥n del software usando ficheros de configuraci√≥n sencillos e independientes de la plataforma. El proceso de construcci√≥n se controla creando uno o m√°s ficheros CMakeLists.txt en cada directorio (incluyendo subdirectorios). Cada CMakeLists.txt consiste en uno o m√°s comandos. Cada comando tiene la forma COMANDO (argumentos...) donde COMANDO es el nombre del comando, y argumentos es una lista de argumentos separados por espacios. CMake provee comandos predefinidos y definidos por el usuario. Entre las principales funcionalidades CMake nos ofrece un an√°lisis autom√°tico de dependencias. 

Debido a que en nuestro proyecto hacemos uso de subproyectos de configuraci√≥n similar como pueden ser el n√∫cleo del simulador, la primera versi√≥n del proyecto que gestiona el modelo, etc... CMake nos aporta una gran ayuda a la hora de iniciar un nuevo proyecto con caracter√≠sticas similares a alguno que ya hayamos creado ya que la configuraci√≥n la gestiona CMake y no tenemos que preocuparnos de configurar las dependencias ni otros tipos de configuraciones.
>>>>>>> FETCH_HEAD

Desde la GCS se envÌ≠a un primer mensaje hacia el UAV MISSION-COUNT, mensaje que pide iniciar una escritura de
misiÛn y que lleva un campo con el n˙mero de waypoints que va a tener esa misiÛn, luego el UAV, cuando recibe Èste mensaje, responde con un MISSION-REQUEST con el n˙mero de waypoint que quiere pedir, en el primer caso ser· el waypoint con n˙mero de secuencia 0, al llegar ese mensaje a la GCS Èsta sabr· que puede enviar el primer waypoint e inicia un contador de tiempo, si en un tiempo determinado no ha recibido el siguiente MISSION-REQUEST desde el UAV significa que ha habida alg˙n problema en el envÌ≠o por lo que tendremos que enviarlo otra vez, cuando ha llegado el mensaje al UAV Èste vuelve a enviar un nuevo MISSION-REQUEST pidiendo el siguiente waypoint, cuando todos los waypoints han sido enviados el UAV envÌ≠a un mensaje MISSION-ACK que informa a la GCS que ha llegadoo el ˙ltimo waypoint correctamente y la misiÛn ha sido escrita entera en la aeronave. …ste protocolo se ilustra en la siguiente figura.

\imgCentrada{fig.2.23}{img/mavlinkwaypointwrite.eps}{Protocolo de escritura de misiÛn en Mavlink.}

\newpage
\subsection{GCS}

\lettrine{U}{na} GCS o estaciÛn de control de tierra por sus siglas en ingles (Ground Control Station) es un centro de control que facilita a un ser humano el control de vehÌ≠culos aÈreos no tripulados en el aire o en el espacio. La estaciÛn de control de tierra te permite una comunicaciÛn directa con el UAV a la hora de mandarle comandos o programar una misiÛn, cuando se realiza una misiÛn hay que hacer una sesiÛn de pre-vuelo donde se comprueba que todos los componentes del aviÛn funcionan correctamente, luego se envÌ≠a una orden de despegue y una vez volando se comanda una misiÛn al UAV, una serie de waypoints y acciones que tendr· que realizar, en cualquier momento se puede enviar una orden de vuelta a casa, una orden de que permanezca en el sitio volando en cÌ≠rculos y otras muchas. Todo esto se controla desde la estaciÛn de control, que en todo momento monitoriza la posiciÛn del UAV, la informaciÛn de telemetrÌ≠a que nos envÌ≠a, el estado de la baterÌ≠a o la gasolina, los motores, la attitud, etcÈtera.

<<<<<<< HEAD
\imgCentrada{fig.2.24}{img/qgroundcontrol.eps}{QGroundControl, gcs de Mavlink.}

En nuestro caso usaremos la GCS creada por los departamentos de AviÛnica y Sistemas No Tripulados y SimulaciÛn y Software de FADA-Catec, La GCS de Catec nos permite realizar las operaciones necesarias para probar nuestro sistema, usa el protocolo de comunicaciones Mavlink mediante UDP, nosotros le realizaremos una modificaciÛn para que pueda comunicarse con el resto de mÛdulos mediante ANIMO DDS. Con Èsta GCS podemos monitorizar los datos del UAV, comandarle una misiÛn, comandarle que haga \emph{loiter} (Que gire en torno a un waypoint) o que entre en \emph{failsafe} y vaya a una zona segura. TambiÈn incorpora una pantalla de monitorizaciÛn de alarmas que nos indica en todo momento el estado de la aeronave.

La GCS de Catec est· basada en plugins, por lo que su funcionalidad es ampliable, disponemos de plugins de monitorizaciÛn 3D de la aeronave, plugins de control de waypoints, plugins de monitorizaciÛnes de telemetrÌ≠a, de control de carga de pago, etcÈtera.

Nosotros hemos creado un plugin de comunicaciÛn para ANIMO DDS el cual transforma los mensajes que maneja la GCS a mensajes que puedan viajar mediante ANIMO DDS para que puedan comunicarse con nuestro simulador.

\imgCentrada{fig.2.25}{img/gcscatec.eps}{GCS de Catec.}

=======
\lettrine{M}{aven}, al igual que CMake, es una herramienta software para la creaci√≥n de proyectos, en este caso para proyectos Java con un modelo de configuraci√≥n muy simple basado en \emph{XML}. Maven utiliza un Project Object Model(POM) para describir el proyecto de software a construir, sus dependencias de otros m√≥dulos y componentes externos, y el orden de construcci√≥n de los elementos. Viene con objetivos predefinidos para realizar ciertas tareas claramente definidas, como la compilaci√≥n del c√≥digo y su empaquetado. Una caracter√≠stica clave de Maven es que est√° listo para usar en red. El motor incluido en su n√∫cleo puede din√°micamente descargar plugins de un repositorio, el mismo repositorio que provee acceso a muchas versiones de diferentes proyectos Open Source en Java, de Apache y otras organizaciones y desarrolladores. Maven provee soporte no s√≥lo para obtener archivos de su repositorio, sino tambi√©n para subir artefactos al repositorio al final de la construcci√≥n de la aplicaci√≥n, dej√°ndola al acceso de todos los usuarios. Una cach√© local de artefactos act√∫a como la primera fuente para sincronizar la salida de los proyectos a un sistema local.

Otra aplicaci√≥n interesante de Maven es la posibilidad de crear \emph{arquetipos}. Los arquetipos se pueden considerar como plantillas de configuraci√≥n para un nuevo proyecto, de forma que una vez configurado nuestro proyecto con Maven podemos guardar esas caracter√≠sticas, librer√≠as usadas, estructura del proyecto, etc... y guardarla de manera que podamos usarla para la generaci√≥n de un proyecto de caracter√≠sticas similares.

A la hora de programar el puesto de instructor necesitaremos que sea una aplicaci√≥n web y aprovechar las m√∫ltiples bibliotecas de utilidad que nos ofrece Java como Spring, Struts, Hibernate, etc... Para gestionar todas estas configuraciones necesarias haremos uso de Maven.
>>>>>>> FETCH_HEAD
\newpage

\subsection{Locomove}

\lettrine{F}{ADA}-Catec dispone de varias aeronaves de desarrollo propio, para nuestro simulador usaremos el aviÛn elÈctrico no tripulado Locomove. Es un RPAS ligero con un motor elÈctrico que destaca por sus prestaciones de carga de pago, autonomÌ≠a y rango de vuelo para el desarrollo de aplicaciones en diferentes ·mbitos. Es un aviÛn de ala fija con una envergadura de algo m·s de dos metros, es de despegue manual, por lo que no necesita pista de despegue y una autonomÌ≠a de unos 45 a 60 minutos, puede llevar una carga de pago de un kilo y alcanza velocidades de entre 60 y 100 kilÛmetros por hora.

Al estar el autopiloto de este dispositivo preparado para trabajar con el resto de nuestros componentes y estar realizado Ì≠ntegramente en el centro supone un sujeto de pruebas perfecto ya que tenemos total control sobre sus componentes y a su vez el proyecto servir· para depurar fallos en el mismo aviÛn y poder probar las nuevas funcionalidades que se le aÒadan antes de realizar un vuelo real.

\imgCentrada{fig.2.26}{img/locomove.eps}{UAV de Catec, Locomove.}

\newpage

<<<<<<< HEAD
\subsection{Autopiloto}

\lettrine{E}{l} autopiloto embarcado dentro del UAV Locomove ha sido diseÒado y fabricado por el departamento de AviÛnica y Sistemas No Tripulados de FADA-Catec, es un disipositivo montado sobre una placa \emph{BeagleBone}, una placa de bajo consumo y hardware libre que contiene en un ˙nico panel un ordenador completo, est· pensada para utilizar software libre y se usa debido a su pequeÒo tamaÒo y peso y gran flexibilidad a la hora de desarrollar sobre ella. Las barrica la empresa americana Texas Instruments junto con Digi-key y Newmark element14.
=======
\lettrine{P}{ara} solucionar el problema de intercambio de datos entre los distintos m√≥dulos que compondr√°n nuestro sistema usaremos un midleware de comunicaciones basado en DDS RTI (Data DIstribution Service de la compa√±√≠a Real Time Innovations), una tecnolog√≠a que nos permite conectar varios sistemas entre s√≠ de forma distribuida, de esta forma disponemos de un medio de intercambio de informaci√≥n sencillo, escalable y sin necesidad de preocuparnos de conectividad a bajo nivel. El uso de DDS RTI tambi√©n nos garantiza que las comunicaciones se realizar√°n en tiempo real y sin perder ning√∫n dato, una funcionalidad indispensable cuando estamos trabajando con dispositivos cr√≠ticos como los UAV en los que cualquier p√©rdida de alg√∫n dato puede introducir fallos en el sistema. Al estar basado en el patr√≥n publicador-subscriptor y nuestro entorno estar estructurado en m√≥dulos podemos ampliar la funcionalidad como queramos sin necesidad de afectar al resto de m√≥dulos. Por ejemplo, si la aeronave est√° publicando su posici√≥n podemos crear una aplicaci√≥n de monitorizaci√≥n que se subscriba a este dato sin afectar al resto de componentes.

ANIMO es un framework envoltura de DDS RTI que nos ofrece una serie de herramientas que facilitan el uso de estas librer√≠as ya que simplifica muchas de las configuraciones previas necesarias para realizar una comunicaci√≥n DDS, tambi√©n permite mediante un sencillo archivo de configuraci√≥n crear los archivos necesarios para un nuevo tipo de dato autom√°ticamente mediante un generador de c√≥digos. Gracias a las calidades de servicio de DDS RTI podemos definir muchas variables en la comunicaci√≥n de los datos, desde enviar un primer dato cuando se inicie la comunicaci√≥n para un cierto tipo con el fin de comprobar que todo funciona bien hasta decidir el tiempo que tiene que pasar para que un dato se de por perdido o incluso establecer un identificador para el destinatario, de esta forma nos aseguramos que la comunicaci√≥n es fiable y segura.
>>>>>>> FETCH_HEAD

La BeagleBone dispone de un procesador Cortex-A8, una memoria DDR2 de 256 MB de capacidad, una ranura para memorias microSD, una entrada Fast Ethernet, y una entrada de alimentaciÛn de 300-500 mA y 5 V mini USB.

El sistema operativo utilizado en el autopiloto es QNX, un sistema operativo en tiempo real de tipo Unix desarrollado para su uso en sistemas embebidos por QNX Software Systems, empresa adquirida por BlackBerry. Est· basado en una estructura micron˙cleo que proporciona caracterÌ≠sticas de estabilidad avanzadas frente a fallos de dispositivos, aplicaciones, etcÈtera. Los sistemas operativos de tiempo real son interesantes para situaciones donde sea absolutamente necesaria una toma continua de, por ejemplo, muestra de datos. Bas·ndose en este interÈs, existen diversos proyectos para crear nuevas versiones en tiempo real de otros sistemas. Est· orientado a su utilizaciÛn en microcontroladores y sistemas crÌ≠ticos como podrÌ≠a ser nuestro ordenador embarcado.

El autopiloto se compone de varios mÛdulos funcionales, cada uno con una misiÛn bien definida. Por una parte tenemos un mÛdulo de tratamiento de mensajes que es el encargado de hacer llegar a cada componente su respectivo mensaje, otro mÛdulo se encarga de manejar la m·quina de estados de la aeronave, tambiÈn hay un mÛdulo de control y guiado de la misiÛn y un estimador que ayuda al pilotaje del aviÛn. 

A parte de los mÛdulos incluidos y necesarios para el vuelo real del UAV, en nuestro autopiloto se incluir· un mÛdulo dedicado a emular los sensores del aviÛn, ya que nuestro autopiloto no estar· volando realmente no podr· leer datos de posiciÛn GPS ni de velocidad de viento etc, por tanto estos datos se los proporcionaremos nosotros simulando el entorno real de vuelo. Este modulo llamado \emph{modelo} del aviÛn nos devolver· respuestas frente a Ûrdenes enviadas por el autopiloto de la misma forma que lo harÌ≠an los servos y sensores del UAV Locomove. M·s adelante se implantar· la posibilidad de cambiar Èste modelo para poder emular diferentes tipos de aviones en nuestro entorno.

\newpage
<<<<<<< HEAD
Quitando el modelo incorporado al autopiloto el resto del sistema es exactamente el mismo sistema que va embarcado dentro del UAV, por tanto tenemos la seguridad que el tratamiento y la respuesta ser· exactamente igual que en unas condiciones de vuelo real.

\imgCentrada{fig.2.27}{img/autopilotocatec.eps}{Autopiloto integrado en el Locomove.}

%%%%%%%%%%%%%%%%%%%%%SPRINTS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\chapter{DiseÒo arquitectÛnico}


\section{TecnologÌ≠as}

\lettrine{A}{ntes} de iniciar el desarrollo del proyecto debemos decidir quÈ tecnologÌ≠as son las m·s adecuadas a la hora de realizar ciertas tareas, como por ejemplo, elegir el entorno de desarrollo o el sistema de repositorios a utilizar, asÌ≠ como distintas librerÌ≠as y herramientas que nos ayuden en el desarrollo.

A continuaciÛn enumeraremos y daremos una breve explicaciÛn de cada una de las tecnologÌ≠as usadas durante el desarrollo del proyecto SIMFORPAS.




=======
\subsection{Spring}
\lettrine{E}{n} la realizaci√≥n de nuestro proyecto usaremos un patr√≥n de dise√±o muy extendido sobre la programaci√≥n orientada a objetos que es la \emph{Inyecci√≥n de dependencias}, este patr√≥n consiste en suministrar objetos a una clase en lugar de que sea esa clase la que los crea. De esta forma se controla mejor el acceso a los componentes y no tenemos que encapsular objetos dentro de otros objetos para mantener el acceso de forma que se nos ensucie el c√≥digo y se ponga en riesgo su legibilidad y escalabilidad. En lugar de eso una clase es la encargada de hacer de contenedor de todos los objetos necesarios durante la ejecuci√≥n del programa y desde esa clase se tomaran las instancias que se pasar√°n como par√°metros de entrada de los constructores de las clases que hagan uso de ellos.

Para implementar este patr√≥n usaremos el framework open source Spring que nos provee una serie de librer√≠as para Java para controlar de forma sencilla la inyecci√≥n de dependencias en nuestra aplicaci√≥n. Debido al √©xito y las m√∫ltiples ampliaciones que ha tenido Spring, √©ste tambi√©n nos provee de otras herramientas √∫tiles a la hora de programar como un m√≥dulo de acceso a datos para trabajar con bases de datos relacionales y no relacionales, un m√≥dulo de aplicaci√≥n del modelo vista controlador, un m√≥dulo de testing, etc√©tera...

Spring nos ofrece varias alternativas a la hora de configurar la creaci√≥n de objetos o \emph{beans}, un ase ellas es mediante un archivo XML donde se define la ruta a las clases que van a ser beans y donde se indica cuantos jeans se van a crear. Otra forma es mediante el uso de \emph{anotaciones}, definiendo directamente una anotaci√≥n en el c√≥digo de la clase podemos controlar m√°s f√°cilmente el uso de estos beans.

\subsubsection{Ventajas de la Inyecci√≥n de Dependencias}

\paragraph{Se reduce el c√≥digo pegamento: }esto quiere decir que se reduce dr?asti- camente la cantidad de c?odigo que se debe escribir para unir los distintos componentes una aplicaci?on, proporcionando bu?squedas autom?aticas para instanciar objetos remotos.

\paragraph{Se externalizan dependencias: }al ser posible colocar la configuraci√≥n de dependencias en archivos gXML, se puede realizar una reconfiguraci√≥n f√°cilmente, sin necesidad de recompilar el c√≥digo. De la misma forma, es posible realizar el cambio de la implementaci√≥n de una dependencia a otra.

\paragraph{Las dependencias se manejan en un solo lugar: }toda la informaci√≥n de dependencias es responsabilidad de un s√≥lo componente, el Contenedor de IoC de Spring, proporcionando un manejo de dependencias m?as simple y menos propenso a errores.

\paragraph{Hace que las pruebas sean m√°s f√°ciles: }como las clases ser√°n dise√±adas para hacer f√°cil el reemplazo de dependencias, se podr√°n proporcionar objetos simulados que regresen datos de prueba, de servicios o cualquier dependencia que necesite el componente que estamos probando.

\subsubsection{M√≥dulos de Spring}

\paragraph{IoC Container: }los componentes no crean, o buscan las referencias a otros componentes que necesiten para realizar su trabajo, sino que simplemente declaran qu√© dependencias tienen, y el contenedor para la Inversi√≥n de Control les proporciona autom√°ticamente estas dependencias.

\paragraph{Acceso a Datos / Integraci√≥n: }en este grupo, Spring mapea las SQLException a excepciones espec√≠ficas y automatiza la gesti√≥n de conexiones. Se declara una fuente de datos y Spring la gestiona.

\paragraph{WEB: }En este grupo se encuentran las herramientas para implementar el Patr√≥n de Dise√±oModelo Vista Controlador y el acceso a componentes remotos. Esto facilita el desarrollo de aplicaciones distribuidas y reduce el c√≥digo que se necesita para exponer un bean como servicio o para acceder desde un bean a un servicio remoto. Tambi√©n unifica distintas A.P.I. para la gesti√≥n de transacciones.

\paragraph{Programaci√≥n Orientada a Aspectos: }Permite combinar cierto c√≥digo con otro para a√±adir cierta funcionalidad al original sin necesidad de modificarlo, facilitando as√≠ la implementaci√≥n de funcionalidades transversales de una aplicaci√≥n.
>>>>>>> FETCH_HEAD

\newpage
\subsubsection{Principios S.O.L.I.D.}

\lettrine{R}{representan} cinco principios b·sicos del uso de la POO y del diseÒo software. …stos conceptos fueron recogidos por Robert C. Martin en torno al aÒo 2000, los principios S.O.L.I.D. son una guÌ≠a que ayuda al programador a elaborar un cÛdigo m·s limpio, legible y f·cil de mantener y extender. Su uso se adapta a dos conceptos que hemos visto anteriormente como son el de TDD y RefactorizaciÛn, ya que estos dos tienen como finalidad buscar un cÛdigo que cumpla siempre con estas directrices.

El acrÛnimo S.O.L.I.D. responde a las siguientes definiciones:

\begin{itemize}
\item\textbf{S}ingle responsibility principle: El principio de ˙nica responsabilidad dice que una clase sÛlo deberÌ≠a tener una ˙nica responsabilidad, de esa forma solo tendrÌ≠a una ˙nica razÛn para cambiar y asÌ≠ se contiene la propagaciÛn de cualquier cambio que realicemos sobre ella sin que afecte a otra parte del cÛdigo que no tiene nada que ver con dicha responsabilidad.
\item\textbf{O}pen/close principle: Nos explica la importancia de que el cÛdigo estÈ abierto a su extensiÛn pero cerrado a su modificaciÛn, esto nos permite modificar la funcionalidad de una clase sin necesidad de tocar su cÛdigo, lo que requerirÌ≠a revisiones, pruebas y comprobaciones de que todo sigue funcionando correctamente.
\item\textbf{L}iskov substitution principle: Es una definiciÛn particular de una relaciÛn de subtipificaciÛn, llamada tipificaciÛn del comportamiento, esto quiere decir que en un cÛdigo puede usarse cualquier clase hija del mismo padre sin que esto altere las propiedades de ese programa.
\item\textbf{I}nterface segregation principle: Es una reflexiÛn que apunta que es mejor tener muchas interfaces especÌ≠ficas a una genÈrica, de esta forma evitamos que el cliente haga uso de propiedades de la interfaz que no necesita o a las cuales no deberÌ≠a tener acceso, tambiÈn es una buena herramienta de documentaciÛn de la funcionalidad del programa y asÌ≠ se define mejor la funcionalidad de pasa clase.
\item\textbf{D}dependency inversiÛn principle: …ste principio apunta que las dependencias entre partes del cÛdigo deben hacerse sobre abstracciones no sobre implementaciones, de esta forma una clase que haga uso de otra no depender· del cÛdigo que se haya escrito para la segunda y si en alg˙n momento Èste cambiara no afectarÌ≠a a la primera. Esto ayuda a mejorar el mantenimiento del cÛdigo y lo prepara para futuras modificaciones.
\end{itemize}

\newpage

<<<<<<< HEAD

\subsection{Patrones de diseÒo}
=======
\lettrine{Y}{a} introdujimos anteriormente el modelo vista controlador o MVC y los beneficios de usarlo en nuestra aplicaci√≥n. Para su implementaci√≥n se har√° uso de Struts 2, una herramienta de soporte para el desarrollo de aplicaciones web en Java de la compa√±√≠a Apache. Es de c√≥digo abierto y nos permite simplificar la conexi√≥n entre nuestro c√≥digo java y la parte de la vista web de la aplicaci√≥n.

El n√∫cleo de Struts es un filtro conocido como \emph{FilterDispatcher} el cual nos permite ejecutar los \emph{actions} que son los m√©todos lanzados por peticiones web, comenzar la ejecuci√≥n de interceptores y gestionar la memoria para evitar fugas.
>>>>>>> FETCH_HEAD

\lettrine{A}{} la hora de programar solemos encontrarnos una gran cantidad de veces con problemas recurrentes de diseÒo de cuya soluciÛn puede depender que nuestro cÛdigo se alivie o que salga herido. Una mala soluciÛn a un problema normalmente acarrear· m·s cambios en el resto del cÛdigo, en cuanto al diseÒo del software hay una serie de problemas que son bastante conocidos ya que suelen aparecer frecuentemente, por ejemplo, tenemos que implementar una aplicaciÛn que trabaja con una base de datos y una interfaz de usuario gestionada por una clase que se comunica directamente con la base de datos y la interfaz representando estos datos. Si en alg˙n momento se quisiera modificar cualquiera de las partes, base de datos, interfaz o aÒadir una nuevo funcionalidad o modificar una ya existente este cambio afectarÌ≠a al conjunto de las partes y pr·cticamente tendrÌ≠amos que reescribir parte del cÛdigo sino el cÛdigo entero. Para resolver este problema tenemos uno de los patrones de diseÒo m·s comunes, el patrÛn MVC(Modelo Vista Controlador) el cual separa la parte de persistencia de datos o modelo de datos de la interfaz del usuario, el controlador hace de puente entre los dos anteriores y guarda la lÛgica de negocio asociada a esos datos. La vista es la interfaz con el usuario, el modelo guarda los datos con los que se trabaja y el controlador modifica esos datos.

\imgCentradaMed{fig.2.8}{img/mvc.eps}{Diagrama MVC.}

<<<<<<< HEAD
\newpage
En 1990 el grupo \emph{Gang of Four} publica el libro \emph{Design Patterns}, en el que recogen los 23 patrones de diseÒo m·s comunes, en Èste libro se recogen una serie de soluciones a problemas habituales en el diseÒo software. Los problemas que resuelven estos patrones de diseÒo han sido ampliamente estudiados por lo que podemos asegurarnos de que su uso va a ofrecernos una soluciÛn limpia y en la mayorÌ≠a de los casos Ûptima sin necesidad de tener que reintentar la rueda. El uso compulsivo de patrones de diseÒo, sin embargo, es desaconsejable, los patrones son una gran ayuda en los casos en los que necesitamos de ellos, pero retorcer el cÛdigo con la finalidad de introducir un patrÛn de diseÒo para resolver un problema que no necesitaba de ese patrÛn tambiÈn podrÌ≠a ser negativo para nuestro programa.

\subsection{Bibliotecas}

\lettrine{C}{uando} nos enfrentamos al desarrollo de un sistema complejo que requiera el uso de muchas tecnologÌ≠as disponemos de herramientas para facilitarnos el trabajo, por ejemplo, una parte importante en el desarrollo de videojuegos es el aspecto gr·fico, si deseamos animar una imagen podrÌ≠amos crearnos un programa que recoja las im·genes que queramos mostrar y crearnos un sistema que secuencie la muestra de estos dibujos creando asÌ≠ la animaciÛn, tambiÈn podrÌ≠amos implementar un sistema que gestione la fÌ≠sica de nuestro juego, esto requerirÌ≠a que diseÒ·ramos desde cero un motor de juego que nos permita m·s adelante desarrollar nuestra aplicaciÛn. Otra opciÛn es hacer uso de bibliotecas que nos den Èstas herramientas ya desarrolladas que nos permitir·, por ejemplo, mediante el archivo que guarda las im·genes y una velocidad de animaciÛn que la biblioteca usar· para autom·ticamente gestionar la animaciÛn de una forma transparente al programador. Otro ejemplo m·s sencillo es el de operaciones matem·ticas incluidas en la mayorÌ≠a de bibliotecas est·ndares de casi todos los lenguajes de programaciÛn que nos quitan el peso de tener que implementar ciertas acciones que son muy comunes, si ya est· hecho y probada su calidad y buen funcionamiento no es necesario hacerlo otra vez.
=======
Los Interceptores son clases que siguen el Patr√≥n de Dise√±o Interceptor. Estos permiten que se implementen funcionalidades cruzadas o comunes para todos los Actions, pero que se ejecuten fuera del Action (por ejemplo validaciones de datos, conversiones de tipos, poblaci√≥n de datos, etc).

√âstos realizan tareas antes y despu√©s de la ejecuci√≥n de un Action y tambi√©n pueden evitar que un Action se ejecute (por ejemplo si se est√° haciendo alguna validaci√≥n que no se ha cumplido).Tambi√©n sirven para ejecutar alg√∫n proceso particular que se quiere aplicar a un conjunto de Actions. De hecho muchas de las caracter√≠sticas con que cuenta Struts2 son proporcionadas por los Interceptors.
Si alguna funcionalidad que necesitamos no se encuentra en los Interceptores de Struts2 podemos crear nuestro propio Interceptor y agregarlo a la cadena que se ejecuta por defecto. De la misma forma, podemos modificar la cadena de Interceptor de Struts2, por ejemplo para quitar un Interceptor o modificar su orden de ejecuci√≥n.

Cada Interceptor proporciona una caracter√≠stica distinta al Action. Para sacar la mayor ventaja posible de los Interceptors, un Action permite que se aplique m?as de un Interceptor. Para lograr esto Struts2 permite crear pilas o stacks de Interceptors y aplicarlas a los Actions. Cada Interceptor es aplicado en el orden en el que aparece en la pila. Tambi√©n podemos formar pilas de Interceptors en base a otras pilas.
>>>>>>> FETCH_HEAD

Existen bibliotecas especÌ≠ficas para un gran n˙mero de utilidades, como por ejemplo la biblioteca \emph{Spring} de Java que nos permite gestionar f·cilmente la \emph{inversiÛn de control} en nuestro programa, de Èsta biblioteca hablaremos m·s adelante. TambiÈn existen bibliotecas que nos permiten acceder a ciertos recursos gr·ficos, trabajar con mapas, gestionar servicios web, hacer uso de determinadas aplicaciones, dar servicios de comunicaciÛn, etcÈtera...

<<<<<<< HEAD
\newpage
\subsection{Ubuntu 12.04}
=======
Las Acciones o Actions son clases encargadas de realizar la l√≥gica para servir una petici√≥n. Cada URL es mapeada a una Action espec√≠fica, la cual proporciona la l√≥gica necesaria para servir a cada petici√≥n hecha por el usuario. Estrictamente hablando, las Actions no necesitan implementar una interfaz o extender de alguna clase base. El √∫nico requisito para que una clase sea considerada un Action es que debe tener un m√©todo que no reciba argumentos y que devuelva un objeto String o un objeto de tipo Result. Por defecto el nombre de este m√©todo debe ser execute aunque podemos ponerle el nombre que queramos y posteriormente indicarlo en el archivo de configuraci√≥n de Struts2.
Cuando el resultado es un String, el objeto tipo Result correspondiente se obtiene de la configuraci√≥n del Action. Esto se usa para generar una respuesta para el usuario.
Los Actions pueden ser P.O.J.O.s que cumplan con el requisito anterior, aunque por lo general, tambi√©n pueden implementar la Interfaz com.opensymphony. xwork2.Action o extender una clase base que proporciona Struts2: com.opensymphony. xwork2.ActionSupport, lo cual hace m√°s sencilla su creaci√≥n y manejo.
La clase ActionSupport implementa la interfaz Action y contiene una implementaci√≥n del m√©todo execute() que devuelve el valor SUCCESS. Adem√°s proporciona unos cuantos m√©todos para establecer mensajes, tanto de error como informativos, que pueden ser mostrados al usuario.
>>>>>>> FETCH_HEAD

\lettrine{E}{n} la b˙squeda de un entorno de desarrollo que respondiese a nuestras necesidades debÌ≠amos buscar un sistema operativo que fuera estable y que nos diera libertad de configuraciÛn. El sistema que vamos a desarrollar requiere de un gran n˙mero de componentes ya sean bibliotecas o mÛdulos adicionales, los cuales pueden inducir al sistema operativo a m˙ltiples errores durante el desarrollo, si no disponemos de un sistema estable esto afectarÌ≠a a la velocidad del desarrollo y al estado de ·nimo del programador. TambiÈn nos permite manipular la totalidad del sistema de forma que podemos adaptarlo al desarrollo de la forma que mejor nos convenga, sin contar la gran comunidad que tiene detr·s al ser un sistema operativo de cÛdigo libre lo cu·l es un motivo para muchos programadores para implementar sus herramientas con compatibilidad para este sistema operativo lo que se convierte en una gran baterÌ≠a de herramientas a nuestro alcance a la hora de desarrollar un proyecto.

<<<<<<< HEAD
\imgCentradaPeq{fig.2.9}{img/ubuntu.eps}{Logo Ubuntu.}
=======
Despu√©s de que un Action haya sido procesado, se debe enviar la respuesta de regreso al usuario, esto se realiza usando Results. Este proceso tiene dos componentes, el tipo del objeto Result y el resultado mismo.
El tipo del Result indica c√≥mo debe ser tratado el resultado que se le devolver?a al cliente. Por ejemplo un tipo de Result puede enviar al usuario de vuelta un objeto JSP mientras que otro puede redirigirlo hacia otro sitio.
Un Action puede tener m?as de un objeto tipo Result asociado. Esto nos permitir√° enviar al usuario a una Vista distinta dependiendo del resultado de la ejecuci√≥n del Action. Por ejemplo, en caso de que todo salga bien, enviaremos al usuario al objeto tipo Result sucess, si algo sale mal lo enviaremos al objeto tipo Result error, o si no tiene permisos lo enviaremos al objeto tipo Result denied.
>>>>>>> FETCH_HEAD

\newpage
\subsection{Qt Creator}

\lettrine{P}{ara} el cÛdigo del simulador que como ya explicamos anteriormente hace uso de C++ ya que nos proporciona la velocidad y robustez que necesitamos en tÈcnicas de simulaciÛn en tiempo real hemos elegido Qt Creator como entorno de desarrollo integrado. Comenzamos usando \emph{Eclipse for C/C++} pero a la hora de realizar la integraciÛn con \emph{CMake}, del cual hablaremos m·s adelante, surgÌ≠an muchos problemas y la velocidad de compilaciÛn era muy reducida, despuÈs de ser aconsejados por una compaÒera de trabajo decidimos cambiar a Qt Creator, el cual ofrece un entorno de desarrollo para C++ orientado a facilitar el uso de la biblioteca Qt de C++ y con muy buena integraciÛn con CMake. Al no depender de la m·quina virtual de java la velocidad tambiÈn aumentÛ, la interfaz es mucho m·s reducida que la de Eclipse y m·s sencilla e intuitiva aportando todas las opciones de configuraciÛn que necesit·bamos.

TambiÈn nos provee de una herramienta de diseÒo de interfaces de usuario con Qt sencilla y un debugger visual. Por todos esos motivos decidimos seguir el desarrollo con Èste IDE en el caso de la programaciÛn en C++ ya que aumentÛ el rendimiento y redujo los fallos derivados del manejo del entorno de desarrollo. 

<<<<<<< HEAD
\imgCentradaPeq{fig.2.10}{img/qtcreator.eps}{Logo Qt Creator.}
=======
Para evitar tener que realizar la configuraci√≥n de Struts mediante el archivo XML, usaremos un plugin de Apache para Struts llamado \emph{Convention Plugin} el cual nos ofrece una forma sencilla de determinar en el mismo c√≥digo como realizar las conexiones entre vistas y modelos. Usando la nomenclatura de las clases que creemos podemos determinar que parte del modelo se lanzar√° cuando se haga una llamada desde la vista. As√≠ si por ejemplo tenemos una acci√≥n llamada NuestraAction.java, cuando cargamos la url con nombre nuestra-action.jsp se har√° una llamada a la acci√≥n del mismo nombre, as√≠ podemos controlar las conexiones sin necesidad de usar ni archivos de configuraci√≥n ni anotaciones.
>>>>>>> FETCH_HEAD

\newpage
\subsection{Eclipse}

<<<<<<< HEAD
\lettrine{E}{l} puesto de instructor est· escrito en cÛdigo Java ya que necesit·bamos que fuera multiplataforma, para Èste lenguaje de programaciÛn, el IDE m·s extendido es el de la propine empresa que lo diseÒÛ, Sun Microsystems, cuyo nombre es Eclipse. Es un programa compuesto por un conjunto de herramientas de cÛdigo abierto y multiplataforma orientado al desarrollo de entornos de desarrollo integrados, en nuestro caso, lo usaremos como entorno para programadores Java ya que tiene una gran integraciÛn con herramientas necesarias en nuestro proyecto como pueden ser \emph{Maven}, \emph{Junit}, Control de versiones, etcÈtera... Decidimos hacer uso de Èl debido al gran n˙mero de herramientas de soporte para el desarrollo Java.

\imgCentradaPeq{fig.2.11}{img/eclipse.eps}{Logo Eclipse.}

\subsection{Control de versiones}
=======
\lettrine{E}{n} vistas de la futura necesidad de almacenar datos de forma persistente, ya sean misiones a realizar por un alumno, log de misiones realizadas, calificaciones, datos de alumnos, modelos de distintos UAVS, etc√©tera, implementaremos un sistema que nos permitan trabajar con bases de datos de forma sencilla y escalable. Para ello requeriremos de un sistema que nos permita hacer una implementaci√≥n del patr√≥n de dise√±o \emph{DAO} o Data Access Object. Al dise√±ar una base de datos de forma tradicional necesitamos adaptar nuestro c√≥digo a los datos que vayan a guardarse en esa base de datos, y dependeremos de la forma en que est√©n guardados, el tipo de base de datos y c√≥mo se nos presenta esos datos de manera que si en alg√∫n momento se cambia algo en la base de datos ser√° muy complicado reutilizar el c√≥digo que ten√≠amos y necesitaremos realizar muchos cambios para adaptar la nueva base de datos.

Para evitar esto disponemos del patr√≥n DAO el cual consiste en disponer de unos objetos que nos hagan de puente entre nuestro programa y la base de datos, estos objetos se encargar√°n de realizar las conexiones con la base de datos y crear a partir de la petici√≥n que hagamos a esa base de datos de alguna entidad el objeto java que usaremos en la ejecuci√≥n. Si en alg√∫n momento necesitamos modificar la base de datos solo tendr√≠amos que cambiar estos objetos por unos que se adecuen a los nuevos requerimientos de forma que no afecta al resto de la aplicaci√≥n.

Para implementar esta soluci√≥n usaremos Hibernate en su versi√≥n 4.3.4, Hibernate es una herramienta de mapeo objeto-relacional para la plataforma Java, mediante anotaciones sobre las clases que queremos guardar en la base de datos podemos autogenerar los objetos DAO e incluso crear las tablas en la base de datos, todo de forma sencilla y autom√°tica.
>>>>>>> FETCH_HEAD

\lettrine{C}{usando} nos disponemos a afrontar un proyecto software uno de los miedos m·s comunes es el de tener un cÛdigo que funciona bien, realizar alg˙n cambio y que todo deje de funcionar y haya que volver a repetir el trabajo ya realizado anteriormente. …ste miedo est· ampliamente superado gracias al control de versiones. …sta tÈcnica nos permite hacer copias de seguridad periÛdicas de nuestro cÛdigo en un repositorio externo, de forma que si en alg˙n momento ocurre un accidente que haga que perdamos nuestro cÛdigo dispongamos de un archivo con todas las versiones anteriores de nuestro programa pudiendo volver a un punto del tiempo en el que nuestro cÛdigo funcionaba correctamente, evitando asÌ≠ tener que repetir la soluciÛn que ya tenÌ≠amos implementada.

Otro problema muy normal entre los equipos de desarrollo se presenta cuando varios integrantes necesitan tocar el mismo cÛdigo, sin el control de versiones, dos personas que estÈn implementando sobre el mismo fichero, sin saber quÈ est· yaciendo el otro tendr·n que unir, una vez finalizados sus respectivos cambios, los dos archivos en uno ˙nico en el que convivan las modificaciones que haya hecho cada uno, esto es un trabajo bastante tedioso y problem·tico ya que en muchas ocasiones el cÛdigo de uno se ver· afectado por el de otro, de manera que cuando el segundo vuelva a revisar su cÛdigo se encuentre que lo que ya funcionaba ahora no realiza correctamente su funciÛn y se le presente una dura tarea de debug para averiguar quÈ cambios han afectado a su cÛdigo. El control de versiones nos permite crear varias ramas de desarrollo, de forma que cada programador trabaja en su rama y solo debe unir sus cambios al repositorio cuando se haya bajado el cÛdigo actual, haya comprobado que no hay con conflictos entre el cÛdigo principal y el suyo y su  cÛdigo estÈ probado y funcionando correctamente, de esta forma siempre tendremos una versiÛn del cÛdigo que funciona correctamente y eliminaremos la situaciÛn en que el cÛdigo escrito por dos personas sobre el mismo fichero se vea en conflicto. …stos motivos la convierten en una tÈcnica indispensable a la hora de organizar un equipo de desarrollo software.

<<<<<<< HEAD
Los sistemas de control de versiones pueden ser clasificados seg˙n la arquitectura que utilizan para el almacenamiento del cÛdigo:
=======
\lettrine{A}{} la hora de hacer las pruebas es conveniente tambi√©n asegurarnos de que nuestro c√≥digo no tiene ninguna fuga de memoria que pudiera hacer que surgieran fallos o incluso que el sistema se colapsara, algunas pistas de que hay errores de memorias son la disminuci√≥n del rendimiento, que el programa vaya lento o que haya objetos devolvi√©ndonos datos err√≥neos. Para hacer una comprobaci√≥n del estado de la memoria usada por nuestro programa usaremos \emph{Valgrind}, un conjunto de herramientas de software libre que nos ayudar√° en este proceso. 
>>>>>>> FETCH_HEAD

\begin{itemize}
\item\textbf{Centralizados:} Hay un ˙nico repositorio que almacena todo el cÛdigo y es gestionado por un administrador o grupo de administradores. Es m·s sencillo de gestionar ya que para realizar alg˙n cambio como la creaciÛn de una nueva rama hay que pedir la aprobaciÛn del responsable del repositorio. Algunos ejemplos de repositorios de Èste tipo son \emph{Subversion} o \emph{CVS}.
\item\textbf{Distribuidos:} A diferencia de los anteriores, cada usuario tiene su propia copia del repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Existe tambiÈn un repositorio principal que sirve para sincronizar el resto de repositorios locales. Entre los repositorios de Èste tipo podemos encontrarnos \emph{Mercurial} o \emph{Git}.
\end{itemize}

Ventajas de los sistemas distribuÌ≠dos:

\begin{itemize}
\item Necesita menos veces estar conectado a la red para hacer operaciones. Esto produce una mayor autonomÌ≠a y una mayor rapidez.
\item Aunque se caiga el repositorio remoto la gente puede seguir trabajando.
\item Al hacer los distintos repositorio una rÈplica local de la informaciÛn de los repositorios remotos a los que se conectan, la informaciÛn est· muy replicada y por tanto el sistema tiene menos problemas en recuperarse si por ejemplo se quema la m·quina que tiene el repositorio remoto. Por tanto hay menos necesidad de backups.
\item Permite mantener repositorios centrales m·s limpios en el sentido de que un usuario puede decidir que ciertos cambios realizados por Èl en el repositorio local, no son relevantes para el resto de usuarios y por tanto no permite que esa informaciÛn sea accesible de forma p˙blica. Por ejemplo es muy ˙til se pueden tener versiones inestables o en proceso de codificaciÛn o tambiÈn tags propios del usuario.
\item El servidor remoto requiere menos recursos que los que necesitarÌ≠a un servidor centralizado ya que gran parte del trabajo lo realizan los repositorios locales.
\item Al ser los sistemas distribuidos m·s recientes que los sistemas centralizados, y al tener m·s flexibilidad por tener un repositorio local y otro/s remotos, estos sistemas han sido diseÒados para hacer f·cil el uso de ramas (creaciÛn, evoluciÛn y fusiÛn) y poder aprovechar al m·ximo su potencial. Por ejemplo se pueden crear ramas en el repositorio remoto para corregir errores o crear funcionalidades nuevas. 
\end{itemize}

Para implementar Èsta tÈcnica en el proyecto SIMFORPAS decidimos hacer uso de las siguientes herramientas.

<<<<<<< HEAD
\subsubsection{Mercurial}

Haremos uso de un sistema de control de versiones distribuido, ya que su arquitectura de adecua mejor a nuestras necesidades como equipo de desarrollo. Usaremos Mercurial un sistema de control de versiones distribuido multiplataforma, originalmente escrito para trabajar en sistemas Linux como Ubuntu. Es un programa para lÌ≠nea de comandos y ofrece un protocolo de acceso mediante red muy eficiente que persigue reducir el tamaÒo de los datos asÌ≠ como la gestiÛn de m˙ltiples peticiones y conexiones. Su cÛdigo se distribuye bajo licencia GNU GPL, lo que lo clasifica como Software Libre.

\imgCentradaPeq{fig.2.12}{img/mercurial.eps}{Logo Mercurial.}

\newpage
\subsubsection{Bitbucket}

Bitbucket es un servicio web de alojamiento de cÛdigo que use sistema de control de versiones Mercurial y Git. Ofrece alojamiento gratuito u opcional de pago, permitiendo Èste segundo un mayor n˙mero de participantes en el repositorio. TambiÈn nos da la opciÛn de crear repositorios tanto p˙blicos como privados y el manejo de funciones propias de Mercurial como la creaciÛn de \emph{Forks} que nos permitan clocar un repositorio en un punto determinado y desarrollar en Èl, mientras el administrador se encarga de gestionar la adiciÛn de los cambios que aporte ese foro al repositorio principal, asegurando que el cÛdigo principal siempre va a gozar de buena salud.

\imgCentradaPeq{fig.2.13}{img/bitbucket.eps}{Logo Bitbucket.}

\subsubsection{TortoiseHg}

Es un cliente de escritorio para Ubuntu de control de versiones Mercurial que nos permite interactuar entre los archivos locales de nuestro cÛdigo y el repositorio remoto, de forma que nos gestiona nuestro repositorio local y nos permite tenerlo sincronizado con el remoto comprobando si ha habido cambios, pudiendo actualizar nuestro repositorio, el remoto y todas las funciones caracterÌ≠sticas del control de versiones como los push, pull, asÌ≠ como una herramienta de soluciÛn de conflictos en el cÛdigo.

\newpage
\subsection{Pruebas unitarias}

\lettrine{E}{l} cÛdigo escrito por un programador est· siempre sujeto a errores inherentes a la condiciÛn humana, por Èste motivo siempre debemos probar un cÛdigo despuÈs de haberlo implementado. Si trat·semos de probar el cÛdigo despuÈs de haber acabado un proyecto completo seguramente nos encontrarÌ≠amos con una gran cantidad de fallos difÌ≠cilmente localizables y requerirÌ≠a mucho tiempo descubrir quÈ es lo que funciona mal y cu·l es su soluciÛn. Una buena tÈcnica para evitar esto es realizar pruebas al cÛdigo parte a parte, otorg·ndole a cada clase su propia prueba de forma unitaria,
 
 Entre las ventajas del uso de las pruebas unitarias se encuentran:
 
 \paragraph{Encuentra problemas a tiempo:} En TDD, como ya explicamos anteriormente, se intenta definir primero la funcionalidad de una clase escribiendo la condiciÛn que tiene que cumplir para que su funcionamiento se de por bueno a travÈs de una prueba unitaria, de esta forma tendremos conocimiento de cuando falla el cÛdigo inmediatamente despuÈs de haberlo escrito. Por tanto, las pruebas unitarias alertan a los desarrolladores de un problema antes de que el producto salga al mercado.
 \paragraph{Facilita los cambios:} Las pruebas unitarias permiten al programador realizar refactorizaciones comprobando que cada parte individual del cÛdigo sigue cumpliendo su funciÛn. El procedimiento requiere que se escriban pruebas para cada mÈtodo del programa por lo que cualquier lugar en el que haya ocurrido un error ser· r·pidamente reconocible ya que la prueba nos indicar· dÛnde se ha producido el fallo.
 \paragraph{Simplifica la integraciÛn:} Ayudan a la integraciÛn entre diferentes unidades del sistema haciendo m·s sencillas las pruebas de varias clases en conjunto ya que cuando se vayan a hacer estas no tenemos que probar los fallos referentes al funcionamiento individual de las clases. En las pruebas unitarias de una clase no debe intervenir ninguna otra, esas casuÌ≠sticas se tratan en las pruebas de integraciÛn.
 \paragraph{Aporta documentaciÛn:} Las pruebas aportan documentaciÛn pr·ctica sobre el cÛdigo ya que para implementarlos hemos tenido que utilizar esas clases de forma correcta y queda plasmada en ellos cÛmo quiere el desarrollado que se use esa clase, de forma que cualquiera que quiera usar ese cÛdigo o conocer su funcionamiento puede acudir a las pruebas para ver de primera mano quÈ est·n haciendo esas clases.
 \paragraph{Mejora el diseÒo:} Cuando el software es desarrollado con guiado mediante pruebas, la combinaciÛn entre escribir los test pare definir las interfaces con la refactorizaciÛn del cÛdigo despuÈs de que se valide la prueba correctamente hace que la estructura del cÛdigo adquiera una forma adecuada y optimizada mejorando asÌ≠ la calidad del mismo y favoreciendo las futuras modificaciones.
 
 \subsubsection{Google Test}
 
 Para la gestiÛn de las pruebas unitarias en los proyectos que estÈn escritos en el lenguaje de programaciÛn C++ usaremos la biblioteca de pruebas de Google \emph{Google Test}. …sta librerÌ≠a nos ofrece una amplia gama de herramientas para probar nuestro cÛdigo, d·ndonos la oportunidad de ejecutar los test por separados o todos a la vez, lo que hace que cubra las necesidades de un amplio espectro de perfiles de desarrolladores.
 
 Google test funciona separando cada test de manera que unos no interfieran sobre la ejecuciÛn de los dem·s lo que nos proporciona fiabilidad y robustez en nuestras pruebas. TambiÈn ejecuta todas las pruebas definidas en el proyecto de manera que no necesitamos listarlas de manera especial para indicarle quÈ test tenemos. Otra caracterÌ≠stica es la b˙squeda de ofrecer el mayor n˙mero de informaciÛn sobre el cÛdigo que se est· probando de manera que no para en el primer error que encuentra sino que sigue con las siguientes pruebas para darnos una visiÛn m·s global del estado de nuestro proyecto. TambiÈn nos permite reutilizar y compartir cÛdigo e instancias de objetos entre los diferentes tests, que gestionamos con los \emph{set-ups} y \emph{tear-downs} de manera que los tests ser·n m·s r·pidos.
 
 \subsubsection{JUnit}
 
 En cuanto a la parte del proyecto realizada en cÛdigo Java haremos uso de las muy extendidas bibliotecas de pruebas para Java \emph{JUnit}. Son un conjunto de clases que nos permiten realizar la ejecuciÛn de clases Java de manera controlada para poder evaluar si el funcionamiento de los mÈtodos de la clase se comporta como se espera. Es decir, en funciÛn de alg˙n valor de entrada se eval˙a el valor de retorno esperado, al igual que la biblioteca de pruebas para C++.
 
 Existe integraciÛn para Eclipse de JUnit, el cual puede ser obtenido a travÈs del \emph{Market Place} incluido en el mismo programa, el cual nos ofrece un entorno gr·fico para la visualizaciÛn de los resultados de las pruebas. Los tests se definen mediante anotaciones, una tÈcnica muy usada en Java que nos permite aÒadir metadatos al cÛdigo fuente para la aplicaciÛn en tiempo de ejecuciÛn de matera que nos libera de tener que usar una biblioteca y aÒadir m·s lÌ≠neas a nuestro cÛdigo.
 
\subsection{Mocks}
=======
La herramienta m√°s usada es \emph{Memcheck}, que permite realizar un seguimiento del uso de la memoria y detectar m√∫ltiples errores como uso de memoria no inicializada, lectura o escritura de memoria que ha sido previamente liberada, lectura o escritura fuera de los l√≠mites del bloque de memoria din√°mica, fugas de memoria, etc√©tera.

El uso de Valgrind sobre nuestro programa relentiza considerablemente el rendimiento de √©ste, se ejecuta mucho m√°s lento, por eso es conveniente usarlo solo en momentos cr√≠ticos, durante una b√∫squeda concreta de estos errores por ejemplo.

\newpage
Otras herramientas incluidas por Valgrind son Massif que mide el rendimiento de la porci√≥n de memoria total, Helgrind que detecta condiciones de carrera cuando varios procesos intentan acceder a la vez al mismo recurso o Cachegrind que mide el rendimiento de la cach√© durante la ejecuci√≥n.
>>>>>>> FETCH_HEAD

\lettrine{L}{as} pruebas unitarias requieren que solamente se valide una ˙nica clase de forma que no afecte a la prueba ninguna otra. Pero en m˙ltiples ocasiones nos encontramos con que la clase que queremos someter a pruebas depende de una clase externa y su funcionamiento est· ligado a la interacciÛn con esta otra clase. Para solucionar esta paradoja se nos ofrece una herramienta como son los objetos \emph{Mock}, estos objetos tienen la funciÛn de comportarse como una imitaciÛn de la clase real. Si por ejemplo necesitamos hacer uso de un mÈtodo que realiza la multiplicaciÛn entre dos n˙meros y cuyo resultado usaremos para realizar alguna acciÛn en la clase que estamos probando, la implementaciÛn de estas clase multiplicaciÛn nos ofrecer· un mÈtodo que nos devuelva un n˙mero, no nos interesa que realice ninguna operaciÛn sino que nos devuelva lo que necesitamos para ejecutar nuestro cÛdigo. Si us·ramos la clase real estarÌ≠amos condicionados a suponer el buen funcionamiento de esta clase, de esta forma, no dependemos de ninguna forma de la clase, sino que nos ceÒiremos a probar que la clase que estamos probando funciona correctamente. El si las clases de las que dependemos funcionan bien o no ser· responsabilidad de los test de esas clases respectivamente.

\subsubsection{GMock}

<<<<<<< HEAD
Al igual que con los entornos de pruebas unitarias, tenemos bibliotecas que nos ayudan con la generaciÛn de objetos mock para que no tengamos que preocuparnos de generar todas estas clases adicionales nosotros mismos. Para pruebas unitarias con Google Test usaremos \emph{GMock}, una biblioteca de Google que nos permite generar este tipo de objetos r·pidamente, de manera sencilla y con una amplia gana de configuraciones entre las que podemos probar el n˙mero de veces que se espera llamar a Èse mÈtodo y quÈ objeto queremos que devuelva en cada una de las llamadas asÌ≠ como definir con quÈ par·metros de entrada se debe invocar, todo esto integrado con el entorno de pruebas de Google Test. Existe una amplia documentaciÛn sobre Èsta tecnologÌ≠a incluido el \emph{CookBook para GMock} de Google donde se explican detalladamente y con ejemplos cada una de las caracterÌ≠sticas de esta biblioteca.
=======
\lettrine{P}{ara} realizar las comunicaciones entre los distintos m√≥dulos que compondr√°n el simulador usaremos el protocolo de comunicaciones Mavlink que es el que se usar√° realmente en un vuelo con el UAV para el que realizaremos el entorno de simulaci√≥n, es un protocolo de comunicaciones simple para aeronaves no tripuladas de menos de 25 kilogramos, se sopes√≥ utilizar el protocolo definido por STANAG, el acuerdo de normalizaci√≥n de la OTAN, pero √©ste protocolo es m√°s amplio y detallado y hubi√©ramos gastado demasiado tiempo en la implementaci√≥n del protocolo que dise√±ando la funcionalidad del simulador que era lo que nos interesaba, adem√°s los componentes que vamos a usar, tanto el UAV como la GCS ya tienen implementados el protocolo Mavlink, por tanto nos aprovecharemos de esto para realizar la primera aproximaci√≥n.
>>>>>>> FETCH_HEAD


<<<<<<< HEAD
\subsubsection{JMock}

Para JUnit tambiÈn tenemos una biblioteca similar que es \emph{jMock}, jMock nos ofrece las mismas caracterÌ≠sticas que ya explicamos anteriormente con GMock, tiene integraciÛn con JUnit y al estar diseÒado con anotaciones tambiÈn permite que nuestro cÛdigo quede m·s limpio, r·pido y sea m·s f·cil de usar. Nos permite especificar que tipo de interacciÛn existe entre nuestros objetos reduciendo la fragilidad de nuestro cÛdigo.

\subsection{CMake}

\lettrine{C}{Make} es una familia de herramientas diseÒada para construir, probar y empaquetar software. \emph{CMake} se utiliza para controlar el proceso de compilaciÛn del software usando ficheros de configuraciÛn sencillos e independientes de la plataforma. El proceso de construcciÛn se controla creando uno o m·s ficheros CMakeLists.txt en cada directorio (incluyendo subdirectorios). Cada CMakeLists.txt consiste en uno o m·s comandos. Cada comando tiene la forma COMANDO (argumentos...) donde COMANDO es el nombre del comando, y argumentos es una lista de argumentos separados por espacios. CMake provee comandos predefinidos y definidos por el usuario. Entre las principales funcionalidades CMake nos ofrece un an·lisis autom·tico de dependencias. 

Debido a que en nuestro proyecto hacemos uso de subproyectos de configuraciÛn similar como pueden ser el n˙cleo del simulador, la primera versiÛn del proyecto que gestiona el modelo, etc... CMake nos aporta una gran ayuda a la hora de iniciar un nuevo proyecto con caracterÌ≠sticas similares a alguno que ya hayamos creado ya que la configuraciÛn la gestiona CMake y no tenemos que preocuparnos de configurar las dependencias ni otros tipos de configuraciones.

Ejemplo de CMakeLists.txt

\imgCentrada{fig.2.14}{img/cmakelists.eps}{Ejemplo CMakeLists.txt.}

\newpage
\subsection{Maven}

\lettrine{M}{aven}, al igual que CMake, es una herramienta software para la creaciÛn de proyectos, en este caso para proyectos Java con un modelo de configuraciÛn muy simple basado en \emph{XML}. Maven utiliza un Project Object Model(POM) para describir el proyecto de software a construir, sus dependencias de otros mÛdulos y componentes externos, y el orden de construcciÛn de los elementos. Viene con objetivos predefinidos para realizar ciertas tareas claramente definidas, como la compilaciÛn del cÛdigo y su empaquetado. Una caracterÌ≠stica clave de Maven es que est· listo para usar en red. El motor incluido en su n˙cleo puede din·micamente descargar plugins de un repositorio, el mismo repositorio que provee acceso a muchas versiones de diferentes proyectos Open Source en Java, de Apache y otras organizaciones y desarrolladores. Maven provee soporte no sÛlo para obtener archivos de su repositorio, sino tambiÈn para subir artefactos al repositorio al final de la construcciÛn de la aplicaciÛn, dej·ndola al acceso de todos los usuarios. Una cachÈ local de artefactos act˙a como la primera fuente para sincronizar la salida de los proyectos a un sistema local.
=======
El protocolo Mavlink define una serie de interfaces a usar en las comunicaciones entre la estaci√≥n de control de tierra y la aeronave y unos protocolos de utilidad durante el revuelo y la misi√≥n del avi√≥n como pueden ser carga de misi√≥n, ordenes, mensajes de error, monitorizaci√≥n de sensores, etc√©tera.

Cada mensaje del protocolo va a su vez encapsulado dentro de un paquete que guarda datos del env√≠o como el n√∫mero de secuencia de ese paquete, el sistema y el componente al que va destinado, un flag de control de env√≠o, un flag de inicio de transmisi√≥n...

Es un protocolo muy extendido y tiene soporte para muchas plataformas, tanto software como hardware, se puede usar con los autopilotos Parrot AR.Drone, ArduPilot, PX4FMU, pxIMU, SmartAP, MatrixPilot, Armazilla 10dM3UOP88 y software como AndroidPilot, APM Planner 2.0, DroidPlanner, MAVProxy, MissionPlanner, QGroundControl(implementado por la compa√±√≠a creadora de Mavlink). √âstos son los oficiales, mucha gente lo ha usado como nosotros para sus propios autopilotos a parte de los aqu√≠ redactados y tiene una gran comunidad detr√°s.

En nuestro sistema usaremos a parte de los mensajes de comando, monitorizaci√≥n y errores la secuencia definida por Mavlink para la escritura de la misi√≥n en el avi√≥n cuyo funcionamiento describir√© a continuaci√≥n para ilustrar el uso de los mensajes de √©ste protocolo.

\subsubsection{Escritura de misi√≥n con el protocolo Mavlink}

Desde la GCS se env√≠a un primer mensaje hacia el UAV MISSION-COUNT, mensaje que pide iniciar una escritura de
misi√≥n y que lleva un campo con el n√∫mero de waypoints que va a tener esa misi√≥n, luego el UAV, cuando recibe √©ste mensaje, responde con un MISSION-REQUEST con el n√∫mero de waypoint que quiere pedir, en el primer caso ser√° el waypoint con n√∫mero de secuencia 0, al llegar ese mensaje a la GCS √©sta sabr√° que puede enviar el primer waypoint e inicia un contador de tiempo, si en un tiempo determinado no ha recibido el siguiente MISSION-REQUEST desde el UAV significa que ha habida alg√∫n problema en el env√≠o por lo que tendremos que enviarlo otra vez, cuando ha llegado el mensaje al UAV √©ste vuelve a enviar un nuevo MISSION-REQUEST pidiendo el siguiente waypoint, cuando todos los waypoints han sido enviados el UAV env√≠a un mensaje MISSION-ACK que informa a la GCS que ha llegadoo el √∫ltimo waypoint correctamente y la misi√≥n ha sido escrita entera en la aeronave. √âste protocolo se ilustra en la siguiente figura.

\imgCentrada{fig.2.23}{img/mavlinkwaypointwrite.eps}{Protocolo de escritura de misi√≥n en Mavlink.}

\newpage
\subsection{GCS}

\lettrine{U}{na} GCS o estaci√≥n de control de tierra por sus siglas en ingles (Ground Control Station) es un centro de control que facilita a un ser humano el control de veh√≠culos a√©reos no tripulados en el aire o en el espacio. La estaci√≥n de control de tierra te permite una comunicaci√≥n directa con el UAV a la hora de mandarle comandos o programar una misi√≥n, cuando se realiza una misi√≥n hay que hacer una sesi√≥n de pre-vuelo donde se comprueba que todos los componentes del avi√≥n funcionan correctamente, luego se env√≠a una orden de despegue y una vez volando se comanda una misi√≥n al UAV, una serie de waypoints y acciones que tendr√° que realizar, en cualquier momento se puede enviar una orden de vuelta a casa, una orden de que permanezca en el sitio volando en c√≠rculos y otras muchas. Todo esto se controla desde la estaci√≥n de control, que en todo momento monitoriza la posici√≥n del UAV, la informaci√≥n de telemetr√≠a que nos env√≠a, el estado de la bater√≠a o la gasolina, los motores, la attitud, etc√©tera.

\imgCentrada{fig.2.24}{img/qgroundcontrol.eps}{QGroundControl, gcs de Mavlink.}

En nuestro caso usaremos la GCS creada por los departamentos de Avi√≥nica y Sistemas No Tripulados y Simulaci√≥n y Software de FADA-Catec, La GCS de Catec nos permite realizar las operaciones necesarias para probar nuestro sistema, usa el protocolo de comunicaciones Mavlink mediante UDP, nosotros le realizaremos una modificaci√≥n para que pueda comunicarse con el resto de m√≥dulos mediante ANIMO DDS. Con √©sta GCS podemos monitorizar los datos del UAV, comandarle una misi√≥n, comandarle que haga \emph{loiter} (Que gire en torno a un waypoint) o que entre en \emph{failsafe} y vaya a una zona segura. Tambi√©n incorpora una pantalla de monitorizaci√≥n de alarmas que nos indica en todo momento el estado de la aeronave.

La GCS de Catec est√° basada en plugins, por lo que su funcionalidad es ampliable, disponemos de plugins de monitorizaci√≥n 3D de la aeronave, plugins de control de waypoints, plugins de monitorizaci√≥nes de telemetr√≠a, de control de carga de pago, etc√©tera.

Nosotros hemos creado un plugin de comunicaci√≥n para ANIMO DDS el cual transforma los mensajes que maneja la GCS a mensajes que puedan viajar mediante ANIMO DDS para que puedan comunicarse con nuestro simulador.
>>>>>>> FETCH_HEAD

Otra aplicaciÛn interesante de Maven es la posibilidad de crear \emph{arquetipos}. Los arquetipos se pueden considerar como plantillas de configuraciÛn para un nuevo proyecto, de forma que una vez configurado nuestro proyecto con Maven podemos guardar esas caracterÌ≠sticas, librerÌ≠as usadas, estructura del proyecto, etc... y guardarla de manera que podamos usarla para la generaciÛn de un proyecto de caracterÌ≠sticas similares.

A la hora de programar el puesto de instructor necesitaremos que sea una aplicaciÛn web y aprovechar las m˙ltiples bibliotecas de utilidad que nos ofrece Java como Spring, Struts, Hibernate, etc... Para gestionar todas estas configuraciones necesarias haremos uso de Maven.
\newpage
Ejemplo de POM.xml

<<<<<<< HEAD
\imgCentradaMed{fig.2.15}{img/pom.eps}{Ejemplo POM.xml.}
=======
\subsection{Locomove}

\lettrine{F}{ADA}-Catec dispone de varias aeronaves de desarrollo propio, para nuestro simulador usaremos el avi√≥n el√©ctrico no tripulado Locomove. Es un RPAS ligero con un motor el√©ctrico que destaca por sus prestaciones de carga de pago, autonom√≠a y rango de vuelo para el desarrollo de aplicaciones en diferentes √°mbitos. Es un avi√≥n de ala fija con una envergadura de algo m√°s de dos metros, es de despegue manual, por lo que no necesita pista de despegue y una autonom√≠a de unos 45 a 60 minutos, puede llevar una carga de pago de un kilo y alcanza velocidades de entre 60 y 100 kil√≥metros por hora.

Al estar el autopiloto de este dispositivo preparado para trabajar con el resto de nuestros componentes y estar realizado √≠ntegramente en el centro supone un sujeto de pruebas perfecto ya que tenemos total control sobre sus componentes y a su vez el proyecto servir√° para depurar fallos en el mismo avi√≥n y poder probar las nuevas funcionalidades que se le a√±adan antes de realizar un vuelo real.

\imgCentrada{fig.2.26}{img/locomove.eps}{UAV de Catec, Locomove.}

>>>>>>> FETCH_HEAD
\newpage


<<<<<<< HEAD
\newpage
\subsection{Spring}
\lettrine{E}{n} la realizaciÛn de nuestro proyecto usaremos un patrÛn de diseÒo muy extendido sobre la programaciÛn orientada a objetos que es la \emph{InyecciÛn de dependencias}, este patrÛn consiste en suministrar objetos a una clase en lugar de que sea esa clase la que los crea. De esta forma se controla mejor el acceso a los componentes y no tenemos que encapsular objetos dentro de otros objetos para mantener el acceso de forma que se nos ensucie el cÛdigo y se ponga en riesgo su legibilidad y escalabilidad. En lugar de eso una clase es la encargada de hacer de contenedor de todos los objetos necesarios durante la ejecuciÛn del programa y desde esa clase se tomaran las instancias que se pasar·n como par·metros de entrada de los constructores de las clases que hagan uso de ellos.

Para implementar este patrÛn usaremos el framework open source Spring que nos provee una serie de librerÌ≠as para Java para controlar de forma sencilla la inyecciÛn de dependencias en nuestra aplicaciÛn. Debido al Èxito y las m˙ltiples ampliaciones que ha tenido Spring, Èste tambiÈn nos provee de otras herramientas ˙tiles a la hora de programar como un mÛdulo de acceso a datos para trabajar con bases de datos relacionales y no relacionales, un mÛdulo de aplicaciÛn del modelo vista controlador, un mÛdulo de testing, etcÈtera...

Spring nos ofrece varias alternativas a la hora de configurar la creaciÛn de objetos o \emph{beans}, un ase ellas es mediante un archivo XML donde se define la ruta a las clases que van a ser beans y donde se indica cuantos jeans se van a crear. Otra forma es mediante el uso de \emph{anotaciones}, definiendo directamente una anotaciÛn en el cÛdigo de la clase podemos controlar m·s f·cilmente el uso de estos beans.

\subsubsection{Ventajas de la InyecciÛn de Dependencias}

\paragraph{Se reduce el cÛdigo pegamento: }esto quiere decir que se reduce dr?asti- camente la cantidad de c?odigo que se debe escribir para unir los distintos componentes una aplicaci?on, proporcionando bu?squedas autom?aticas para instanciar objetos remotos.

\paragraph{Se externalizan dependencias: }al ser posible colocar la configuraciÛn de dependencias en archivos gXML, se puede realizar una reconfiguraciÛn f·cilmente, sin necesidad de recompilar el cÛdigo. De la misma forma, es posible realizar el cambio de la implementaciÛn de una dependencia a otra.
=======
\lettrine{E}{l} autopiloto embarcado dentro del UAV Locomove ha sido dise√±ado y fabricado por el departamento de Avi√≥nica y Sistemas No Tripulados de FADA-Catec, es un disipositivo montado sobre una placa \emph{BeagleBone}, una placa de bajo consumo y hardware libre que contiene en un √∫nico panel un ordenador completo, est√° pensada para utilizar software libre y se usa debido a su peque√±o tama√±o y peso y gran flexibilidad a la hora de desarrollar sobre ella. Las barrica la empresa americana Texas Instruments junto con Digi-key y Newmark element14.

La BeagleBone dispone de un procesador Cortex-A8, una memoria DDR2 de 256 MB de capacidad, una ranura para memorias microSD, una entrada Fast Ethernet, y una entrada de alimentaci√≥n de 300-500 mA y 5 V mini USB.

El sistema operativo utilizado en el autopiloto es QNX, un sistema operativo en tiempo real de tipo Unix desarrollado para su uso en sistemas embebidos por QNX Software Systems, empresa adquirida por BlackBerry. Est√° basado en una estructura micron√∫cleo que proporciona caracter√≠sticas de estabilidad avanzadas frente a fallos de dispositivos, aplicaciones, etc√©tera. Los sistemas operativos de tiempo real son interesantes para situaciones donde sea absolutamente necesaria una toma continua de, por ejemplo, muestra de datos. Bas√°ndose en este inter√©s, existen diversos proyectos para crear nuevas versiones en tiempo real de otros sistemas. Est√° orientado a su utilizaci√≥n en microcontroladores y sistemas cr√≠ticos como podr√≠a ser nuestro ordenador embarcado.

El autopiloto se compone de varios m√≥dulos funcionales, cada uno con una misi√≥n bien definida. Por una parte tenemos un m√≥dulo de tratamiento de mensajes que es el encargado de hacer llegar a cada componente su respectivo mensaje, otro m√≥dulo se encarga de manejar la m√°quina de estados de la aeronave, tambi√©n hay un m√≥dulo de control y guiado de la misi√≥n y un estimador que ayuda al pilotaje del avi√≥n. 

A parte de los m√≥dulos incluidos y necesarios para el vuelo real del UAV, en nuestro autopiloto se incluir√° un m√≥dulo dedicado a emular los sensores del avi√≥n, ya que nuestro autopiloto no estar√° volando realmente no podr√° leer datos de posici√≥n GPS ni de velocidad de viento etc, por tanto estos datos se los proporcionaremos nosotros simulando el entorno real de vuelo. Este modulo llamado \emph{modelo} del avi√≥n nos devolver√° respuestas frente a √≥rdenes enviadas por el autopiloto de la misma forma que lo har√≠an los servos y sensores del UAV Locomove. M√°s adelante se implantar√° la posibilidad de cambiar √©ste modelo para poder emular diferentes tipos de aviones en nuestro entorno.

\newpage
Quitando el modelo incorporado al autopiloto el resto del sistema es exactamente el mismo sistema que va embarcado dentro del UAV, por tanto tenemos la seguridad que el tratamiento y la respuesta ser√° exactamente igual que en unas condiciones de vuelo real.
>>>>>>> FETCH_HEAD

\paragraph{Las dependencias se manejan en un solo lugar: }toda la informaciÛn de dependencias es responsabilidad de un sÛlo componente, el Contenedor de IoC de Spring, proporcionando un manejo de dependencias m?as simple y menos propenso a errores.

\paragraph{Hace que las pruebas sean m·s f·ciles: }como las clases ser·n diseÒadas para hacer f·cil el reemplazo de dependencias, se podr·n proporcionar objetos simulados que regresen datos de prueba, de servicios o cualquier dependencia que necesite el componente que estamos probando.

\subsubsection{MÛdulos de Spring}

\paragraph{IoC Container: }los componentes no crean, o buscan las referencias a otros componentes que necesiten para realizar su trabajo, sino que simplemente declaran quÈ dependencias tienen, y el contenedor para la InversiÛn de Control les proporciona autom·ticamente estas dependencias.

<<<<<<< HEAD
\paragraph{Acceso a Datos / IntegraciÛn: }en este grupo, Spring mapea las SQLException a excepciones especÌ≠ficas y automatiza la gestiÛn de conexiones. Se declara una fuente de datos y Spring la gestiona.

\paragraph{WEB: }En este grupo se encuentran las herramientas para implementar el PatrÛn de DiseÒoModelo Vista Controlador y el acceso a componentes remotos. Esto facilita el desarrollo de aplicaciones distribuidas y reduce el cÛdigo que se necesita para exponer un bean como servicio o para acceder desde un bean a un servicio remoto. TambiÈn unifica distintas A.P.I. para la gestiÛn de transacciones.

\paragraph{ProgramaciÛn Orientada a Aspectos: }Permite combinar cierto cÛdigo con otro para aÒadir cierta funcionalidad al original sin necesidad de modificarlo, facilitando asÌ≠ la implementaciÛn de funcionalidades transversales de una aplicaciÛn.

\imgCentradaMed{fig.2.17}{img/spring.eps}{Logo Spring.}

\newpage
\subsection{Struts 2}

\lettrine{Y}{a} introdujimos anteriormente el modelo vista controlador o MVC y los beneficios de usarlo en nuestra aplicaciÛn. Para su implementaciÛn se har· uso de Struts 2, una herramienta de soporte para el desarrollo de aplicaciones web en Java de la compaÒÌ≠a Apache. Es de cÛdigo abierto y nos permite simplificar la conexiÛn entre nuestro cÛdigo java y la parte de la vista web de la aplicaciÛn.

El n˙cleo de Struts es un filtro conocido como \emph{FilterDispatcher} el cual nos permite ejecutar los \emph{actions} que son los mÈtodos lanzados por peticiones web, comenzar la ejecuciÛn de interceptores y gestionar la memoria para evitar fugas.

Las peticiones se procesan usando tres elementos principales: Interceptors, Actions y Results.

\subsubsection{Interceptors}

Los Interceptores son clases que siguen el PatrÛn de DiseÒo Interceptor. Estos permiten que se implementen funcionalidades cruzadas o comunes para todos los Actions, pero que se ejecuten fuera del Action (por ejemplo validaciones de datos, conversiones de tipos, poblaciÛn de datos, etc).

…stos realizan tareas antes y despuÈs de la ejecuciÛn de un Action y tambiÈn pueden evitar que un Action se ejecute (por ejemplo si se est· haciendo alguna validaciÛn que no se ha cumplido).TambiÈn sirven para ejecutar alg˙n proceso particular que se quiere aplicar a un conjunto de Actions. De hecho muchas de las caracterÌ≠sticas con que cuenta Struts2 son proporcionadas por los Interceptors.
Si alguna funcionalidad que necesitamos no se encuentra en los Interceptores de Struts2 podemos crear nuestro propio Interceptor y agregarlo a la cadena que se ejecuta por defecto. De la misma forma, podemos modificar la cadena de Interceptor de Struts2, por ejemplo para quitar un Interceptor o modificar su orden de ejecuciÛn.
=======
\part{Sistema a desarrollar}
\chapter{Planificaci√≥n inicial}
\section{Lanzamiento del proyecto}

\lettrine{A}{} principios del mes de Octubre de 2013 se re√∫ne el equipo de desarrollo del proyecto SIMFORPAS formado por Irene Alejo, Jaime Rey, Manuel Mateos y Yamnia Rodr√≠guez junto con Pablo Morillas desarrollado de la GCS en car√°cter de experto sobre comunicaciones entre GCS y UAV y manejo de la GCS. √âsta reuni√≥n constituye la primera etapa del desarrollo incremental guiado por Scrum, en ella se definir√°n los roles existentes y se pondr√°n en com√∫n las historias de usuario necesarias para la consecuci√≥n de los objetivos del proyecto.

\subsection{Definici√≥n de roles}

\lettrine{S}{e} ponen en com√∫n los posibles roles que participar√°n en el desarrollo entre los que salen el cliente, que comprar√° la aplicaci√≥n, los usuarios que ser√°n el instructor y el alumno, el equipo de desarrollo y el instalador del sistema. Estos actores tendr√°n sus requerimientos sobre el sistema y sus exigencias sobre la funcionalidad que tiene que darse en √©l para su beneficio. Por tanto haremos una descripci√≥n de la funci√≥n de cada uno y despu√©s los usaremos para definir las historias de usuarios.

Al ser un proyecto de investigaci√≥n sobre √©sta tecnolog√≠a no disponemos de un cliente, si en un futuro se pretende vender √©ste producto nos pondremos nosotros mismos en el papel del cliente imaginando c√≥mo debe ser el producto final.

\begin{itemize}
\item\textbf{Instructor:} Ser√° el encargado de manejar el puesto de instructor mediante el cual podr√° recibir datos del puesto de un alumno y en base a la informaci√≥n intercambiada decidir si √©ste es apto o no para recibir un t√≠tulo de operador de GCS.

El instructor necesitar√° herramientas que le permitan evaluar los conocimientos del alumno. Deber√° visualizar cuando sea preciso el puesto del alumno para monitorizar sus acciones, ser capaz de introducir errores en el modelo para comprobar la reacci√≥n del alumno y guardar un log con la evoluci√≥n de la misi√≥n.

\item\textbf{Alumno:} Este actor ser√° evaluado por un instructor haciendo uso del sistema. Requerir√° disponer de una GCS que simule un entorno real de pilotaje de UAV, un instructor que le cargue una misi√≥n y supervise durante el desarrollo de la misma. El sistema deber√° tener unas condiciones lo m√°s parecidas a un caso real para comprobar que los conocimientos adquiridos por el alumno son correctos y pueden usarse en un entorno real.

\item\textbf{Desarrollador:} Es el encargado del dise√±o, escritura y posterior montaje del sistema. Necesitar√° para ello informaci√≥n ver√≠dica sobre los requisitos que se necesitan, un entorno de desarrollo adecuado y las herramientas necesarias.

\item\textbf{Instalador del sistema:} Es el actor encargado de preparar los equipos para que trabajen con el software desarrollado durante el proyecto. Necesitar√° un equipo adecuado para instalar el puesto del alumno y otro para el del instructor, que el software disponga de un instalador con todas las herramientas necesarias para el correcto funcionamiento del sistema.

\item\textbf{Cliente:} Ser√° el interesado en adquirir el software para instruir a futuros operadores de GCS. Necesitar√° un entorno de aprendizaje que simule fielmente las condiciones de pilotaje de UAV y permita a un instructor ser capaz de evaluar al alumno.
>>>>>>> FETCH_HEAD

Cada Interceptor proporciona una caracterÌ≠stica distinta al Action. Para sacar la mayor ventaja posible de los Interceptors, un Action permite que se aplique m?as de un Interceptor. Para lograr esto Struts2 permite crear pilas o stacks de Interceptors y aplicarlas a los Actions. Cada Interceptor es aplicado en el orden en el que aparece en la pila. TambiÈn podemos formar pilas de Interceptors en base a otras pilas.

\subsubsection{Actions}

<<<<<<< HEAD
Las Acciones o Actions son clases encargadas de realizar la lÛgica para servir una peticiÛn. Cada URL es mapeada a una Action especÌ≠fica, la cual proporciona la lÛgica necesaria para servir a cada peticiÛn hecha por el usuario. Estrictamente hablando, las Actions no necesitan implementar una interfaz o extender de alguna clase base. El ˙nico requisito para que una clase sea considerada un Action es que debe tener un mÈtodo que no reciba argumentos y que devuelva un objeto String o un objeto de tipo Result. Por defecto el nombre de este mÈtodo debe ser execute aunque podemos ponerle el nombre que queramos y posteriormente indicarlo en el archivo de configuraciÛn de Struts2.
Cuando el resultado es un String, el objeto tipo Result correspondiente se obtiene de la configuraciÛn del Action. Esto se usa para generar una respuesta para el usuario.
Los Actions pueden ser P.O.J.O.s que cumplan con el requisito anterior, aunque por lo general, tambiÈn pueden implementar la Interfaz com.opensymphony. xwork2.Action o extender una clase base que proporciona Struts2: com.opensymphony. xwork2.ActionSupport, lo cual hace m·s sencilla su creaciÛn y manejo.
La clase ActionSupport implementa la interfaz Action y contiene una implementaciÛn del mÈtodo execute() que devuelve el valor SUCCESS. Adem·s proporciona unos cuantos mÈtodos para establecer mensajes, tanto de error como informativos, que pueden ser mostrados al usuario.
=======
\lettrine{A}{} partir de los actores del proyecto se definir√°n las historias de usuario. Una historia de usuario es una representaci√≥n de un requisito de software escrito en una o dos frases utilizando el lenguaje com√∫n del usuario. √âstas historias de usuario son utilizadas en la metodolog√≠a Scrum para la especificaci√≥n de requisitos. Cada historia de usuario debe ser limitada, esta deber√≠a poderse escribir sobre una nota adhesiva peque√±a. Son una forma r√°pida de administrar los requisitos de los usuarios sin tener que elaborar gran cantidad de documentos formales y sin requerir de mucho tiempo para administrarlos. Las historias de usuario permiten responder r√°pidamente a los requisitos cambiantes. Vamos a enumerar caracter√≠sticas que deben cumplir las historias de usuario.
>>>>>>> FETCH_HEAD

\subsubsection{Results}

DespuÈs de que un Action haya sido procesado, se debe enviar la respuesta de regreso al usuario, esto se realiza usando Results. Este proceso tiene dos componentes, el tipo del objeto Result y el resultado mismo.
El tipo del Result indica cÛmo debe ser tratado el resultado que se le devolver?a al cliente. Por ejemplo un tipo de Result puede enviar al usuario de vuelta un objeto JSP mientras que otro puede redirigirlo hacia otro sitio.
Un Action puede tener m?as de un objeto tipo Result asociado. Esto nos permitir· enviar al usuario a una Vista distinta dependiendo del resultado de la ejecuciÛn del Action. Por ejemplo, en caso de que todo salga bien, enviaremos al usuario al objeto tipo Result sucess, si algo sale mal lo enviaremos al objeto tipo Result error, o si no tiene permisos lo enviaremos al objeto tipo Result denied.

<<<<<<< HEAD
\imgCentradaMed{fig.2.18}{img/struts2.eps}{Logo Struts 2.}

Para evitar tener que realizar la configuraciÛn de Struts mediante el archivo XML, usaremos un plugin de Apache para Struts llamado \emph{Convention Plugin} el cual nos ofrece una forma sencilla de determinar en el mismo cÛdigo como realizar las conexiones entre vistas y modelos. Usando la nomenclatura de las clases que creemos podemos determinar que parte del modelo se lanzar· cuando se haga una llamada desde la vista. AsÌ≠ si por ejemplo tenemos una acciÛn llamada NuestraAction.java, cuando cargamos la url con nombre nuestra-action.jsp se har· una llamada a la acciÛn del mismo nombre, asÌ≠ podemos controlar las conexiones sin necesidad de usar ni archivos de configuraciÛn ni anotaciones.

\newpage
\subsection{Hibernate}

\lettrine{E}{n} vistas de la futura necesidad de almacenar datos de forma persistente, ya sean misiones a realizar por un alumno, log de misiones realizadas, calificaciones, datos de alumnos, modelos de distintos UAVS, etcÈtera, implementaremos un sistema que nos permitan trabajar con bases de datos de forma sencilla y escalable. Para ello requeriremos de un sistema que nos permita hacer una implementaciÛn del patrÛn de diseÒo \emph{DAO} o Data Access Object. Al diseÒar una base de datos de forma tradicional necesitamos adaptar nuestro cÛdigo a los datos que vayan a guardarse en esa base de datos, y dependeremos de la forma en que estÈn guardados, el tipo de base de datos y cÛmo se nos presenta esos datos de manera que si en alg˙n momento se cambia algo en la base de datos ser· muy complicado reutilizar el cÛdigo que tenÌ≠amos y necesitaremos realizar muchos cambios para adaptar la nueva base de datos.

Para evitar esto disponemos del patrÛn DAO el cual consiste en disponer de unos objetos que nos hagan de puente entre nuestro programa y la base de datos, estos objetos se encargar·n de realizar las conexiones con la base de datos y crear a partir de la peticiÛn que hagamos a esa base de datos de alguna entidad el objeto java que usaremos en la ejecuciÛn. Si en alg˙n momento necesitamos modificar la base de datos solo tendrÌ≠amos que cambiar estos objetos por unos que se adecuen a los nuevos requerimientos de forma que no afecta al resto de la aplicaciÛn.
=======
\item\textbf{Negociables:} La historia en si misma no es lo suficientemente expl√≠cita como para considerarse un contrato, la discusi√≥n con los usuarios debe permitir esclarecer su alcance y √©ste debe dejarse expl√≠cito bajo la forma de pruebas de validaci√≥n.

\item\textbf{Valoradas por los clientes o usuarios:} Los intereses de los clientes y de los usuarios no siempre coinciden, pero en todo caso, cada historia debe ser importante para alguno de ellos m√°s que para el desarrollador.

\item\textbf{Estimables:} Un resultado de la discusi√≥n de una historia de usuario es la estimaci√≥n del tiempo que tomar√° completarla. Esto permite estimar el tiempo total del proyecto.

\item\textbf{Peque√±as:} Las historias muy largas son dif√≠ciles de estimar e imponen restricciones sobre la planificaci√≥n de un desarrollo iterativo. Generalmente se recomienda la consolidaci√≥n de historias muy cortas en una sola historia.

\item\textbf{Verificables:} Las historias de usuario cubren requerimientos funcionales, por lo que generalmente son verificables. Cuando sea posible, la verificaci√≥n debe automatizarse, de manera que pueda ser verificada en cada entrega del proyecto.
>>>>>>> FETCH_HEAD

Para implementar esta soluciÛn usaremos Hibernate en su versiÛn 4.3.4, Hibernate es una herramienta de mapeo objeto-relacional para la plataforma Java, mediante anotaciones sobre las clases que queremos guardar en la base de datos podemos autogenerar los objetos DAO e incluso crear las tablas en la base de datos, todo de forma sencilla y autom·tica.

<<<<<<< HEAD
\imgCentradaMed{fig.2.19}{img/hibernate.eps}{Logo Hibernate.}
=======
Despu√©s de definir todas las historias de usuario hay que valorar la dificultad de cada una de las historias de usuario para hacer una estimaci√≥n del tiempo necesario para llevarlas a cabo.  El siguiente paso consiste en darles a cada una una prioridad basada en la necesidad que tenemos de que se realicen primero o de la importancia que tengan en el sistema. Ahora enumeraremos las historias de usuario propuestas durante la reuni√≥n de lanzamiento del proyecto y la importancia que se le dio a cada uno, a mayor n√∫mero junto a la historia de usuario mayor importancia tendr√°, tambi√©n a√±adiremos el grado de dificultad de cada historia, para dar una imagen global de como usar los puntos, un grupo de trabajo de cuatro personas tiene una velocidad aproximada de 20 puntos por semana.
>>>>>>> FETCH_HEAD

\subsection{Valgrind}

<<<<<<< HEAD
\lettrine{A}{} la hora de hacer las pruebas es conveniente tambiÈn asegurarnos de que nuestro cÛdigo no tiene ninguna fuga de memoria que pudiera hacer que surgieran fallos o incluso que el sistema se colapsara, algunas pistas de que hay errores de memorias son la disminuciÛn del rendimiento, que el programa vaya lento o que haya objetos devolviÈndonos datos errÛneos. Para hacer una comprobaciÛn del estado de la memoria usada por nuestro programa usaremos \emph{Valgrind}, un conjunto de herramientas de software libre que nos ayudar· en este proceso. 

\imgCentradaMed{fig.2.20}{img/valgrind.eps}{Logo Valgrind.}
=======
\item Como cliente quiero que el desarrollo del simulador se lleve usando las herramientas y metodolog√≠as necesarias para augurar el √©xito en el desarrollo del proyecto.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9990

\item Como desarrollador quiero tener bien definida la arquitectura b√°sica a alto nivel y las herramientas principales que se van a utilizar para no perder la vista del objetivo principal del proyecto.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9980
\item Como instructor quiero que las comunicaciones entre los sistemas se realice en tiempo real como uno de los puntos para garantizar el entrenamiento veraz.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }9890
\item Como desarrollador quiero poder insertar un modelo simple de UAV en el simulador para ayudar a definir el m√©todo de carga de modelos f√≠sicos.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }9880
\item Como desarrollador quiero un m√≥dulo central capaz de cambiar y monitorizar el estado del modelo.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9790
\item Como desarrollador quiero un m√≥dulo que emule las GCS en el env√≠o y recepci√≥n de datos para no depender de las GCS a la hora de desarrollar el resto de m√≥dulos y tener as√≠ el bucle completo cerrado GCS-SIMCore-SIMModel.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }9780
\item Como cliente quiero que el modelo contemple la carga de los datos de misi√≥n utilizados en el protocolo Mavlink.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9785
\item Como desarrollador quiero que el m√≥dulo central est√© sincronizado con el modelo para asegurar que los datos son coherentes.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9775
\item Como instructor quiero que las GCS visualicen la telemetr√≠a del UAV simulado para tener control de la misi√≥n.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9770
\item Como instructor quiero que el modelo del UAV sea lo m√°s real posible para garantizar los conocimiento del alumno.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9760
\item Como cliente quiero que el desarrollo del puesto de instructor se lleve usando las herramientas y metodolog√≠as necesarias para augurar el √©xito en el desarrollo del proyecto.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9755
\item Como instructor quiero usar el autopiloto real para realizar el entrenamiento y examen.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9754
\item Como instructor quiero que las GCS establezcan un plan de vuelo para la misi√≥n simulada.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9750
\item Como instructor quiero poder iniciar la simulaci√≥n para tener control de la misi√≥n.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9680
\item Como instructor quiero poder parar la simulaci√≥n para tener control de la misi√≥n.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9670
\item Como instructor quiero poder pausar la simulaci√≥n para tener control de la misi√≥n.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9660
\item Como instructor quiero introducir fallos de p√©rdida total de comunicaci√≥n para poner a prueba al alumno.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }9650
\item Como instructor quiero visualizar las GCS para tener controlado al alumno.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9590
\item Como instructor quiero crear misiones para tener una bater√≠a de ex√°menes.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9580
\item Como instructor quiero grabar misiones que he generado en las GCS para poner a prueba al alumno en diferentes contextos.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }9570
\item Como instructor quiero cargar misiones que he generado en las GCS para poner a prueba al alumno en diferentes contextos.
\\
\textbf{Dificultad: }2
\\
\textbf{Prioridad: }9560
\item Como instalador quiero que el sistema completo sea sencillo de administrar en instalar.
\\
\textbf{Dificultad: }1
\\
\textbf{Prioridad: }9490
\item Como Instructor, quiero tener acceso a informaci√≥n que me indique, paso a paso, el funcionamiento del puesto de instructor.
\\
\textbf{Dificultad: }1
\\
\textbf{Prioridad: }9480
\item Como instructor quiero que el modelo del UAV sea lo m√°s real posible para garantizar los conocimiento del alumno.
\\
\textbf{Dificultad: }20
\\
\textbf{Prioridad: }8990
\item Como instructor quiero cambiar las condiciones del entorno (lluvia, viento?) para poner a prueba al alumno.
\\
\textbf{Dificultad: }20
\\
\textbf{Prioridad: }8980
\item Como instructor quiero elegir un UAV para la misi√≥n con el objetivo de evaluar al alumno en un UAV concreto.
\\
\textbf{Dificultad: }8
\\
\textbf{Prioridad: }8970
\item Como Instructor quiero almacenar/ consultar resultados de las pruebas para posterior evaluaci√≥n o consulta a hist√≥rico del alumno.
\\
\textbf{Dificultad: }5
\\
\textbf{Prioridad: }8960
\item Como instructor quiero tomar y guardar anotaciones sobre el examen de un alumno para posterior evaluaci√≥n.
\\
\textbf{Dificultad: }3
\\
\textbf{Prioridad: }8950
>>>>>>> FETCH_HEAD

La herramienta m·s usada es \emph{Memcheck}, que permite realizar un seguimiento del uso de la memoria y detectar m˙ltiples errores como uso de memoria no inicializada, lectura o escritura de memoria que ha sido previamente liberada, lectura o escritura fuera de los lÌ≠mites del bloque de memoria din·mica, fugas de memoria, etcÈtera.

<<<<<<< HEAD
El uso de Valgrind sobre nuestro programa relentiza considerablemente el rendimiento de Èste, se ejecuta mucho m·s lento, por eso es conveniente usarlo solo en momentos crÌ≠ticos, durante una b˙squeda concreta de estos errores por ejemplo.
=======
Una vez tenemos todos estos datos podemos realizar el documento de backlog, un documento de alto nivel para todo el proyecto. √âste documento va a ir incluyendo gr√°ficas que representan la evoluci√≥n del proyecto en cada sprint.
>>>>>>> FETCH_HEAD

\newpage
Otras herramientas incluidas por Valgrind son Massif que mide el rendimiento de la porciÛn de memoria total, Helgrind que detecta condiciones de carrera cuando varios procesos intentan acceder a la vez al mismo recurso o Cachegrind que mide el rendimiento de la cachÈ durante la ejecuciÛn.

<<<<<<< HEAD
\imgCentrada{fig.2.21}{img/valgrindreport.eps}{Resltado Valgrind.}
=======
Se concretan las acciones para el primer sprint, que consistir√°n en realizar documentaci√≥n sobre la estructura que tendr√° el proyecto, estudio de interfaces y set up de los entornos de trabajo.
>>>>>>> FETCH_HEAD


%%%SPRINTS

\part{Desarrollo del proyecto}

\chapter{Iteraciones: Sprints de desarrollo}

\section{Sprint 1: Set Up del proyecto}

\lettrine{U}{na} vez estudiados los requisitos del sistema a partir de las historias de usuario pasaremos a desarrollar la estructura global del sistema y a documentarlo todo. 

\subsection{M√≥dulos del sistema}

<<<<<<< HEAD
Se necesitar· una serie de mÛdulos que tengan una funciÛn definida cada uno de ellos con el fin de hacer el sistema lo m·s escalable posible de manera que si en alg˙n momento hay que realizar un cambio grande no afecte al resto de componentes, cada mÛdulo ser· un proyecto independiente para descentralizar el desarrollo, asÌ≠ se determina la necesidad de disponer de los siguientes elementos:
=======
Se necesitar√° una serie de m√≥dulos que tengan una funci√≥n definida cada uno de ellos con el fin de hacer el sistema lo m√°s escalable posible de manera que si en alg√∫n momento hay que realizar un cambio grande no afecte al resto de componentes, cada m√≥dulo ser√° un proyecto independiente para descentralizar el desarrollo, as√≠ se determina la necesidad de disponer de los siguientes elementos:
>>>>>>> FETCH_HEAD

\begin{itemize}
\item\textbf{Control:} Recibe un comando de control (Waypoint, velocidad, acci√≥n de alg√∫n sensor, etc) y calcula qu√© cambios hay que realizar en el modelo para alcanzarlo. El autopiloto puede ser parte del m√≥dulo de control.

<<<<<<< HEAD
\item\textbf{Modelo:} Simula las condiciones del entorno y comportamiento del UAV. Utilizar· modelos lo m·s reales posibles. Mantendr· en todo momento un estado coherente del sistema, es decir, un cambio en alguno de sus par·metros afectar· al resto seg˙n las reglas de la fÌ≠sica y de comportamiento que se hayan implementado.
=======
\item\textbf{Modelo:} Simula las condiciones del entorno y comportamiento del UAV. Utilizar√° modelos lo m√°s reales posibles. Mantendr√° en todo momento un estado coherente del sistema, es decir, un cambio en alguno de sus par√°metros afectar√° al resto seg√∫n las reglas de la f√≠sica y de comportamiento que se hayan implementado.
>>>>>>> FETCH_HEAD

\item\textbf{Simulador:} Coordina el funcionamiento del resto de m√≥dulos y monitoriza el estado del sistema en cada momento. Gestiona el flujo de informaci√≥n entre los distintos m√≥dulos durante la ejecuci√≥n del programa.

\item\textbf{GCS:} Estaci√≥n de comando y de control del UAV. Es la interfaz entre el sistema y el operador, muestra en todo momento el estado del modelo y la misi√≥n. Esta ser√° la plataforma sobre la que el operador ser√° entrenado y evaluado. El Instructor debe tener visibilidad sobre lo que el operador est√° haciendo en cada momento durante el desarrollo de la misi√≥n.

\item\textbf{Puesto de instructor:} Sirve de interfaz entre el instructor y el sistema, desde ella se podr√° cargar un modelo, una misi√≥n y controlar las acciones del alumno durante la misma. Tambi√©n permitir√° introducir errores o cambios en el sistema durante una misi√≥n con el fin de evaluar la reacci√≥n del alumno.

\end{itemize}

<<<<<<< HEAD
Es necesario un elemento central que controle el flujo en informaciÛn entre el resto de mÛdulos y los sincronice para que no se produzcan situaciones de pÈrdidas de datos o de desfases de tiempo entre los distintos mÛdulos que puedan provocar errores. Otro de los elementos necesarios ser· el llamado modelo del aviÛn, Èste modelo en una primera instancia deber· de disponer de un sistema de guiado y de tratamiento de acciones como la de la carga y gestiÛn de la misiÛn de forma que nos pueda devolver datos de telemetrÌ≠a actualizados seg˙n las condiciones globales del sistema. TambiÈn se dispondr· de un puesto de instructor que permitir· a un examinador monitorizar la misiÛn del alumno y de modificar las condiciones para comprobar su reacciÛn. Por ˙ltimo haremos uso de la GCS ya implementada por Catec para que el alumno maneje el simulador.
=======
Es necesario un elemento central que controle el flujo en informaci√≥n entre el resto de m√≥dulos y los sincronice para que no se produzcan situaciones de p√©rdidas de datos o de desfases de tiempo entre los distintos m√≥dulos que puedan provocar errores. Otro de los elementos necesarios ser√° el llamado modelo del avi√≥n, √©ste modelo en una primera instancia deber√° de disponer de un sistema de guiado y de tratamiento de acciones como la de la carga y gesti√≥n de la misi√≥n de forma que nos pueda devolver datos de telemetr√≠a actualizados seg√∫n las condiciones globales del sistema. Tambi√©n se dispondr√° de un puesto de instructor que permitir√° a un examinador monitorizar la misi√≥n del alumno y de modificar las condiciones para comprobar su reacci√≥n. Por √∫ltimo haremos uso de la GCS ya implementada por Catec para que el alumno maneje el simulador.
>>>>>>> FETCH_HEAD

\subsection{Estructura del sistema}

Al final la arquitectura queda dispuesta de la siguiente manera, comunic√°ndose todos los m√≥dulos mediante ANIMO DDS:

<<<<<<< HEAD
\imgCentradaGrande{fig.4.1}{img/arquitectura.eps}{Arquitectura del sistema, con las relaciones fÌ≠sicas entre subsistemas.}

Como podemos observar en el diagrama de arquitectura, el proyecto se dividir· en mÛdulos que se encargar·n de una funciÛn especÌ≠fica. Para realizar la interconexiÛn entre los diferentes mÛdulos usaremos el Framework de comunicaciones ANIMO para garantizar que las comunicaciones se establecen en tiempo real.

El mÛdulo del modelo y el control ser·n desarrollados con Matlab-Simulink. Para el simulador se usar·n tecnologÌ≠as web y servicios web para comunicarse con Èl (haciendo uso de ANIMO).
=======
\imgCentradaGrande{fig.4.1}{img/arquitectura.eps}{Arquitectura del sistema, con las relaciones f√≠sicas entre subsistemas.}

Como podemos observar en el diagrama de arquitectura, el proyecto se dividir√° en m√≥dulos que se encargar√°n de una funci√≥n espec√≠fica. Para realizar la interconexi√≥n entre los diferentes m√≥dulos usaremos el Framework de comunicaciones ANIMO para garantizar que las comunicaciones se establecen en tiempo real.

El m√≥dulo del modelo y el control ser√°n desarrollados con Matlab-Simulink. Para el simulador se usar√°n tecnolog√≠as web y servicios web para comunicarse con √©l (haciendo uso de ANIMO).
>>>>>>> FETCH_HEAD

En el caso de las bases de datos necesarias para guardar informaci√≥n sobre modelos de UAV, de entorno y misiones se har√° uso de bases de datos no relacionales debido a que son m√°s f√°ciles de dise√±ar, administrar y proveen de una mejora sustancial en la velocidad del sistema.

La GCS permitir√° al usuario crear, modificar e incluso cargar misiones y modelos desde un archivo externo al sistema, el c√≥digo que gestiona el funcionamiento de la GCS estar√° desarrollado en C++ y la parte encargada de la interfaz de usuario se realizar√° usando las bibliotecas QT.

\subsection{Diagramas de secuencia}

Una vez estudiados los elementos necesarios haremos una lista de las interfaces u objetos que necesitaremos manejar durante la ejecuci√≥n de nuestro programa. Para ello tuvimos una reuni√≥n con el equipo que trabaja en el desarrollo de la estaci√≥n de control para saber qu√© datos manejan ellos, conocer las entradas y salidas de su aplicaci√≥n, los pasos de ejecuci√≥n etc√©tera. Como nosotros debemos simular el comportamiento de la aeronave vamos a definir una serie de diagramas de secuencias donde se definan las distintas acciones que implementaremos en nuestra aplicaci√≥n.

\begin{itemize}
\item\textbf{Funcionamiento b√°sico durante la ejecuci√≥n de una misi√≥n}

\imgCentradaGrande{fig.4.2}{img/funcionamientobasicomision.eps}{Diagrama de secuencia de la ejecuci√≥n de una misi√≥n.}

<<<<<<< HEAD
En el primer paso la GCS envÌ≠a una seÒal de inicio de ejecuciÛn de una misiÛn al simulador que reenvÌ≠a al control. El control envÌ≠a el estado inicial al modelo que responde con el estado actualizado que m·s tarde se envÌ≠a al simulador para mostrarlo en la GCS.

A continuaciÛn se inicia el bucle principal de la misiÛn, el cual acabar· cuando se hayan alcanzado todos los Waypoints. El control envÌ≠a un Waypoint al modelo, que responde con su estado el cual se envÌ≠a al simulador para mostrarlo en la GCS. Una vez alcanzado este Waypoint el control procedera? a enviar el siguiente. Cuando se hayan alcanzado todos los Waypoints ha acabado la misiÛn y el simulador envÌ≠a un mensaje a la GCS.
=======
En el primer paso la GCS env√≠a una se√±al de inicio de ejecuci√≥n de una misi√≥n al simulador que reenv√≠a al control. El control env√≠a el estado inicial al modelo que responde con el estado actualizado que m√°s tarde se env√≠a al simulador para mostrarlo en la GCS.

A continuaci√≥n se inicia el bucle principal de la misi√≥n, el cual acabar√° cuando se hayan alcanzado todos los Waypoints. El control env√≠a un Waypoint al modelo, que responde con su estado el cual se env√≠a al simulador para mostrarlo en la GCS. Una vez alcanzado este Waypoint el control procedera? a enviar el siguiente. Cuando se hayan alcanzado todos los Waypoints ha acabado la misi√≥n y el simulador env√≠a un mensaje a la GCS.
>>>>>>> FETCH_HEAD

\item\textbf{Carga de la misi√≥n en el simulador y en control}

\imgCentradaGrande{fig.4.3}{img/cargamision.eps}{Diagrama de secuencia de la carga de una misi√≥n en el simulador y el control.}

<<<<<<< HEAD
El mÈtodo de carga de la misiÛn est· basado en el protocolo MAVLINK. La GCS envÌ≠a el n˙mero de Waypoints de la misiÛn al simulador, que hace de puente de comunicaciÛn entre el control y la GCS, el control pide uno a uno los waypoint y la GCS se los va mandando. Cuando recibe el ˙ltimo waypoint el control envÌ≠a un mensaje de fin de carga de la misiÛn. En el protocolo de escritura de misiones en el UAV de MAVLINK cuando se envÌ≠a un mensaje que espera respuesta se inicia un timer si se consume ese tiempo sin respuesta se realiza otra vez la peticiÛn, esta acciÛn la realizar· el simulador.
=======
El m√©todo de carga de la misi√≥n est√° basado en el protocolo MAVLINK. La GCS env√≠a el n√∫mero de Waypoints de la misi√≥n al simulador, que hace de puente de comunicaci√≥n entre el control y la GCS, el control pide uno a uno los waypoint y la GCS se los va mandando. Cuando recibe el √∫ltimo waypoint el control env√≠a un mensaje de fin de carga de la misi√≥n. En el protocolo de escritura de misiones en el UAV de MAVLINK cuando se env√≠a un mensaje que espera respuesta se inicia un timer si se consume ese tiempo sin respuesta se realiza otra vez la petici√≥n, esta acci√≥n la realizar√° el simulador.
>>>>>>> FETCH_HEAD

\item\textbf{Inicio, parada y pausa de la simulaci√≥n}

\imgCentradaGrande{fig.4.4}{img/iniciopausaparada.eps}{Diagrama de secuencia con los comandos desde el puesto de instructor para iniciar, parar o pausar una ejecuci√≥n.}

<<<<<<< HEAD
El primer comando es enviado por el puesto de instructor al simulador para que Èste establezca las comunicaciones con cada uno de los mÛdulos para iniciar la ejecuciÛn.
El segundo comando muestra el flujo de informaciÛn al cargar el modelo desde el puesto de instructor. El instructor selecciona el modelo a cargar (tanto del entorno como del UAV), el simulador recibe ese modelo y lo carga en el mÛdulo ?Modelo? y se envÌ≠a un mensaje al simulador mostrando si ha ocurrido alg˙n error durante la carga.
El tercer comando muestra al alumno cargando (o creando) una misiÛn, la cual enviar· al simulador y Èste le devolver· un mensaje con el resultado de la carga.
El cuarto es la operaciÛn anterior pero realizada desde el puesto de instructor, carga la misiÛn en el simulador, la inicializa en la GCS y se envÌ≠a el correspondiente mensaje de errores.
Los dos ˙ltimos comandos muestran el funcionamiento de las Ûrdenes de parada y reanudaciÛn, las cuales se realizar·n sobre el mÛdulo de control.
=======
El primer comando es enviado por el puesto de instructor al simulador para que √©ste establezca las comunicaciones con cada uno de los m√≥dulos para iniciar la ejecuci√≥n.
El segundo comando muestra el flujo de informaci√≥n al cargar el modelo desde el puesto de instructor. El instructor selecciona el modelo a cargar (tanto del entorno como del UAV), el simulador recibe ese modelo y lo carga en el m√≥dulo ?Modelo? y se env√≠a un mensaje al simulador mostrando si ha ocurrido alg√∫n error durante la carga.
El tercer comando muestra al alumno cargando (o creando) una misi√≥n, la cual enviar√° al simulador y √©ste le devolver√° un mensaje con el resultado de la carga.
El cuarto es la operaci√≥n anterior pero realizada desde el puesto de instructor, carga la misi√≥n en el simulador, la inicializa en la GCS y se env√≠a el correspondiente mensaje de errores.
Los dos √∫ltimos comandos muestran el funcionamiento de las √≥rdenes de parada y reanudaci√≥n, las cuales se realizar√°n sobre el m√≥dulo de control.
>>>>>>> FETCH_HEAD

\item\textbf{Introducci√≥n de fallos en el modelo}

\imgCentradaGrande{fig.4.5}{img/introduccionfallos.eps}{Diagrama de secuencia para la introducci√≥n de fallos.}

<<<<<<< HEAD
El diagrama muestra el intercambio de datos cuando el instructor desea introducir errores en el sistema con el fin de comprobar la reacciÛn del alumno. Se selecciona el error a introducir en el puesto de instructor y se notifica al simulador, se procesa el error y se actualiza el modelo, el modelo realiza los cambios necesarios y para finalizar el simulador envÌ≠a el nuevo estado del modelo a la GCS.

En otra posible soluciÛn el control es el que detecta el fallo una vez se ha introducido en el modelo y genera el mensaje de error que envÌ≠a al simulador para que se lo comunique a la GCS.
=======
El diagrama muestra el intercambio de datos cuando el instructor desea introducir errores en el sistema con el fin de comprobar la reacci√≥n del alumno. Se selecciona el error a introducir en el puesto de instructor y se notifica al simulador, se procesa el error y se actualiza el modelo, el modelo realiza los cambios necesarios y para finalizar el simulador env√≠a el nuevo estado del modelo a la GCS.

En otra posible soluci√≥n el control es el que detecta el fallo una vez se ha introducido en el modelo y genera el mensaje de error que env√≠a al simulador para que se lo comunique a la GCS.
>>>>>>> FETCH_HEAD

\item\textbf{Cambios en la misi√≥n}

\imgCentradaGrande{fig.4.6}{img/cambiosmision.eps}{Diagrama de secuencia para hacer cambios en la misi√≥n.}

<<<<<<< HEAD
Estas transacciones explican el intercambio de informaciÛn en el caso en que se introdujeran cambios en la misiÛn durante el vuelo (introducciÛn de un nuevo Waypoint o cambios en el modelo de UAV como velocidad etc). La GCS introduce o modifica un Waypoint o modifica alg˙n par·metro en el UAV y se lo comunica al simulador que es donde est· almacenada la misiÛn, el simulador le envÌ≠a el nuevo Waypoint o par·metro al control cuando se lo pida.
=======
Estas transacciones explican el intercambio de informaci√≥n en el caso en que se introdujeran cambios en la misi√≥n durante el vuelo (introducci√≥n de un nuevo Waypoint o cambios en el modelo de UAV como velocidad etc). La GCS introduce o modifica un Waypoint o modifica alg√∫n par√°metro en el UAV y se lo comunica al simulador que es donde est√° almacenada la misi√≥n, el simulador le env√≠a el nuevo Waypoint o par√°metro al control cuando se lo pida.
>>>>>>> FETCH_HEAD

\end{itemize}

\subsection{Diagrama de comunicaciones}

Una vez tenemos las acciones que va seguir nuestro programa podemos hacer un diagrama de c√≥mo se van a comunicar los distintos m√≥dulos y de esta manera simplificar la informaci√≥n que obtuvimos anteriormente.

\imgCentradaGrande{fig.4.7}{img/relacionescomunicacion.eps}{Diagrama de las relaciones a la hora de comunicarse de los distintos m√≥dulos.}

<<<<<<< HEAD
De esta forma se puede observar de un vistazo que el simulador ser· el centro de las comunicaciones del sistema, el control se comunicar· con el simulador para recibir los comandos cuya interpretaciÛn pasar· al modelo y devolver· al simulador el nuevo estado de Èste. El puesto de instructor enviar· las acciones al simulador que ser· el encargado de redirigirlas hacia el puesto del alumno, el control o de hacer la comunicaciÛn con la base de datos. El puesto del alumno se conectar· al simulador y desde ahÌ≠ manejar· el control y el modelo. El puesto de instructor podr· comunicarse con el puesto del alumno para monitorizar las acciones de Èste y poder evaluarle luego.
=======
De esta forma se puede observar de un vistazo que el simulador ser√° el centro de las comunicaciones del sistema, el control se comunicar√° con el simulador para recibir los comandos cuya interpretaci√≥n pasar√° al modelo y devolver√° al simulador el nuevo estado de √©ste. El puesto de instructor enviar√° las acciones al simulador que ser√° el encargado de redirigirlas hacia el puesto del alumno, el control o de hacer la comunicaci√≥n con la base de datos. El puesto del alumno se conectar√° al simulador y desde ah√≠ manejar√° el control y el modelo. El puesto de instructor podr√° comunicarse con el puesto del alumno para monitorizar las acciones de √©ste y poder evaluarle luego.
>>>>>>> FETCH_HEAD

\newpage
\subsection{Entradas y salidas de los m√≥dulos}

Una vez sabemos qu√© datos se van a enviar entre los diferentes m√≥dulos podemos agrupar cada transacci√≥n seg√∫n sean entradas o salidas de cada uno de los m√≥dulos de la siguiente manera:


\begin{enumerate}
\item Puesto de instructor
\\
\textbf{Salidas}

\begin{itemize}

\item Orden de inicio del sistema (tipo Command) $\rightarrow$ Simulador
\item Identificador del modelo (tipo Command) $\rightarrow$ Simulador
\item Misi√≥n (tipo Mission) $\rightarrow$ Simulador
\item Orden de parada (tipo Command) $\rightarrow$ Simulador
\item Orden de reanudaci√≥n (tipo Command) $\rightarrow$ Simulador
\item Fallo en el sistema (tipo Error) $\rightarrow$ Simulador

\end{itemize}

\item Simulador
\\
\textbf{Entradas}

\begin{itemize}

\item Orden de inicio (tipo Command) $\leftarrow$ Puesto del instructor
\item Identificador del modelo (tipo Command) $\leftarrow$ Simulador
\item Confirmaci√≥n de carga (tipo Error) $\leftarrow$ Modelo
\item Misi√≥n (creadas en la GCS) (tipo Mission) $\leftarrow$ GCS
\item Identificador de la misi√≥n (tipo Mission) $\leftarrow$ Puesto del instructor
\item Confirmaci√≥n de recepci√≥n de misi√≥n (cuando el instructor carga una misi√≥n en el simulador la GCS debe darse cuenta) (tipo Error) $\leftarrow$ GCS
\item Orden de parada (tipo Command) $\leftarrow$ Puesto del instructor
\item Orden de reanudaci√≥n (tipo Command) $\leftarrow$ Puesto del instructor
\item Orden de inicio de misi√≥n (tipo Command) $\leftarrow$ GCS
\item Nuevo estado del modelo (Al inicio, tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Modelo
\item Nuevo estado del modelo (En el bucle, tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Modelo
\item Fallo en el sistema (tipo Error) $\leftarrow$ Puesto de instructor
\item Nuevo estado del modelo (despu√©s del error, tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Modelo
\item Correcciones del alumno (despu√©s del error, tipo Command) $\leftarrow$ GCS


\end{itemize}

\textbf{Salidas}

\begin{itemize}
\item Carga modelo (tipos PosWgs , Rotation y VelEarth) $\rightarrow$ Modelo
\item Dato de confirmaci√≥n (tipo Error) $\rightarrow$ GCS
\item Misi√≥n (tipo Mission) $\rightarrow$ GCS
\item Orden de parada (tipo Command) $\rightarrow$ Control
\item Orden de reanudaci√≥n (tipo Command) $\rightarrow$ Control
\item Estado inicial del UAV (tipos PosWgs, Rotation y VelEarth) $\rightarrow$ Modelo
\item Waypoint (tipo FlightPlan) $\rightarrow$ Control
\item Introducci√≥n de error (tipo Command) $\rightarrow$ Modelo
\item Aviso de error (tipo ?Error) $\rightarrow$ GCS

\end{itemize}

\item GCS
\\
\textbf{Entradas}

\begin{itemize}

\item Orden de inicio (tipo Command) $\leftarrow$ Simulador
\item Confirmaci√≥n de carga de la misi√≥n (tipo Error) $\leftarrow$ Simulador
\item Misi√≥n cargada por el instructor en el simulador (tipo Mission) $\leftarrow$ Simulador
\item Estado del modelo (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Simulador
\item Aviso finalizaci√≥n (tipo Error) $\leftarrow$ Simulador
\item Aviso de error (tipo Error) $\leftarrow$ Simulador

\end{itemize}

\textbf{Salidas}

\begin{itemize}

\item Misi√≥n (tipo Mission) $\rightarrow$ Simulador
\item Confirmaci√≥n de recepci√≥n de misi√≥n (tipo Error) $\rightarrow$ Simulador
\item Orden de inicio de misi√≥n (tipo Command) $\rightarrow$ Simulador
\item Reacci√≥n ante un problema (tipo Command) $\rightarrow$ Simulador

\end{itemize}

\item Modelo
\\
\textbf{Entradas}

\begin{itemize}

\item Orden de inicio (tipo Command) $\leftarrow$ Simulador
\item Tipo de dato modelo (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Simulador
\item Estado inicial del UAV (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Simulador
\item Consulta estado del modelo (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Control
\item Actualiza el modelo (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Control
\item Actualiza modelo con el error (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Modelo

\end{itemize}

\textbf{Salidas}

\begin{itemize}

\item Confirmaci√≥n de carga (tipo Error) $\rightarrow$ Simulador
\item Comunica el estado inicial (tipos PosWgs , Rotation y VelEarth) $\rightarrow$ Simulador
\item Publica estado actual (tipos PosWgs , Rotation y VelEarth) $\rightarrow$ Control
\item Comunica nuevo estado del modelo (tipos PosWgs , Rotation y VelEarth) $\rightarrow$ Simulador
\item Actualiza el nuevo estado (despu√©s de error, tipos PosWgs , Rotation y VelEarth) $\rightarrow$ Simulador

\end{itemize}

\item Control
\\
\textbf{Entradas}

\begin{itemize}

\item Orden de inicio (tipo Command) $\leftarrow$ Simulador
\item Orden de parada (tipo Command) $\leftarrow$ Simulador
\item Orden de reanudaci√≥n (tipo Command) $\leftarrow$ Simulador
\item Waypoint (tipo FlightPlan) $\leftarrow$ Simulador
\item Estado actual del modelo (tipos PosWgs , Rotation y VelEarth) $\leftarrow$ Modelo

\end{itemize}

\textbf{Salidas}

\begin{itemize}

\item Consulta estado del modelo (tipo Command) $\rightarrow$ Modelo
\item Actualiza el modelo (tipos PosWgs , Rotation y VelEarth) $\rightarrow$ Modelo

\end{itemize}

\end{enumerate}

\subsection{Definici√≥n de interfaces}

A la hora de empezar a programar nuestra aplicaci√≥n necesitamos conocer qu√© clases vamos a tener y qu√© informaci√≥n guardar√° cada una, ya que hemos realizado el ejercicio de anotar todas las comunicaciones de datos que se realizar√°n entre nuestros m√≥dulos y de las entradas y salidas de cada uno de ellos ya sabemos qu√© datos manejar√° cada uno, por tanto, definiremos cu√°les son los datos que tenemos que modelar con clases.

\imgCentradaGrande{fig.4.8}{img/definicioninterfaces.eps}{Definici√≥n de interfaces.}

\newpage
\subsection{Diagrama de burndown}

Para el primer sprint se esperaba realizar el documento de an√°lisis inicial con un valor de dificultad de dos puntos y la definici√≥n de interfaces con otros dos puntos. Al haber realizado las dos acciones finalizamos el sprint con un total de 4 puntos en la evoluci√≥n de velocidad de la iteraci√≥n que plasmaremos en el siguiente diagrama de velocidad.

\imgCentradaGrande{fig.4.9}{img/diagvelocidad1.eps}{Diagrama de velocidad para el primer sprint.}

\newpage
\subsection{Diagrama de evoluci√≥n}

El diagrama de evoluci√≥n nos muestra las historias de usuario que hemos realizado frente a las totales del proyecto, lo que nos da una idea aproximada de lo que nos queda para finalizar.

\imgCentradaGrande{fig.4.10}{img/diagevolucion1.eps}{Diagrama de evoluci√≥n para el primer sprint.}


\newpage
\section{Sprint 2: Creaci√≥n de la capa de comunicaci√≥n}

<<<<<<< HEAD
\lettrine{E}{ste} sprint lo dividiremos en tres partes, en un principio explicaremos los pasos necesarios para poner a punto las herramientas que usaremos durante el desarrollo del proyecto, entornos de programaciÛn, librerÌ≠as necesarias, etcÈtera. En la segunda parte explicaremos cÛmo se implementÛ la capa de comunicaciÛn de los distintos mÛdulos para realizar el intercambio de datos entre ellos, parte muy importante en el proyecto, tambiÈn explicaremos como se usa ANIMO DDS. Para terminar realizaremos una primera integraciÛn del simulador con un modelo simple que acepta una trayectoria tomando un camino rectilÌ≠neo de un punto a otro de la misiÛn.

\subsection{Set up del entorno de desarrollo}

\lettrine{E}{l} primer paso a la hora de iniciar el desarrollo del proyecto debe ser el de disponer de un entorno de desarrollo con todas las herramientas necesarias a la hora de llevar a cabo la programaciÛn de nuestro sistema, para ello haremos un recuento de las tecnologÌ≠as que vamos a usar e instalaremos las correspondientes herramientas que faciliten el uso de Èstas tecnologÌ≠as.

\subsubsection{Entorno de desarrollo C++}

Ya que la mayor parte del proyecto va a ser desarrollado en el lenguaje de programaciÛn C++ debemos disponer de un entorno de programaciÛn adecuado. Decidimos hacer uso de la herramienta de generaciÛn de proyectos en C++ Cmake, la cual nos resultar· muy ˙til a la hora de crear varios proyectos que tengan las mismas caracterÌ≠sticas y usen las mismas tecnologÌ≠as. Al decidir hacer uso de CMake nos decantamos por trabajar con el entorno de desarrollo integrado o \emph{IDE} (Integrated Development Enviroment) QtCreator ya que Èste tenÌ≠a una mejor integraciÛn con CMake sobre la otra opciÛn que tuvimos que era usar el entorno Eclipse adaptado a C++ que, a parte de ser m·s lento al ejecutarse en la m·quina virtual de Java, disponÌ≠a de herramientas ˙tiles a la hora de trabajar con CMake y con las librerÌ≠as de C++ Qt de las que haremos uso m·s adelante.
=======
\lettrine{E}{ste} sprint lo dividiremos en tres partes, en un principio explicaremos los pasos necesarios para poner a punto las herramientas que usaremos durante el desarrollo del proyecto, entornos de programaci√≥n, librer√≠as necesarias, etc√©tera. En la segunda parte explicaremos c√≥mo se implement√≥ la capa de comunicaci√≥n de los distintos m√≥dulos para realizar el intercambio de datos entre ellos, parte muy importante en el proyecto, tambi√©n explicaremos como se usa ANIMO DDS. Para terminar realizaremos una primera integraci√≥n del simulador con un modelo simple que acepta una trayectoria tomando un camino rectil√≠neo de un punto a otro de la misi√≥n.

\subsection{Set up del entorno de desarrollo}

\lettrine{E}{l} primer paso a la hora de iniciar el desarrollo del proyecto debe ser el de disponer de un entorno de desarrollo con todas las herramientas necesarias a la hora de llevar a cabo la programaci√≥n de nuestro sistema, para ello haremos un recuento de las tecnolog√≠as que vamos a usar e instalaremos las correspondientes herramientas que faciliten el uso de √©stas tecnolog√≠as.

\subsubsection{Entorno de desarrollo C++}

Ya que la mayor parte del proyecto va a ser desarrollado en el lenguaje de programaci√≥n C++ debemos disponer de un entorno de programaci√≥n adecuado. Decidimos hacer uso de la herramienta de generaci√≥n de proyectos en C++ Cmake, la cual nos resultar√° muy √∫til a la hora de crear varios proyectos que tengan las mismas caracter√≠sticas y usen las mismas tecnolog√≠as. Al decidir hacer uso de CMake nos decantamos por trabajar con el entorno de desarrollo integrado o \emph{IDE} (Integrated Development Enviroment) QtCreator ya que √©ste ten√≠a una mejor integraci√≥n con CMake sobre la otra opci√≥n que tuvimos que era usar el entorno Eclipse adaptado a C++ que, a parte de ser m√°s lento al ejecutarse en la m√°quina virtual de Java, dispon√≠a de herramientas √∫tiles a la hora de trabajar con CMake y con las librer√≠as de C++ Qt de las que haremos uso m√°s adelante.
>>>>>>> FETCH_HEAD

Tanto la √∫ltima versi√≥n de Qt como el entorno de desarrollo QtCreator lo podemos encontrar en la p√°gina del proyecto \emph{http://qt-project.org}.

Una vez disponemos de este entorno de desarrollo ya podemos crear nuestro primer proyecto con C++.

\subsubsection{Creaci√≥n del repositorio y la estructura de carpetas}

<<<<<<< HEAD
Ahora que tenemos el proyecto creado nos creamos un repositorio, usamos bitbucket ya que es el m·s usado por el departamento de SimulaciÛn y Software de Catec. Mediante la herramienta TortoiseHG podremos manejar nuestro repositorio desde el escritorio. La metodologÌ≠a de trabajo ser· la siguiente: nos crearemos un \emph{fork} del repositorio principal, subiremos todas las modificaciones que realicemos a ese fork, y cada vez que tengamos una versiÛn estable del sistema haremos una peticiÛn de uniÛn con el repositorio principal o \emph{pull request}. Para la estructura de carpetas se definiÛ que la ruta principal tendrÌ≠a dos carpetas, una destinada al cÛdigo y otra a la documentaciÛn, dentro de la carpeta cÛdigo la estructura serÌ≠a crear una carpeta por cada mÛdulo o proyecto que se necesite en el sistema.
=======
Ahora que tenemos el proyecto creado nos creamos un repositorio, usamos bitbucket ya que es el m√°s usado por el departamento de Simulaci√≥n y Software de Catec. Mediante la herramienta TortoiseHG podremos manejar nuestro repositorio desde el escritorio. La metodolog√≠a de trabajo ser√° la siguiente: nos crearemos un \emph{fork} del repositorio principal, subiremos todas las modificaciones que realicemos a ese fork, y cada vez que tengamos una versi√≥n estable del sistema haremos una petici√≥n de uni√≥n con el repositorio principal o \emph{pull request}. Para la estructura de carpetas se defini√≥ que la ruta principal tendr√≠a dos carpetas, una destinada al c√≥digo y otra a la documentaci√≥n, dentro de la carpeta c√≥digo la estructura ser√≠a crear una carpeta por cada m√≥dulo o proyecto que se necesite en el sistema.
>>>>>>> FETCH_HEAD

\subsubsection{Instalaci√≥n ANIMO DDS}

<<<<<<< HEAD
El primer paso que tomamos una vez pudimos empezar a generar nuestro cÛdigo en C++ fue el de instalarnos las librerÌ≠as de ANIMO proporcionadas por Catec e integrarlas en un proyecto de prueba que consistÌ≠a en dos aplicaciones, una que permitÌ≠a tomar datos de un joystick conectado por USB al ordenador, enviar Èstos datos por ANIMO y recibirlos en otra aplicaciÛn que dibujaba un punto sobre una ventana representando el movimiento del joystick.

El primer paso es descargarse las librerÌ≠as de RTI DDS, las podemos encontrar en la siguiente url \emph{http://www.rti.com/downloads/connext-files.html/}, una vez tenemos el archivo de instalaciÛn debemos darle permisos de ejecuciÛn y ejecutarlo, aceptar las condiciones de uso y seleccionar el directorio de instalaciÛn. Antes de ejecutarlo debemos revisar algunas dependencias que tienen estas librerÌ≠as, debemos tener instaladas en nuestro sistema las librerÌ≠as \emph{libtiff3} y \emph{libjpeg62}. Una vez termine la instalaciÛn de RTI DDS debemos de hacernos con un archivo de licencia, en nuestro caso fue provisto por Catec, y lo copiamos en la carpeta de instalaciÛn de RTI.
=======
El primer paso que tomamos una vez pudimos empezar a generar nuestro c√≥digo en C++ fue el de instalarnos las librer√≠as de ANIMO proporcionadas por Catec e integrarlas en un proyecto de prueba que consist√≠a en dos aplicaciones, una que permit√≠a tomar datos de un joystick conectado por USB al ordenador, enviar √©stos datos por ANIMO y recibirlos en otra aplicaci√≥n que dibujaba un punto sobre una ventana representando el movimiento del joystick.

El primer paso es descargarse las librer√≠as de RTI DDS, las podemos encontrar en la siguiente url \emph{http://www.rti.com/downloads/connext-files.html/}, una vez tenemos el archivo de instalaci√≥n debemos darle permisos de ejecuci√≥n y ejecutarlo, aceptar las condiciones de uso y seleccionar el directorio de instalaci√≥n. Antes de ejecutarlo debemos revisar algunas dependencias que tienen estas librer√≠as, debemos tener instaladas en nuestro sistema las librer√≠as \emph{libtiff3} y \emph{libjpeg62}. Una vez termine la instalaci√≥n de RTI DDS debemos de hacernos con un archivo de licencia, en nuestro caso fue provisto por Catec, y lo copiamos en la carpeta de instalaci√≥n de RTI.
>>>>>>> FETCH_HEAD

Lo siguiente es instalar el paquete debian creado por el equipo de desarrollo de ANIMO DDS de Catec, el cual se instalar√° con el correspondiente comando desde nuestra terminal de Ubuntu.

<<<<<<< HEAD
Una vez tenemos todas las librerÌ≠as instaladas correctamente podemos hacer la implementaciÛn de nuestra primera prueba de comunicaciones mediante ANIMO DDS.

\textbf{Uso de las librerÌ≠as de ANIMO DDS: }El uso es bastante sencillo, sÛlo basta con inicializar ANIMO obteniendo una instancia del framework a partir de un archivo de configuraciÛn en el que se indica el dominio o "canal" por el que se van a transmitir los datos, las calidades de servicios, la ruta del fichero donde se encuentran la definiciÛn de calidades, la ruta del log y el identificador del log. A partir de este objeto crearemos dos instancias de los llamados "Acces Points" que son los objetos que usaremos para publicar y subscribirnos. La din·mica de funcionamiento del patrÛn publicador subscriptor es muy sencilla, una aplicaciÛn publica un dato bajo un tÛpico y Èste dato es recibido por todas las aplicaciones que estÈn subscritas a ese dato con ese tÛpico, asÌ≠ mediante el tÛpico podemos decidir quÈ datos vanos a recibir y cuales no, en nuestra aplicaciÛn asignaremos como tÛpico el identificador correspondiente al programa que ha enviado ese dato, por tanto el resto de mÛdulos se subscribir·n al identificador correspondiente a los mÛdulos que envÌ≠an informaciÛn que Èl necesita. Entonces nos crearemos un objeto AccessPointForSending y otro objeto AccessPointForReceiving.
=======
Una vez tenemos todas las librer√≠as instaladas correctamente podemos hacer la implementaci√≥n de nuestra primera prueba de comunicaciones mediante ANIMO DDS.

\textbf{Uso de las librer√≠as de ANIMO DDS: }El uso es bastante sencillo, s√≥lo basta con inicializar ANIMO obteniendo una instancia del framework a partir de un archivo de configuraci√≥n en el que se indica el dominio o "canal" por el que se van a transmitir los datos, las calidades de servicios, la ruta del fichero donde se encuentran la definici√≥n de calidades, la ruta del log y el identificador del log. A partir de este objeto crearemos dos instancias de los llamados "Acces Points" que son los objetos que usaremos para publicar y subscribirnos. La din√°mica de funcionamiento del patr√≥n publicador subscriptor es muy sencilla, una aplicaci√≥n publica un dato bajo un t√≥pico y √©ste dato es recibido por todas las aplicaciones que est√©n subscritas a ese dato con ese t√≥pico, as√≠ mediante el t√≥pico podemos decidir qu√© datos vanos a recibir y cuales no, en nuestra aplicaci√≥n asignaremos como t√≥pico el identificador correspondiente al programa que ha enviado ese dato, por tanto el resto de m√≥dulos se subscribir√°n al identificador correspondiente a los m√≥dulos que env√≠an informaci√≥n que √©l necesita. Entonces nos crearemos un objeto AccessPointForSending y otro objeto AccessPointForReceiving.
>>>>>>> FETCH_HEAD

A la hora de enviar un dato lo √∫nico que necesitamos hacer es tomar la instancia de nuestro AccessPointForSending y llamar a su m√©todo sendInterfaceData(data) donde "data" es cualquier objeto que herede de la clase "I\_Data" de ANIMO DDS. La recepci√≥n del dato se har√° mediante listeners, un listener es un objeto que tendr√° un m√©todo process el cu√°l ser√° llamado cuando haya llegado un dato que est√© destinado a ese listener proporcion√°ndole el dato. Para que ese listener reciba ese dato debemos registrarlo mediante el framework de ANIMO, m√°s concretamente haciendo uso del AccessPointForReceiving el cual tiene dos m√©todos, uno llamado registerInterface(Type, listener) el cual recibe un enumerado con el tipo de dato que se va a recibir en ese listener y un listener que debe heredar del tipo de ANIMO I\_DataListener el cual posee un m√©todo process que es el que recibir√° el dato.

<<<<<<< HEAD
Los tipos que pueden ser enviados mediante ANIMO debemos definirlos antes y, haciendo uso de las herramientas de generaciÛn de cÛdigo de ANIMO DDS, recoger sus propiedades dentro de un archivo de configuraciÛn a partir del cual ANIMO autom·ticamente generar· las clases necesarias para el envÌ≠o de ese dato por DDS y har· las modificaciones pertinentes en el framework, incluido el aÒadir al enumerado de tipos que se pueden enviar por ANIMO el nuevo dato, enumerado que necesitaremos en el AccessPointForReceiving. DespuÈs de esto debemos generar los paquetes debÌ≠an de nuevo mediante un script incluido en el proyecto ANIMO DDS y volver a instalarlos.
=======
Los tipos que pueden ser enviados mediante ANIMO debemos definirlos antes y, haciendo uso de las herramientas de generaci√≥n de c√≥digo de ANIMO DDS, recoger sus propiedades dentro de un archivo de configuraci√≥n a partir del cual ANIMO autom√°ticamente generar√° las clases necesarias para el env√≠o de ese dato por DDS y har√° las modificaciones pertinentes en el framework, incluido el a√±adir al enumerado de tipos que se pueden enviar por ANIMO el nuevo dato, enumerado que necesitaremos en el AccessPointForReceiving. Despu√©s de esto debemos generar los paquetes deb√≠an de nuevo mediante un script incluido en el proyecto ANIMO DDS y volver a instalarlos.
>>>>>>> FETCH_HEAD

El siguiente paso es indicarle AccessPointForReceiving que va a recibir datos de un t√≥pico para empezar a escuchar, por tanto se llamar√° a su m√©todo starDevice(Type, Topic) donde "Type" volver√° a ser el enumerado con valor correspondiente al tipo de dato que vamos a recibir y "Topic" ser√° el t√≥pico bajo el que se va a enviar ese dato.

<<<<<<< HEAD
AsÌ≠ pues en el process del listener se define quÈ es lo que se va a hacer con ese dato. En nuestro caso la acciÛn era modificar la posiciÛn de un punto en nuestra ventana seg˙n el valor de movimiento que nos hubiera mandado el joystick.
=======
As√≠ pues en el process del listener se define qu√© es lo que se va a hacer con ese dato. En nuestro caso la acci√≥n era modificar la posici√≥n de un punto en nuestra ventana seg√∫n el valor de movimiento que nos hubiera mandado el joystick.
>>>>>>> FETCH_HEAD

\subsection{Implementaci√≥n de la capa de comunicaci√≥n}

<<<<<<< HEAD
\lettrine{D}{espuÈs} de la implementaciÛn del proyecto de prueba de comunicaciones con ANIMO se definiÛ una estructura a seguir para el tratamiento de los datos. Seg˙n Èsta estructura se definirÌ≠a una clase contenedor para todos los elementos referentes a las comunicaciones y un tipo de listener especial para nuestro proyecto. A continuaciÛn explicaremos cÛmo est·n formados estos elementos.

\subsubsection{Contenedor}

El contenedor es la clase principal de nuestras comunicaciones mediante ANIMO, Èsta estar· encargada de establecer los elementos necesarios para iniciar las comunicaciones (creaciÛn de los Access Points, registros, etcÈtera...), crear los listeners que nos har·n falta, almacenarlos y proveer al resto del proyecto de los mÈtodos necesarios tanto para realizar un envÌ≠o de un dato mediante DDS como para acceder a los datos que nos han llegado.

El constructor del container tiene como par·metros de entrada el archivo de configuraciÛn necesario para la inicializaciÛn de ANIMO y el dominio, ambos archivos los incluiremos en el archivo de configuraciÛn general de la aplicaciÛn que tendr· los par·metros caracterÌ≠sticos de cada mÛdulo a parte de las configuraciones necesarias para las comunicaciones a travÈs de ANIMO. TambiÈn ser· encargado de inicializar el framework de ANIMO y de crear los Access Points, tanto el de subscriptor como el de publicador. Y por ˙ltimo inicializar· los listeners necesarios para nuestro proyecto.
=======
\lettrine{D}{espu√©s} de la implementaci√≥n del proyecto de prueba de comunicaciones con ANIMO se defini√≥ una estructura a seguir para el tratamiento de los datos. Seg√∫n √©sta estructura se definir√≠a una clase contenedor para todos los elementos referentes a las comunicaciones y un tipo de listener especial para nuestro proyecto. A continuaci√≥n explicaremos c√≥mo est√°n formados estos elementos.

\subsubsection{Contenedor}

El contenedor es la clase principal de nuestras comunicaciones mediante ANIMO, √©sta estar√° encargada de establecer los elementos necesarios para iniciar las comunicaciones (creaci√≥n de los Access Points, registros, etc√©tera...), crear los listeners que nos har√°n falta, almacenarlos y proveer al resto del proyecto de los m√©todos necesarios tanto para realizar un env√≠o de un dato mediante DDS como para acceder a los datos que nos han llegado.

El constructor del container tiene como par√°metros de entrada el archivo de configuraci√≥n necesario para la inicializaci√≥n de ANIMO y el dominio, ambos archivos los incluiremos en el archivo de configuraci√≥n general de la aplicaci√≥n que tendr√° los par√°metros caracter√≠sticos de cada m√≥dulo a parte de las configuraciones necesarias para las comunicaciones a trav√©s de ANIMO. Tambi√©n ser√° encargado de inicializar el framework de ANIMO y de crear los Access Points, tanto el de subscriptor como el de publicador. Y por √∫ltimo inicializar√° los listeners necesarios para nuestro proyecto.
>>>>>>> FETCH_HEAD

Uno de los m√©todos necesarios es el de subscribe(), el cual a partir de la lista de listeners que hemos creado y el t√≥pico identificador para el m√≥dulo que estamos implementando subscribir√° cada uno de los listeners para poder iniciar la recepci√≥n de datos.

<<<<<<< HEAD
TambiÈn dispondr· de un mÈtodo de envÌ≠o que recibir· un dato de ANIMO a publicar y har· la llamada al AccessPointForSending que realizar· el envÌ≠o.
=======
Tambi√©n dispondr√° de un m√©todo de env√≠o que recibir√° un dato de ANIMO a publicar y har√° la llamada al AccessPointForSending que realizar√° el env√≠o.
>>>>>>> FETCH_HEAD

Por √∫ltimo, esta clase dispondr√° de una serie de m√©todos observadores que devolver√°n cada uno de los datos a los que nos hemos suscrito.

\subsubsection{Listeners}

<<<<<<< HEAD
Debido a que queremos mantener un control sobre el flujo de datos entre los sistemas de que disponemos y sobre la ejecuciÛn de la simulaciÛn tenemos que marcar unas pautas que definan quÈ se va a hacer con los mensajes cuando nos llegan. Una opciÛn consiste en hacer en el process del listener la llamada a la clase que vaya a usar ese dato o un controlador de datos que lo redirija al objeto en el que va a ser usado, esto podrÌ≠a darnos problemas y complicar mucho el flujo de ejecuciÛn elevando el riesgo de que se entre en condiciones de carrera, etcÈtera.
=======
Debido a que queremos mantener un control sobre el flujo de datos entre los sistemas de que disponemos y sobre la ejecuci√≥n de la simulaci√≥n tenemos que marcar unas pautas que definan qu√© se va a hacer con los mensajes cuando nos llegan. Una opci√≥n consiste en hacer en el process del listener la llamada a la clase que vaya a usar ese dato o un controlador de datos que lo redirija al objeto en el que va a ser usado, esto podr√≠a darnos problemas y complicar mucho el flujo de ejecuci√≥n elevando el riesgo de que se entre en condiciones de carrera, etc√©tera.
>>>>>>> FETCH_HEAD

La segunda opci√≥n, por la que finalmente optamos fue la de almacenar dentro del listener los datos nuevos cuando llegan, por lo que los listeners tienen un atributo del tipo del dato que est√°n esperando recibir, el cual se actualiza en el momento en que se comprueba en el process que el dato es el que queremos, almacen√°ndose en ese atributo.

El listener nos permite la visualizaci√≥n de ese dato almacenado mediante un m√©todo get que devuelve el tipo correspondiente al listener.

<<<<<<< HEAD
AsÌ≠ cuando durante la ejecuciÛn de nuestra aplicaciÛn necesitemos alguno de los datos, solo tenemos que realizar una espera activa comprobando si tenemos alg˙n dato nuevo en el listener correspondiente al objeto que necesitamos, al que podemos acceder mediante los mÈtodos provistos en la clase contenedor de comunicaciones.
=======
As√≠ cuando durante la ejecuci√≥n de nuestra aplicaci√≥n necesitemos alguno de los datos, solo tenemos que realizar una espera activa comprobando si tenemos alg√∫n dato nuevo en el listener correspondiente al objeto que necesitamos, al que podemos acceder mediante los m√©todos provistos en la clase contenedor de comunicaciones.
>>>>>>> FETCH_HEAD

\subsection{Implementaci√≥n del modelo simple}

<<<<<<< HEAD
\lettrine{D}{bebemos} trabajar haciendo uso de un modelo que simule el comportamiento de una aeronave no tripulada, la estructura de Èsta aeronave simulada ser· por un lado un control que har· de autopiloto, y por otro lado un modelo en Matlab Simulink que ser· el que haga las veces de sensores y respuestas del aviÛn. Para familiarizarnos con el comportamiento y uso de Èstas tecnologÌ≠as vamos a implementar un llamado \emph{modelo bicicleta} o modelo simple.
=======
\lettrine{D}{bebemos} trabajar haciendo uso de un modelo que simule el comportamiento de una aeronave no tripulada, la estructura de √©sta aeronave simulada ser√° por un lado un control que har√° de autopiloto, y por otro lado un modelo en Matlab Simulink que ser√° el que haga las veces de sensores y respuestas del avi√≥n. Para familiarizarnos con el comportamiento y uso de √©stas tecnolog√≠as vamos a implementar un llamado \emph{modelo bicicleta} o modelo simple.
>>>>>>> FETCH_HEAD

\subsubsection{Primera aproximaci√≥n}

Simulink nos autogenera un c√≥digo en C++ con el modelo y una serie de m√©todos para introducir los par√°metros de entrada del modelo y un m√©todo para ejecutar un paso de simulaci√≥n. La entra de este modelo simple es el \emph{waypoint} o coordenada al que debe dirigirse y como salida ir√° mostrando su posici√≥n.

Para √©sta prueba se realiz√≥ un nuevo proyecto que creaba una envoltura al c√≥digo generado por Simulink, de manera que se le proporcionaba una serie de waypoints y un m√≥dulo secuenciador era el encargado de modificar el waypoint objetivo al modelo, ejecutar los pasos de simulaci√≥n y enviarle el siguiente waypoint cuando hubiera llegado al anterior.

<<<<<<< HEAD
Una vez tuvimos Èste sistema funcionando ampliados su funcionamiento para poder usar Ûrdenes externas a travÈs de ·nimo, de forma que el control de la ejecuciÛn del paso de simulaciÛn fuera activada exteriormente, asÌ≠ como la informaciÛn de la misiÛn que debÌ≠a realizar.
=======
Una vez tuvimos √©ste sistema funcionando ampliados su funcionamiento para poder usar √≥rdenes externas a trav√©s de √°nimo, de forma que el control de la ejecuci√≥n del paso de simulaci√≥n fuera activada exteriormente, as√≠ como la informaci√≥n de la misi√≥n que deb√≠a realizar.
>>>>>>> FETCH_HEAD

\subsubsection{Cambios para implementaci√≥n en el sistema}

La envoltura que se realiz√≥ fue una clase llamada AircraftContainer la cual creaba e inicializaba las clases autogeneradas por Matlab Simulink y se encargaba de almacenar los objetos necesarios para el manejo de √©ste modelo, como por ejemplo el contenedor de comunicaciones, el controlador de ejecuci√≥n, la clase encargada de secuencia los waypoints al modelo, el controlador de la posici√≥n y la encargada del manejo de la carga de misi√≥n en nuestro proyecto.

Tiene un m√©todo para ejecutar el step del modelo, de forma que primero comprueba si se ha enviado una odre de ejecuci√≥n desde fuera ya que la ejecuci√≥n ser√° controlada desde otro m√≥dulo. Cuando nos llega una orden de ejecuci√≥n del paso de simulaci√≥n, llamamos a la ejecuci√≥n del controlador de posici√≥n que se encargar√° de modificar el estado de la aeronave y de llamar al guiado que en √∫ltima instancia ser√° el que compruebe si hemos llegado al waypoint y luego, el controlador de posici√≥n llamar√° a la ejecuci√≥n del modelo.

Otro m√©todo llamado checkMissionRequest comprueba que haya una petici√≥n de inicio de carga de misi√≥n, el cu√°l comprobar√° que no se haya terminado de cargar una misi√≥n en curso, y, si se dan las condiciones, inicializar el control de posici√≥n.

Por √∫ltimo, checkMissionStartCommand comprueba si ha llegado un comando de inicio de misi√≥n, en cuyo caso devolver√° verdadero.

La carga de misi√≥n se realizar√° siguiendo el proceso de carga definido por el protocolo Mavlink y ser√° gestionado por la clase MissionLoader, la cual ser√° ejecutada por el contenedor de la aeronave.

<<<<<<< HEAD
AsÌ≠ pues, a cada paso de ejecuciÛn, si no hay una misiÛn cargada y llega una solicitud de carga de misiÛn se inicia el proceso de peticiÛn de waypoints, una vez est· cargada la misiÛn se espera a que se envÌ≠a una seÒal de inicio de misiÛn, cuando se cumplen estas dos premisas se comienza la ejecuciÛn del modelo cuyos datos recibe mediante el mÛdulo de guiado.
=======
As√≠ pues, a cada paso de ejecuci√≥n, si no hay una misi√≥n cargada y llega una solicitud de carga de misi√≥n se inicia el proceso de petici√≥n de waypoints, una vez est√° cargada la misi√≥n se espera a que se env√≠a una se√±al de inicio de misi√≥n, cuando se cumplen estas dos premisas se comienza la ejecuci√≥n del modelo cuyos datos recibe mediante el m√≥dulo de guiado.
>>>>>>> FETCH_HEAD

El siguiente paso que realizaremos ser√° el de crear la primera versi√≥n del m√≥dulo central de control de la simulaci√≥n, el cu√°l enviar√° el paso de simulaci√≥n y mediante un programa de prueba que haremos podr√° validar el funcionamiento de la implementaci√≥n del modelo simple.

\subsection{Pruebas}

Para este sprint se implementa una baterÌ≠a de pruebas unitarias que se deben cumplir durante el resto del desarrollo y est·n orientadas a la comprobaciÛn del funcionamiento de la capa de comunicaciones. En primera instancia se realizan pruebas unitarias sobre las clases creadas de forma que se definan unos test de aceptaciÛn para cada una de ellas.

\textbf{CommunicationContainer: }Al tratarse de un contenedor no podemos hacer pruebas unitarias sobre la creaciÛn de objetos, pero sÌ≠ que podemos eralizarlas sobre la funcionalidad adicional que aportan lso mÈtodos de acceso y de tratamiento de las comunicaciones como son los observadores de los datos guardados en los listeners. Para el getData comprobamos que el realizar la llamada recoja el dato que le debuelve el listener que hemos mockeado para quitar la dependencia de esta clase. Al probar los mÈtodos de subscripciÛn y de envÌ≠o necesitamos asegurarnos que se realiza la llamada al mÈtodo correspondiente de la librerÌ≠a de ANIMO.

\textbf{Listeners: }Al listener se le realizaron pruebas de integraciÛn, estas pruebas consistÌ≠an en realizar un envÌ≠o mediante ANIMO pero sin usar la integraciÛn de la capa de comunicaciÛn de nuestro proyecto, de forma que se enviara un dato que se debÌ≠a registrar en nuestro listener y luego al acceder a Èl se comprueba que estÈ correcto.

TambiÈn se realizaron pruebas para la implementaciÛn del modelo simple.

\textbf{Envoltura del modelo simple: }Las pruebas unitarias de Èste mÛdulo consistÌ≠an en comprobar que la envoltura hacÌ≠a las peticiones correspondientes al modelo mockeado. Para ello se realizaron test de validaciÛn de datos, de los mÈtodos que controlan la entrada al modelo, de cambios del estado del modelo al ejecutar un step, y de tratamiento de excepciones para valores no permitidos de los datos.

\textbf{Carga de misiÛn: }Para la carga de misiÛn se comprobÛ que cuando le llegar aun waypoint pidiera el siguiente, que el mÈtodo de control del comando no devolviera true hasta que lo hubiera recibido, comprobar que las transacciones de carga de misiÛn se realizan secuencialmente y que se limpia la misiÛn si ha fallado la transacciÛn.

\textbf{Control de posiciÛn: }En el control de posiciÛn controlamos que se lance una excepciÛn si se inicia el guiado sin que haya una misiÛn cargada y que el guiado se realice secuencialmente.


\newpage
\subsection{Diagrama de burndown}

<<<<<<< HEAD
Para este sprint se estimaron 8 puntos, de los cuales se han realizado 11, debido a que una historia de usuario que tenÌ≠a 3 puntos, concretamente la de set up del entorno se ha realizado en este segundo sprint.
=======
Para este sprint se estimaron 8 puntos, de los cuales se han realizado 11, debido a que una historia de usuario que ten√≠a 3 puntos, concretamente la de set up del entorno se ha realizado en este segundo sprint.
>>>>>>> FETCH_HEAD

\imgCentradaGrande{fig.4.11}{img/diagvelocidad2.eps}{Diagrama de velocidad para el segundo sprint.}

\newpage
\subsection{Diagrama de evoluci√≥n}
\imgCentradaGrande{fig.4.12}{img/diagevolucion2.eps}{Diagrama de evoluci√≥n para el segundo sprint.}

\newpage
\section{Sprint 3: Creaci√≥n del SIMCORE}

<<<<<<< HEAD
\lettrine{D}{durante} este sprint hemos realizado el desarrollo del mÛdulo central de simulaciÛn, proyecto que se encargar· de administrar el funcionamiento del resto de mÛdulos, y de crear un proyecto desde el que podamos manejar el envÌ≠o de datos como si fuera la GCS y que nos sirva para poder realizar pruebas de funcionamiento de una primera versiÛn del sistema de simulaciÛn completo.

\subsubsection{SIMCORE}

\lettrine{U}{na} que hemos creado el mÛdulo de manejo de la aeronave y hemos adaptado su funcionamiento a la recepciÛn de datos externos mediante ANIMO DDS haremos una primera versiÛn del mÛdulo central de simulaciÛn que el cual se encargar· de hacer de puente en el envÌ≠o de datos entre los diferentes mÛdulos, de asegurarse de que el fluye de datos se est· manteniendo bien y de gestionar el envÌ≠o del paso de ejecuciÛn definido por una velocidad en hercios dados por el archivo de configuraciÛn del proyecto.
=======
\lettrine{D}{durante} este sprint hemos realizado el desarrollo del m√≥dulo central de simulaci√≥n, proyecto que se encargar√° de administrar el funcionamiento del resto de m√≥dulos, y de crear un proyecto desde el que podamos manejar el env√≠o de datos como si fuera la GCS y que nos sirva para poder realizar pruebas de funcionamiento de una primera versi√≥n del sistema de simulaci√≥n completo.

\subsubsection{SIMCORE}

\lettrine{U}{na} que hemos creado el m√≥dulo de manejo de la aeronave y hemos adaptado su funcionamiento a la recepci√≥n de datos externos mediante ANIMO DDS haremos una primera versi√≥n del m√≥dulo central de simulaci√≥n que el cual se encargar√° de hacer de puente en el env√≠o de datos entre los diferentes m√≥dulos, de asegurarse de que el fluye de datos se est√° manteniendo bien y de gestionar el env√≠o del paso de ejecuci√≥n definido por una velocidad en hercios dados por el archivo de configuraci√≥n del proyecto.
>>>>>>> FETCH_HEAD

La funci√≥n de la clase principal del n√∫cleo debe ser la de reenviar los mensajes nuevos recibidos por √°nimo, para esto guardar√° en un atributo de la clase la marca de tiempo que tienen todos los mensajes enviados por ANIMO en un mapa, cada tipo de dato que reciba el simulador tendr√° un valor de marca de tiempo guardado en esa variable, de esta manera cuando llegue un dato cuya marca de tiempo difiera de la anterior registrada para ese tipo se reenviar√° este dato al destinatario correspondiente. En cada paso de iteraci√≥n el simulador comprobar√° la marca de tiempo de los datos guardados en los listeners de la capa de comunicaci√≥n y los cotejar√° con las guardadas en nuestro mapa de √∫ltimas marcas de tiempo de forma que si alguna ha cambiado reenviar√° el dato.

<<<<<<< HEAD
El tiempo de duraciÛn del paso de simulaciÛn viene dado por un mÈtodo que calcula cu·nto tiempo debe durar el paso de simulaciÛn seg˙n los hercios a los que se tenga que ejecutar el simulador, dato que se modifica en el archivo de configuraciÛn del proyecto, y cu·nto tiempo ha tardado la ejecuciÛn de la iteraciÛn del simulador de forma que despuÈs se pausar· un tiempo igual a la diferencia entre el tiempo total que debe durar la ejecuciÛn de una iteraciÛn y el tiempo que le llevÛ ejecutar un paso. De esta forma nos aseguramos que todos los pasos de ejecuciÛn duran el mismo tiempo y podemos sincronizar el envÌ≠o y la recepciÛn de datos entre mÛdulos sin que se produzcan errores.
=======
El tiempo de duraci√≥n del paso de simulaci√≥n viene dado por un m√©todo que calcula cu√°nto tiempo debe durar el paso de simulaci√≥n seg√∫n los hercios a los que se tenga que ejecutar el simulador, dato que se modifica en el archivo de configuraci√≥n del proyecto, y cu√°nto tiempo ha tardado la ejecuci√≥n de la iteraci√≥n del simulador de forma que despu√©s se pausar√° un tiempo igual a la diferencia entre el tiempo total que debe durar la ejecuci√≥n de una iteraci√≥n y el tiempo que le llev√≥ ejecutar un paso. De esta forma nos aseguramos que todos los pasos de ejecuci√≥n duran el mismo tiempo y podemos sincronizar el env√≠o y la recepci√≥n de datos entre m√≥dulos sin que se produzcan errores.
>>>>>>> FETCH_HEAD

\subsubsection{GCS para pruebas}

Antes de implementar los cambios en la GCS de Catec para que sea posible su comunicaci√≥n con el resto de m√≥dulos mediante ANIMO, realizaremos una aplicaci√≥n sencilla que se encargue de enviar los mensajes en una secuencia correcta para el sistema de forma que podamos comprobar si la respuesta dada por el simulador es la esperada o hay alg√∫n error durante la comunicaci√≥n con la GCS.

<<<<<<< HEAD
A esta aplicaciÛn se le hizo una interfaz a travÈs de la lÌ≠nea de comandos que te permitÌ≠a enviar varias Ûrdenes. El funcionamiento b·sico consistÌ≠a en enviar un comando de mission request en el que se indicaba el n˙mero de waypoints que se le iban a enviar y luego ir enviando waypoints generados aleatoriamente.

\subsection{Pruebas}

La pruebas realizadas sobre SIMCORE no solo probaban el funcionamiento por separado de las clases, sino que incluÌa una serie de pruebas de integraciÛn y de sistema que nos aseguraba que el simulador respondÌa correctamente frente al resto de mÛdulos.

\textbf{Pruebas unitarias: }Se comprobaba que dado un dato a la clase SimcoreFramework esta fuera capaz de procesarlo, modificar su identificador y volver a publicar el mismo dato recibido. La segunda baterÌa de pruebas se centraba en comprobar que la tasa de ejecuciÛn de varios pasos de simulaciÛn se mantenÌa constante.

\textbf{Pruebas de sistema: }Para las pruebas de sistemas nos creamos una clase de ejecuciÛn independiente al simulador que hacÌa las veces de GCS y de Control  de la aeronave, de forma que se subscribÌa a los datos publicados por el simulador y los enviaba bajos los tÛpicos de la GCS y del Control, de forma que haciendo funcionar a parte el simulador nos permitÌa comprobar si los datos que le envi·bamos eran reenviados a sus respectivos mÛdulos sin ning˙n error.

\subsection{Diagrama de burndown}

En este sprint tenÌ≠amos como objetivo crear la primera versiÛn funcional del simulador y crear una herramienta que nos permitiera probar el sistema, que es la versiÛn de prueba de la GCS. Las dos acciones fueron finalizadas en Èste sprint por lo tanto se cumplieron los objetivos. Al final se realizÛ una prueba global de todo el sistema que confirmaba que todas sus partes funcionaban correctamente y terminamos una primera versiÛn del sistema de simulaciÛn funcionando.
=======
A esta aplicaci√≥n se le hizo una interfaz a trav√©s de la l√≠nea de comandos que te permit√≠a enviar varias √≥rdenes. El funcionamiento b√°sico consist√≠a en enviar un comando de mission request en el que se indicaba el n√∫mero de waypoints que se le iban a enviar y luego ir enviando waypoints generados aleatoriamente.

\subsection{Diagrama de burndown}

En este sprint ten√≠amos como objetivo crear la primera versi√≥n funcional del simulador y crear una herramienta que nos permitiera probar el sistema, que es la versi√≥n de prueba de la GCS. Las dos acciones fueron finalizadas en √©ste sprint por lo tanto se cumplieron los objetivos. Al final se realiz√≥ una prueba global de todo el sistema que confirmaba que todas sus partes funcionaban correctamente y terminamos una primera versi√≥n del sistema de simulaci√≥n funcionando.
>>>>>>> FETCH_HEAD

\imgCentradaGrande{fig.4.13}{img/diagvelocidad3.eps}{Diagrama de velocidad para el tercer sprint.}

\subsection{Diagrama de evoluci√≥n}
\imgCentradaGrande{fig.4.14}{img/diagevolucion3.eps}{Diagrama de evoluci√≥n para el tercer sprint.}


\newpage
\section{Sprint 4: Implementaci√≥n del modelo de Locomove}

<<<<<<< HEAD
\lettrine{E}{l} siguiente paso que tomaremos ser· el de cambiar el modelo simple por el modelo del UAV de Catec Locomove que ser· el que usemos finalmente de forma que tengamos una respuesta fiable y exacta del comportamiento de la aeronave. El modelo simple que est·bamos usando hasta ahora simplemente calculaba una trayectoria rectilÌ≠nea entre el punto en que se encontraba en ese momento y el punto de destino que tenÌ≠a que alcanzar y como salida iba actualizando su posiciÛn. Sin embargo el modelo del Locomove tiene m·s par·metros de entrada y en su salida nos da tambiÈn m·s datos del estado de la aeronave. Hablaremos muy brevemente del uso de Simulink para la creaciÛn de un modelo de simulaciÛn y luego analizaremos los cambios realizados para la implementaciÛn de Èste modelo.
=======
\lettrine{E}{l} siguiente paso que tomaremos ser√° el de cambiar el modelo simple por el modelo del UAV de Catec Locomove que ser√° el que usemos finalmente de forma que tengamos una respuesta fiable y exacta del comportamiento de la aeronave. El modelo simple que est√°bamos usando hasta ahora simplemente calculaba una trayectoria rectil√≠nea entre el punto en que se encontraba en ese momento y el punto de destino que ten√≠a que alcanzar y como salida iba actualizando su posici√≥n. Sin embargo el modelo del Locomove tiene m√°s par√°metros de entrada y en su salida nos da tambi√©n m√°s datos del estado de la aeronave. Hablaremos muy brevemente del uso de Simulink para la creaci√≥n de un modelo de simulaci√≥n y luego analizaremos los cambios realizados para la implementaci√≥n de √©ste modelo.
>>>>>>> FETCH_HEAD

\subsection{Modelos de simulaci√≥n en Matlab Simulink}

<<<<<<< HEAD
\lettrine{E}{s} un entorno visual de programaciÛn que funciona sobre el sistema Matlab. La programaciÛn se realiza a un nivel m·s alto que el lenguaje de programaciÛn de Matlab en sÌ≠. Es una programaciÛn visual donde los componentes de control se incluyen mediante representaciones visuales y la configuraciÛn de un programa se realiza como si hiciÈsemos un mapa de un circuito. Podemos crear "cajas negras" que realizar·n una funciÛn especÌ≠fica, como si fuesen clases de nuestro programa dentro de las cuales los elementos de entrada ir·n a parar a funciones que devolver·n los par·metros de salida de esas mismas cajas. De esta forma se va formando nuestro programa. 
=======
\lettrine{E}{s} un entorno visual de programaci√≥n que funciona sobre el sistema Matlab. La programaci√≥n se realiza a un nivel m√°s alto que el lenguaje de programaci√≥n de Matlab en s√≠. Es una programaci√≥n visual donde los componentes de control se incluyen mediante representaciones visuales y la configuraci√≥n de un programa se realiza como si hici√©semos un mapa de un circuito. Podemos crear "cajas negras" que realizar√°n una funci√≥n espec√≠fica, como si fuesen clases de nuestro programa dentro de las cuales los elementos de entrada ir√°n a parar a funciones que devolver√°n los par√°metros de salida de esas mismas cajas. De esta forma se va formando nuestro programa. 
>>>>>>> FETCH_HEAD

Este modelo recibir√° como par√°metros de entrada un grupo de tres waypoints, siendo el primer el waypoint del que procede, el segundo el waypoint al que se debe dirigir y el √∫ltimo el siguiente waypoint que tiene que alcanzar. Como salida seremos capaces de obtener datos de posici√≥n, altitud, actitud que nos dir√° en qu√© posici√≥n se encuentran los ejes centrales del avi√≥n e informaci√≥n sobre el estado de los componentes de la aeronave.

\subsection{Modificaciones en el c√≥digo para introducir el nuevo modelo}

<<<<<<< HEAD
\lettrine{M}{atlab} Simulink nos genera, a partir del diagrama de cajas creado con su herramienta, un cÛdigo en C++, el cual debemos integrar en nuestro sistema. El modelo era similar al que tenÌ≠amos anteriormente hablando de estructura de clases, pero no en entradas y salidas, por lo que no funcionaba nada m·s implantarlo. Si en un futuro se quisiera modificar de forma sencilla el modelo de aviÛn que se est· simulando se deberÌ≠a diseÒar unas condiciones est·ndar que debieran cumplir los modelos en cuestiÛn de par·metros de entrada y salida para que no haya que realizar ninguna modificaciÛn en el resto de nuestro cÛdigo. Una vez se adaptÛ el sistema de guiado al nuevo modelo, ya que el anterior solo recibÌ≠a un valor de posiciÛn y este espera tres valores, y se subsanaron problemas con los par·metros de entrada de los waypoints, ya que Èste simulador comprobaba que la recepciÛn del dato hubiera sido correcta consultando uno de sus par·metros el cual no se habÌ≠a tenido en cuenta anteriormente, fuimos capaces de compilar el proyecto y empezar con las pruebas.
=======
\lettrine{M}{atlab} Simulink nos genera, a partir del diagrama de cajas creado con su herramienta, un c√≥digo en C++, el cual debemos integrar en nuestro sistema. El modelo era similar al que ten√≠amos anteriormente hablando de estructura de clases, pero no en entradas y salidas, por lo que no funcionaba nada m√°s implantarlo. Si en un futuro se quisiera modificar de forma sencilla el modelo de avi√≥n que se est√° simulando se deber√≠a dise√±ar unas condiciones est√°ndar que debieran cumplir los modelos en cuesti√≥n de par√°metros de entrada y salida para que no haya que realizar ninguna modificaci√≥n en el resto de nuestro c√≥digo. Una vez se adapt√≥ el sistema de guiado al nuevo modelo, ya que el anterior solo recib√≠a un valor de posici√≥n y este espera tres valores, y se subsanaron problemas con los par√°metros de entrada de los waypoints, ya que √©ste simulador comprobaba que la recepci√≥n del dato hubiera sido correcta consultando uno de sus par√°metros el cual no se hab√≠a tenido en cuenta anteriormente, fuimos capaces de compilar el proyecto y empezar con las pruebas.
>>>>>>> FETCH_HEAD

Tambi√©n se modific√≥ la capa de comunicaci√≥n y, por tanto, se realizaron los cambios pertinentes en el simulador para que aceptase los nuevos tipos que surgieron al introducir el nuevo modelo de avi√≥n, ya que algunos par√°metros de control no estaban hechos en ANIMO y hubo que a√±adirlos.

<<<<<<< HEAD
Se realizÛ una modificaciÛn en la funcionalidad de la carga de misiÛn que permitÌ≠a introducir una nueva misiÛn mientras estaba ejecutando una. De esta forma en pleno vuelo se puede cambiar la trayectoria del aviÛn y darle nuevas Ûrdenes como podrÌ≠a ser la de vuelta a casa o la optimizaciÛn de la ruta dependiendo de las condiciones actuales del entorno. Por tanto cuando llega una nueva peticiÛn de carga de misiÛn, el control de la aeronave guarda en un nuevo atributo la nueva misiÛn cargada y cuando recibe la orden de iniciar dicha misiÛn la sustituye dentro del sistema de guiado para que el aviÛn siga la nueva ruta.

Otro inconveniente a tener en cuenta fue el conflicto que surgiÛ al modelar los tipos de datos de Mavlink a tipos de ANIMO, ya que dos tipos casi idÈnticos como eran el mission\_count y el mission\_request se modelaron en un mismo tipo de dato denominado mission\_command, este mission\_command se distinguÌ≠a mediante el tÛpico que llevaba el dato al ser transportado, ya que por exigencias del protocolo de carga de misiÛn el mission\_count siempre iba a enviarse bajo el tÛpico de la GCS y el mission\_request siempre lo iba a enviar el control de la aeronave. Por la estructura interna de ANIMO y DDS resulta que los dos datos llegaban a los dos listeners donde se podÌ≠an discriminar dependiendo del lugar desde el que procedÌ≠an, sin embargo, al publicarlos el simulador les ponÌ≠a su propio tÛpico, ahÌ≠ era cuando no se podÌ≠an distinguir en los destinos quÈ tipo era el que estaba publicando el simulador y esto introducÌ≠a incoherencias dentro de nuestro sistema. Para solucionar este problema se optÛ por modelar los datos de Mavlink en ANIMO por separado, al tratarse de dos tipos de datos distintos este problema dejÛ de darse.

\subsection{Diagrama de burndown}

En este sprint nos comprometimos a realizar la introducciÛn del nuevo modelo y de implementar nuestro sistema con la GCS de Catec, al encontrarnos con muchos problemas a la hora de realizar la implementaciÛn de la envoltura del nuevo modelo de aviÛn no pudimos completar todas las historias de usuario de este sprint lo cual se representa como una caÌ≠da en el rendimiento de la velocidad del equipo de desarrollo.
=======
Se realiz√≥ una modificaci√≥n en la funcionalidad de la carga de misi√≥n que permit√≠a introducir una nueva misi√≥n mientras estaba ejecutando una. De esta forma en pleno vuelo se puede cambiar la trayectoria del avi√≥n y darle nuevas √≥rdenes como podr√≠a ser la de vuelta a casa o la optimizaci√≥n de la ruta dependiendo de las condiciones actuales del entorno. Por tanto cuando llega una nueva petici√≥n de carga de misi√≥n, el control de la aeronave guarda en un nuevo atributo la nueva misi√≥n cargada y cuando recibe la orden de iniciar dicha misi√≥n la sustituye dentro del sistema de guiado para que el avi√≥n siga la nueva ruta.

Otro inconveniente a tener en cuenta fue el conflicto que surgi√≥ al modelar los tipos de datos de Mavlink a tipos de ANIMO, ya que dos tipos casi id√©nticos como eran el mission\_count y el mission\_request se modelaron en un mismo tipo de dato denominado mission\_command, este mission\_command se distingu√≠a mediante el t√≥pico que llevaba el dato al ser transportado, ya que por exigencias del protocolo de carga de misi√≥n el mission\_count siempre iba a enviarse bajo el t√≥pico de la GCS y el mission\_request siempre lo iba a enviar el control de la aeronave. Por la estructura interna de ANIMO y DDS resulta que los dos datos llegaban a los dos listeners donde se pod√≠an discriminar dependiendo del lugar desde el que proced√≠an, sin embargo, al publicarlos el simulador les pon√≠a su propio t√≥pico, ah√≠ era cuando no se pod√≠an distinguir en los destinos qu√© tipo era el que estaba publicando el simulador y esto introduc√≠a incoherencias dentro de nuestro sistema. Para solucionar este problema se opt√≥ por modelar los datos de Mavlink en ANIMO por separado, al tratarse de dos tipos de datos distintos este problema dej√≥ de darse.

\subsection{Diagrama de burndown}

En este sprint nos comprometimos a realizar la introducci√≥n del nuevo modelo y de implementar nuestro sistema con la GCS de Catec, al encontrarnos con muchos problemas a la hora de realizar la implementaci√≥n de la envoltura del nuevo modelo de avi√≥n no pudimos completar todas las historias de usuario de este sprint lo cual se representa como una ca√≠da en el rendimiento de la velocidad del equipo de desarrollo.
>>>>>>> FETCH_HEAD

\imgCentradaGrande{fig.4.15}{img/diagvelocidad4.eps}{Diagrama de velocidad para el cuarto sprint.}

\subsection{Diagrama de evoluci√≥n}
\imgCentradaGrande{fig.4.15}{img/diagevolucion4.eps}{Diagrama de evoluci√≥n para el cuarto sprint.}

\newpage
\section{Sprint 5: Introducci√≥n de la GCS de Catec}

<<<<<<< HEAD
\lettrine{E}{n} este sprint vamos a introducir en nuestro sistema la GCS de Catec, uno de los objetivos fundamentales consistÌ≠a en que el alumno que fuera a usar nuestra plataforma con el fin de realizar pr·cticas de vuelo no tripulado debÌ≠a de ser conocedor y de poder trabajar con la herramienta de control de aviones no tripulados de Catec o estaciÛn de control de tierra. Por ello despuÈs de las pruebas iniciales de funcionamiento del simulador nos dispondremos a integrar la herramienta real al sistema. Primero explicaremos el uso de una herramienta que nos asegurÛ que la aeronave estaba siguiendo las rutas correctamente.

\subsection{Visualizador basado en Marble y problema de loiter}

\lettrine{H}{asta} ahora la ˙nica forma que hemos tenido de visualizar el progreso de una misiÛn en curso era imprimiendo en la salida est·ndar de nuestro sistema operativo la posiciÛn y los datos que nos eran relevantes y comprobar la direcciÛn en la que se movÌ≠an seg˙n las coordenadas o ver si se acercaba al punto que le indic·bamos, pero esta es una forma muy poco intuitiva y no podemos ver potenciales errores en el movimiento de la aeronave, por ello y antes de introducir la GCS en el sistema creamos una herramienta de visualizaciÛn basada en Marble.

Marble es una aplicaciÛn geogr·fica desarrollada por KDE y distribuida bajo licencia GNU LGPL y nos provee herramientas parecidas a las de Google Maps, pudiendo representar sobre un mapa terrestre una posiciÛn dando sus coordenadas globales. Nuestra aplicaciÛn era muy simple y solo consistÌ≠a en una ventana en la cual se representaba el mapa y sobre Èl la posiciÛn de la aeronave. 

Para tomar estos datos nos subscribÌ≠amos por ANIMO DDS al dato de posiciÛn y lo actualiz·bamos seg˙n un ratio de refresco prefijado. Gracias al patrÛn publicador subscriptor nos fue muy sencillo realizar una aplicaciÛn de este estilo ya que ˙nicamente sabiendo el tÛpico y el tipo de dato mediante una configuraciÛn sencilla de la herramienta de ANIMO pudimos recoger el dato actualizado y representarlo.

Una vez usada Èsta herramienta hicimos dos comprobaciones, la primera era que cuando se realiza una misiÛn de un solo waypoint, seg˙n el comportamiento observado por los datos de posiciÛn pens·bamos que el modelo del aviÛn se quedaba girando en torno al waypoint, al poder observarlo en el mapa nos dimos cuenta de que no giraba en torno al waypoint sino que una vez llegado a Èl intentaba volver a alcanzarlo haciendo que se forzase la aeronave a realizar giros pronunciados, lo cual se debÌ≠a corregir ya que podrÌ≠a producirse alg˙n error por este motivo.

La otra observaciÛn fue la del funcionamiento del waypoint tipo loiter. Los waypoints tienen una serie de atributos de comandos para indicar acciones cuando se llegue a ellos, una de estas acciones es la de hacer lioter, que consiste en girar con un radio dado por un par·metro en el mismo waypoint usando el waypoint como centro de la circunferencia a trazar. En el modelo de Simulink el loiter anulaba el mÛdulo que generaba el mensaje de aviso de que se habÌ≠a alcanzado un waypoint, este mensaje se denomina "detect", el loiter, al tener que mantener el aviÛn girando en torno a un waypoint no debe activar el detect por que si no el sistema de guiado mandarÌ≠a el siguiente waypoint, sin embargo, el modelo de simulink guardaba el ˙ltimo valor obtenido en el detect, por tanto cuando llegaba al waypoint anterior y se cambiaba al loiter se mantiene el valor del detect y para el sistema es como si hubiera llegado por lo que se lo saltaba.

=======
\lettrine{E}{n} este sprint vamos a introducir en nuestro sistema la GCS de Catec, uno de los objetivos fundamentales consist√≠a en que el alumno que fuera a usar nuestra plataforma con el fin de realizar pr√°cticas de vuelo no tripulado deb√≠a de ser conocedor y de poder trabajar con la herramienta de control de aviones no tripulados de Catec o estaci√≥n de control de tierra. Por ello despu√©s de las pruebas iniciales de funcionamiento del simulador nos dispondremos a integrar la herramienta real al sistema. Primero explicaremos el uso de una herramienta que nos asegur√≥ que la aeronave estaba siguiendo las rutas correctamente.

\subsection{Visualizador basado en Marble y problema de loiter}

\lettrine{H}{asta} ahora la √∫nica forma que hemos tenido de visualizar el progreso de una misi√≥n en curso era imprimiendo en la salida est√°ndar de nuestro sistema operativo la posici√≥n y los datos que nos eran relevantes y comprobar la direcci√≥n en la que se mov√≠an seg√∫n las coordenadas o ver si se acercaba al punto que le indic√°bamos, pero esta es una forma muy poco intuitiva y no podemos ver potenciales errores en el movimiento de la aeronave, por ello y antes de introducir la GCS en el sistema creamos una herramienta de visualizaci√≥n basada en Marble.

Marble es una aplicaci√≥n geogr√°fica desarrollada por KDE y distribuida bajo licencia GNU LGPL y nos provee herramientas parecidas a las de Google Maps, pudiendo representar sobre un mapa terrestre una posici√≥n dando sus coordenadas globales. Nuestra aplicaci√≥n era muy simple y solo consist√≠a en una ventana en la cual se representaba el mapa y sobre √©l la posici√≥n de la aeronave. 

Para tomar estos datos nos subscrib√≠amos por ANIMO DDS al dato de posici√≥n y lo actualiz√°bamos seg√∫n un ratio de refresco prefijado. Gracias al patr√≥n publicador subscriptor nos fue muy sencillo realizar una aplicaci√≥n de este estilo ya que √∫nicamente sabiendo el t√≥pico y el tipo de dato mediante una configuraci√≥n sencilla de la herramienta de ANIMO pudimos recoger el dato actualizado y representarlo.

Una vez usada √©sta herramienta hicimos dos comprobaciones, la primera era que cuando se realiza una misi√≥n de un solo waypoint, seg√∫n el comportamiento observado por los datos de posici√≥n pens√°bamos que el modelo del avi√≥n se quedaba girando en torno al waypoint, al poder observarlo en el mapa nos dimos cuenta de que no giraba en torno al waypoint sino que una vez llegado a √©l intentaba volver a alcanzarlo haciendo que se forzase la aeronave a realizar giros pronunciados, lo cual se deb√≠a corregir ya que podr√≠a producirse alg√∫n error por este motivo.

La otra observaci√≥n fue la del funcionamiento del waypoint tipo loiter. Los waypoints tienen una serie de atributos de comandos para indicar acciones cuando se llegue a ellos, una de estas acciones es la de hacer lioter, que consiste en girar con un radio dado por un par√°metro en el mismo waypoint usando el waypoint como centro de la circunferencia a trazar. En el modelo de Simulink el loiter anulaba el m√≥dulo que generaba el mensaje de aviso de que se hab√≠a alcanzado un waypoint, este mensaje se denomina "detect", el loiter, al tener que mantener el avi√≥n girando en torno a un waypoint no debe activar el detect por que si no el sistema de guiado mandar√≠a el siguiente waypoint, sin embargo, el modelo de simulink guardaba el √∫ltimo valor obtenido en el detect, por tanto cuando llegaba al waypoint anterior y se cambiaba al loiter se mantiene el valor del detect y para el sistema es como si hubiera llegado por lo que se lo saltaba.
>>>>>>> FETCH_HEAD



<<<<<<< HEAD
\lettrine{A}{} la hora de introducir la GCS el primer paso consiste en realizar la instalaciÛn. La instalaciÛn requiere de una serie de dependencias y librerÌ≠as que al ser ajenas al proyecto actual no voy a enumerar, pero requiere de tener instalados Qt5 principalmente ya que hace mucho uso de seÒales, de las cuales os hablarÈ en el ˙ltimo capÌ≠tulo de este apartado. 

El uso hasta ahora que se habÌ≠a hecho de la GCS usaba comunicaciones mediante el protocolo UDP, por tanto tanto el protocolo de Mavlink como la GCS est·n preparadas para comunicarse de esta manera. Pero por la forma en que est· diseÒada la GCS podemos aprovechar las seÒales que emite para conectarlas con una aplicaciÛn externa.
=======
\subsection{Introducci√≥n de la GCS}

\lettrine{A}{} la hora de introducir la GCS el primer paso consiste en realizar la instalaci√≥n. La instalaci√≥n requiere de una serie de dependencias y librer√≠as que al ser ajenas al proyecto actual no voy a enumerar, pero requiere de tener instalados Qt5 principalmente ya que hace mucho uso de se√±ales, de las cuales os hablar√© en el √∫ltimo cap√≠tulo de este apartado. 
>>>>>>> FETCH_HEAD

El uso hasta ahora que se hab√≠a hecho de la GCS usaba comunicaciones mediante el protocolo UDP, por tanto tanto el protocolo de Mavlink como la GCS est√°n preparadas para comunicarse de esta manera. Pero por la forma en que est√° dise√±ada la GCS podemos aprovechar las se√±ales que emite para conectarlas con una aplicaci√≥n externa.

<<<<<<< HEAD
Debido a que la clase que recoge los datos por UDP para tratarlos como la que los publica por este medio se une con estos sistemas mediante seÒales de Qt vamos a aprovecharnos de esta funcionalidad. Las seÒales de Qt con una herramienta mediante las que puedes unir dos mÈtodos de dos clases cualesquiera, aunque no compartan dependencias ni relaciÛn de forma que puedas pasarle par·metros, un mÈtodo emite una seÒal y esa seÒal se trata en un bucle especÌ≠fico de Qt y se envÌ≠a al mÈtodo con el que se haya realizado la conexiÛn. De esta forma crearemos un nuevo tipo de listener que heredar· de nuestro listener de ANIMO pero aÒadir· la funcionalidad de emitir seÒales de Qt cuando le haya llegado un nuevo dato. AsÌ≠ no tendremos que estar consultando el dato almacenado en el listener, sino que sabremos cuando ha llegado un dato nuevo. Cuando llega un dato nuevo se emite una seÒal que durante la instanciaciÛn del plugin ha sido conectada con el mÈtodo de la GCS que se dedica a tratar los datos que provienen de fuera de la aplicaciÛn. De la misma forma cuando la GCS tiene que enviar un dato emite una seÒal, la cual conectaremos con la clase del plugin que realiza la publicaciÛn mediante ANIMO.
=======
Al estar la GCS basada en plugins podemos usar esta funcionalidad para crear una interfaz para las comunicaciones mediante DDS RTI con ANIMO. La funcionalidad de nuestro plugin ser√° principalmente recoger los datos publicados por el simulador que van destinados hacia la GCS, realizar una traducci√≥n del dato de ANIMO a un dato de las interfaces de Mavlink (que son los datos que trabjan en la GCS) e introducirlos en el sistema de la GCS, recogiendo la respuesta de √©sta, volviendo a realizar la traducci√≥n externa y publicar estos datos mediante ANIMO.
>>>>>>> FETCH_HEAD

Debido a que la clase que recoge los datos por UDP para tratarlos como la que los publica por este medio se une con estos sistemas mediante se√±ales de Qt vamos a aprovecharnos de esta funcionalidad. Las se√±ales de Qt con una herramienta mediante las que puedes unir dos m√©todos de dos clases cualesquiera, aunque no compartan dependencias ni relaci√≥n de forma que puedas pasarle par√°metros, un m√©todo emite una se√±al y esa se√±al se trata en un bucle espec√≠fico de Qt y se env√≠a al m√©todo con el que se haya realizado la conexi√≥n. De esta forma crearemos un nuevo tipo de listener que heredar√° de nuestro listener de ANIMO pero a√±adir√° la funcionalidad de emitir se√±ales de Qt cuando le haya llegado un nuevo dato. As√≠ no tendremos que estar consultando el dato almacenado en el listener, sino que sabremos cuando ha llegado un dato nuevo. Cuando llega un dato nuevo se emite una se√±al que durante la instanciaci√≥n del plugin ha sido conectada con el m√©todo de la GCS que se dedica a tratar los datos que provienen de fuera de la aplicaci√≥n. De la misma forma cuando la GCS tiene que enviar un dato emite una se√±al, la cual conectaremos con la clase del plugin que realiza la publicaci√≥n mediante ANIMO.

Para finalizar se realiz√≥ una interfaz al plugin de forma que mediante un formulario se pudiera configurar los par√°metros de ANIMO.

\subsection{Diagrama de burndown}

Este sprint se dedic√≥ al funcionamiento de la GCS casi en su totalidad, ya que no solo debimos instalarla sino averiguar su funcionamiento tras horas de lectura de su c√≥digo y del estudio de Qt, por tanto nos llev√≥ m√°s tiempo del esperado y la integraci√≥n de nuestro plugin no se termin√≥ en este sprint sino en el siguiente, por eso las gr√°ficas muestran que no ha habido una evoluci√≥n en las historias de usuario.

\imgCentradaGrande{fig.4.17}{img/diagvelocidad5.eps}{Diagrama de velocidad para el quinto sprint.}

\subsection{Diagrama de evoluci√≥n}
\imgCentradaGrande{fig.4.18}{img/diagevolucion5.eps}{Diagrama de evoluci√≥n para el quinto sprint.}

\newpage
\section{Sprint 6: Puesto de instructor}

<<<<<<< HEAD
\lettrine{D}{durante} este sprint nos centraremos en realizar el diseÒo y set up del proyecto del puesto de instructor y de implementar las funcionalidades necesarias en el mismo. Haremos un repaso sobre quÈ componentes y tecnologÌ≠as usa y luego enumeraremos sus distintas funcionalidades y como se han implementado.

\subsubsection{Estructura y set up}

\lettrine{A}{l} ser un proyecto web en Java podemos aprovechar la gran cantidad de frameworks, librerÌ≠as y herramientas que existen para Èste fin y que nos facilitan tanto el desarrollo como el futuro mantenimiento y posible cambio de la funcionalidad de la aplicaciÛn. Por supuesto haremos uso de la metodologÌ≠a de programaciÛn denominada inversiÛn de control que nos permitir· m·s flexibilidad a la hora de implementar las dependencias, ya que todos los objetos son creados en un contenedor al cual podemos acceder llamando una instancia del mismo desde cualquier parte del cÛdigo y que nos proveer· de los objetos que necesitemos sin que tengamos que estar encapsulando objetos unos en otros. …sta tÈcnica la implementaremos mediante el uso del framework Spring, el cual a parte de Èsta funcionalidad nos provee de muchas m·s herramientas ˙tiles, por ejemplo, a la hora de implementar la persistencia de datos.
=======
\lettrine{D}{durante} este sprint nos centraremos en realizar el dise√±o y set up del proyecto del puesto de instructor y de implementar las funcionalidades necesarias en el mismo. Haremos un repaso sobre qu√© componentes y tecnolog√≠as usa y luego enumeraremos sus distintas funcionalidades y como se han implementado.

\subsubsection{Estructura y set up}

\lettrine{A}{l} ser un proyecto web en Java podemos aprovechar la gran cantidad de frameworks, librer√≠as y herramientas que existen para √©ste fin y que nos facilitan tanto el desarrollo como el futuro mantenimiento y posible cambio de la funcionalidad de la aplicaci√≥n. Por supuesto haremos uso de la metodolog√≠a de programaci√≥n denominada inversi√≥n de control que nos permitir√° m√°s flexibilidad a la hora de implementar las dependencias, ya que todos los objetos son creados en un contenedor al cual podemos acceder llamando una instancia del mismo desde cualquier parte del c√≥digo y que nos proveer√° de los objetos que necesitemos sin que tengamos que estar encapsulando objetos unos en otros. √âsta t√©cnica la implementaremos mediante el uso del framework Spring, el cual a parte de √©sta funcionalidad nos provee de muchas m√°s herramientas √∫tiles, por ejemplo, a la hora de implementar la persistencia de datos.
>>>>>>> FETCH_HEAD

Para la vista web como para la implementaci√≥n del Modelo-Vista-Controlador usaremos Struts 2 con Convention Plugin. Esto nos permitir√° unir las acciones a la vista de forma sencilla e intuitiva, de forma que podamos unir nuestras clases java con las peticiones realizadas por el usuario desde el navegador.

Tambi√©n implementamos la persistencia con Hibernate de forma que autom√°ticamente nos crease una base de datos con las tablas que necesit√°semos. El uso de esta base de datos a√∫n no est√° implementado pero en un futuro si podr√° funcionar con la implementaci√≥n que realizamos.

<<<<<<< HEAD
Todas las dependencias vienen gestionada mediante Maven, al tener tantas tecnologÌ≠as trabajando juntas tenemos el problema que algunas de ellas comparten librerÌ≠as por lo que puede haber errores a la hora de instalar las versiones de cada una de ellas, esto supuso un gran problema de manera que cuando conseguimos hacer funcionar todas nos creamos mediante Maven un arquetipo que nos permitiera guardar un set up de proyecto de forma que la prÛxima vez que se realizara un proyecto de Èstas caracterÌ≠sticas tendrÌ≠amos ya todo configurado.

Los m·s complicado fue aÒadir DDS RTI al proyecto del puesto de instructor, ya que ANIMO no tiene librerÌ≠as para Java, solo para C++, de forma que tuvimos que implementar directamente una envoltura para RTI DDS que funciona a mucho m·s bajo nivel, de forma que tenÌ≠amos que gestionar las calidades de servicios, la creaciÛn de los participantes que son los objetos encargados del envÌ≠o y recepciÛn de datos por la red y de crear los objetos IDL para cada uno de los datos que tenÌ≠amos que enviar. Todo esto lo hace ANIMO autom·ticamente pero al no poder usarlo hicimos una implementaciÛn manual de las librerÌ≠as de RTI. Al adaptarlo el funcionamiento es parecido al del resto de mÛdulos, tenemos una serie de listeners que almacenan el dato recibido.
=======
Todas las dependencias vienen gestionada mediante Maven, al tener tantas tecnolog√≠as trabajando juntas tenemos el problema que algunas de ellas comparten librer√≠as por lo que puede haber errores a la hora de instalar las versiones de cada una de ellas, esto supuso un gran problema de manera que cuando conseguimos hacer funcionar todas nos creamos mediante Maven un arquetipo que nos permitiera guardar un set up de proyecto de forma que la pr√≥xima vez que se realizara un proyecto de √©stas caracter√≠sticas tendr√≠amos ya todo configurado.

Los m√°s complicado fue a√±adir DDS RTI al proyecto del puesto de instructor, ya que ANIMO no tiene librer√≠as para Java, solo para C++, de forma que tuvimos que implementar directamente una envoltura para RTI DDS que funciona a mucho m√°s bajo nivel, de forma que ten√≠amos que gestionar las calidades de servicios, la creaci√≥n de los participantes que son los objetos encargados del env√≠o y recepci√≥n de datos por la red y de crear los objetos IDL para cada uno de los datos que ten√≠amos que enviar. Todo esto lo hace ANIMO autom√°ticamente pero al no poder usarlo hicimos una implementaci√≥n manual de las librer√≠as de RTI. Al adaptarlo el funcionamiento es parecido al del resto de m√≥dulos, tenemos una serie de listeners que almacenan el dato recibido.
>>>>>>> FETCH_HEAD

El √∫ltimo paso para tenerlo todo funcionando y probar es instalarnos Tomcat que lo usaremos en su versi√≥n 7. Tomcat es un contenedor de servlets e implementa las especificaciones de los servlets de JavaServer Pages (JSP) de Oracle, que usaremos para programar las vistas de nuestro puesto de instructor. Una vez instalado solo debemos crear nuestro paquete .war directamente desde el IDE de Java y desplegarlos sobre tomcat para tener nuestro servidor funcionando y poder acceder a la p√°gina web.

\subsubsection{Funcionalidad del puesto de instructor}

\lettrine{L}{a} funcionalidad principal del puesto de instructor se basa en dos puntos claves, por un lado monitorizar las acciones del alumno durante la misi√≥n de pr√°cticas o de examen y por otra parte ser capaz de controlar los par√°metros de la misi√≥n e introducir errores.

<<<<<<< HEAD
El primer paso fue crear una serie de estados en el simulador que nos permitiera controlar el paso de ejecuciÛn de forma que se pausara y se pudiera reanudar. Para ello se crea una clase en el simulador que se dedica al tratamiento de los comandos de control de la misiÛn, esta clase discrimina entre los diferentes comandos implementados y controla el envÌ≠o del paso de simulaciÛn. Luego se implementaron una serie de botones en la vista que cuya funciÛn simplemente residÌ≠a en enviar mediante ANIMO el mensaje correspondiente.
=======
El primer paso fue crear una serie de estados en el simulador que nos permitiera controlar el paso de ejecuci√≥n de forma que se pausara y se pudiera reanudar. Para ello se crea una clase en el simulador que se dedica al tratamiento de los comandos de control de la misi√≥n, esta clase discrimina entre los diferentes comandos implementados y controla el env√≠o del paso de simulaci√≥n. Luego se implementaron una serie de botones en la vista que cuya funci√≥n simplemente resid√≠a en enviar mediante ANIMO el mensaje correspondiente.
>>>>>>> FETCH_HEAD

\subsection{Diagrama de burndown}

Las tareas para este sprint fueron, a parte de acabar las que no se terminaron en el anterior, crear una primera versi√≥n del puesto de instructor, la cual se realiz√≥ satisfactoriamente ya que funcionaba bien con el resto de componentes.

\imgCentradaGrande{fig.4.19}{img/diagvelocidad6.eps}{Diagrama de velocidad para el sexto sprint.}

\subsection{Diagrama de evoluci√≥n}

\imgCentradaGrande{fig.4.20}{img/diagevolucion6.eps}{Diagrama de velocidad para el sexto sprint.}

\newpage
\section{Sprint 7: Primera versi√≥n y cambios en el objetivo}

\lettrine{C}{uando} tuvimos la reuni√≥n de retrospectiva del sprint anterior analizamos el estado y el funcionamiento del proyecto y los cambios que se deber√≠an realizar para mejorar la funcionalidad. Durante esta reuni√≥n decidimos que el mantenimiento y desarrollo de la aplicaci√≥n de controlador y envoltura del modelo del UAV resultaba muy costoso y nos retrasaba mucho ya que cualquier cambio en el resto del sistema supon√≠a tener que tocar la forma en que se interaccionaba con el modelo. Adem√°s el equipo de avi√≥nica tiene modelos de prueba integrados con el control y una m√°quina de estados que tendr√≠amos que implementar nosotros en nuestro control de envoltura del modelo cuando ellos ya lo tienen probado y es el control que va en el autopiloto real del avi√≥n. Tambi√©n se hizo hincapi√© en tener control sobre la misi√≥n, ahora en la primera versi√≥n del puesto de instructor somos capaces de pausar y reanudar la misi√≥n pero tambi√©n deber√≠amos controlar el inicio y el fin de la misma. La √∫ltima observaci√≥n fue sobre la funci√≥n del n√∫cleo del simulador, ahora pasan por √©l todos los mensajes y la √∫nica acci√≥n que realiza es la de reenviarlos. A continuaci√≥n repasaremos estos tres puntos revisando los pros y los contras de las dos versiones propuestas.

\subsection{An√°lisis del estado del proyecto}

<<<<<<< HEAD
\lettrine{C}{uando} tuvimos la reuniÛn de retrospectiva del sprint anterior analizamos el estado y el funcionamiento del proyecto y los cambios que se deberÌ≠an realizar para mejorar la funcionalidad. Durante esta reuniÛn decidimos que el mantenimiento y desarrollo de la aplicaciÛn de controlador y envoltura del modelo del UAV resultaba muy costoso y nos retrasaba mucho ya que cualquier cambio en el resto del sistema suponÌ≠a tener que tocar la forma en que se interaccionaba con el modelo. Adem·s el equipo de aviÛnica tiene modelos de prueba integrados con el control y una m·quina de estados que tendrÌ≠amos que implementar nosotros en nuestro control de envoltura del modelo cuando ellos ya lo tienen probado y es el control que va en el autopiloto real del aviÛn. TambiÈn se hizo hincapiÈ en tener control sobre la misiÛn, ahora en la primera versiÛn del puesto de instructor somos capaces de pausar y reanudar la misiÛn pero tambiÈn deberÌ≠amos controlar el inicio y el fin de la misma. La ˙ltima observaciÛn fue sobre la funciÛn del n˙cleo del simulador, ahora pasan por Èl todos los mensajes y la ˙nica acciÛn que realiza es la de reenviarlos. A continuaciÛn repasaremos estos tres puntos revisando los pros y los contras de las dos versiones propuestas.

\subsection{An·lisis del estado del proyecto}

\lettrine{L}{a} modificaciÛn m·s radical fue la de usar el autopiloto embarcado como medio de simulaciÛn de la aeronave, 
=======
\lettrine{L}{a} modificaci√≥n m√°s radical fue la de usar el autopiloto embarcado como medio de simulaci√≥n de la aeronave, 
>>>>>>> FETCH_HEAD

\subsection{Diagrama de burndown}
%\imgCentradaGrande{fig.4.21}{img/diagvelocidad7.eps}{Diagrama de velocidad para el s√©ptimo sprint.}

\newpage
\section{Sprint 8: Cambios en el dise√±o}

\subsection{Diagrama de burndown}
%\imgCentradaGrande{fig.4.23}{img/diagvelocidad8.eps}{Diagrama de velocidad para el octavo sprint.}

\part{Conclusiones}

\part{Ap√©ndices}

\end{document}
